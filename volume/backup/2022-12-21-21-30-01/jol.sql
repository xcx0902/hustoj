-- MySQL dump 10.13  Distrib 5.7.33, for Linux (x86_64)
--
-- Host: localhost    Database: jol
-- ------------------------------------------------------
-- Server version	5.7.33-0ubuntu0.16.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `jol`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `jol` /*!40100 DEFAULT CHARACTER SET latin1 */;

USE `jol`;

--
-- Table structure for table `balloon`
--

DROP TABLE IF EXISTS `balloon`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `balloon` (
  `balloon_id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` char(48) NOT NULL,
  `sid` int(11) NOT NULL,
  `cid` int(11) NOT NULL,
  `pid` int(11) NOT NULL,
  `status` smallint(6) NOT NULL DEFAULT '0',
  PRIMARY KEY (`balloon_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `balloon`
--

LOCK TABLES `balloon` WRITE;
/*!40000 ALTER TABLE `balloon` DISABLE KEYS */;
/*!40000 ALTER TABLE `balloon` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `compileinfo`
--

DROP TABLE IF EXISTS `compileinfo`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `compileinfo` (
  `solution_id` int(11) NOT NULL DEFAULT '0',
  `error` text,
  PRIMARY KEY (`solution_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `compileinfo`
--

LOCK TABLES `compileinfo` WRITE;
/*!40000 ALTER TABLE `compileinfo` DISABLE KEYS */;
INSERT INTO `compileinfo` VALUES (1016,'Main.cc: In function \'void Add(long long int, long long int, long long int, long long int, long long int, long long int)\':\nMain.cc:6:15: warning: suggest parentheses around \'+\' inside \'>>\' [-Wparentheses]\n    6 | #define mid (l+r>>1)\n      |              ~^~\nMain.cc:7:19: note: in expansion of macro \'mid\'\n    7 | #define lson ls,l,mid\n      |                   ^~~\nMain.cc:37:9: note: in expansion of macro \'lson\'\n   37 |     Add(lson,s,t,z);\n      |         ^~~~\nMain.cc:6:15: warning: suggest parentheses around \'+\' inside \'>>\' [-Wparentheses]\n    6 | #define mid (l+r>>1)\n      |              ~^~\nMain.cc:8:17: note: in expansion of macro \'mid\'\n    8 | #define rson rs,mid+1,r\n      |                 ^~~\nMain.cc:38:9: note: in expansion of macro \'rson\'\n   38 |     Add(rson,s,t,z);\n      |         ^~~~\nMain.cc: In function \'long long int Max(long long int, long long int, long long int, long long int, long long int)\':\nMain.cc:6:15: warning: suggest parentheses around \'+\' inside \'>>\' [-Wparentheses]\n    6 | #define mid (l+r>>1)\n      |              ~^~\nMain.cc:7:19: note: in expansion of macro \'mid\'\n    7 | #define lson ls,l,mid\n      |                   ^~~\nMain.cc:50:20: note: in expansion of macro \'lson\'\n   50 |     return max(Max(lson,s,t),Max(rson,s,t));\n      |                    ^~~~\nMain.cc:6:15: warning: suggest parentheses around \'+\' inside \'>>\' [-Wparentheses]\n    6 | #define mid (l+r>>1)\n      |              ~^~\nMain.cc:8:17: note: in expansion of macro \'mid\'\n    8 | #define rson rs,mid+1,r\n      |                 ^~~\nMain.cc:50:34: note: in expansion of macro \'rson\'\n   50 |     return max(Max(lson,s,t),Max(rson,s,t));\n      |                                  ^~~~\n'),(1024,'Main.cc: In function \'void build(long long int, long long int, long long int)\':\nMain.cc:35:15: warning: suggest parentheses around \'+\' inside \'>>\' [-Wparentheses]\n   35 |     int mid=ll+rr>>1;\n      |             ~~^~~\nMain.cc:40:39: error: no matching function for call to \'max(long long int&, int)\'\n   40 |         lx[mid]=rx[mid]=max(val[mid],0);\n      |                                       ^\nIn file included from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from Main.cc:1:\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note: candidate: \'template<class _Tp> const _Tp& std::max(const _Tp&, const _Tp&)\'\n  222 |     max(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template argument deduction/substitution failed:\nMain.cc:40:39: note:   deduced conflicting types for parameter \'const _Tp\' (\'long long int\' and \'int\')\n   40 |         lx[mid]=rx[mid]=max(val[mid],0);\n      |                                       ^\nIn file included from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from Main.cc:1:\n/usr/include/c++/9/bits/stl_algobase.h:268:5: note: candidate: \'template<class _Tp, class _Compare> const _Tp& std::max(const _Tp&, const _Tp&, _Compare)\'\n  268 |     max(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5: note:   template argument deduction/substitution failed:\nMain.cc:40:39: note:   deduced conflicting types for parameter \'const _Tp\' (\'long long int\' and \'int\')\n   40 |         lx[mid]=rx[mid]=max(val[mid],0);\n      |                                       ^\nIn file included from /usr/include/c++/9/algorithm:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from Main.cc:1:\n/usr/include/c++/9/bits/stl_algo.h:3462:5: note: candidate: \'template<class _Tp> _Tp std::max(std::initializer_list<_Tp>)\'\n 3462 |     max(initializer_list<_Tp> __l)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algo.h:3462:5: note:   template argument deduction/substitution failed:\nMain.cc:40:39: note:   mismatched types \'std::initializer_list<_Tp>\' and \'long long int\'\n   40 |         lx[mid]=rx[mid]=max(val[mid],0);\n      |                                       ^\nIn file included from /usr/include/c++/9/algorithm:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from Main.cc:1:\n/usr/include/c++/9/bits/stl_algo.h:3468:5: note: candidate: \'template<class _Tp, class _Compare> _Tp std::max(std::initializer_list<_Tp>, _Compare)\'\n 3468 |     max(initializer_list<_Tp> __l, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algo.h:3468:5: note:   template argument deduction/substitution failed:\nMain.cc:40:39: note:   mismatched types \'std::initializer_list<_Tp>\' and \'long long int\'\n   40 |         lx[mid]=rx[mid]=max(val[mid],0);\n      |                                       ^\nMain.cc: In function \'void change(long long int, long long int)\':\nMain.cc:87:24: error: no matching function for call to \'max(long long int&, int)\'\n   87 |     lx[z]=rx[z]=max(w,0);\n      |                        ^\nIn file included from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from Main.cc:1:\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note: candidate: \'template<class _Tp> const _Tp& std::max(const _Tp&, const _Tp&)\'\n  222 |     max(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template argument deduction/substitution failed:\nMain.cc:87:24: note:   deduced conflicting types for parameter \'const _Tp\' (\'long long int\' and \'int\')\n   87 |     lx[z]=rx[z]=max(w,0);\n      |                        ^\nIn file included from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from Main.cc:1:\n/usr/include/c++/9/bits/stl_algobase.h:268:5: note: candidate: \'template<class _Tp, class _Compare> const _Tp& std::max(const _Tp&, const _Tp&, _Compare)\'\n  268 |     max(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5: note:   template argument deduction/substitution failed:\nMain.cc:87:24: note:   deduced conflicting types for parameter \'const _Tp\' (\'long long int\' and \'int\')\n   87 |     lx[z]=rx[z]=max(w,0);\n      |                        ^\nIn file included from /usr/include/c++/9/algorithm:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from Main.cc:1:\n/usr/include/c++/9/bits/stl_algo.h:3462:5: note: candidate: \'template<class _Tp> _Tp std::max(std::initializer_list<_Tp>)\'\n 3462 |     max(initializer_list<_Tp> __l)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algo.h:3462:5: note:   template argument deduction/substitution failed:\nMain.cc:87:24: note:   mismatched types \'std::initializer_list<_Tp>\' and \'long long int\'\n   87 |     lx[z]=rx[z]=max(w,0);\n      |                        ^\nIn file included from /usr/include/c++/9/algorithm:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from Main.cc:1:\n/usr/include/c++/9/bits/stl_algo.h:3468:5: note: candidate: \'template<class _Tp, class _Compare> _Tp std::max(std::initializer_list<_Tp>, _Compare)\'\n 3468 |     max(initializer_list<_Tp> __l, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algo.h:3468:5: note:   template argument deduction/substitution failed:\nMain.cc:87:24: note:   mismatched types \'std::initializer_list<_Tp>\' and \'long long int\'\n   87 |     lx[z]=rx[z]=max(w,0);\n      |                        ^\nMain.cc: In function \'void query(long long int, long long int)\':\nMain.cc:95:14: warning: format \'%d\' expects argument of type \'int\', but argument 2 has type \'long long int\' [-Wformat=]\n   95 |     printf(\"%d\\n\",mx[ch[y][0]]);\n      |             ~^    ~~~~~~~~~~~~\n      |              |               |\n      |              int             long long int\n      |             %lld\nMain.cc: In function \'int main()\':\nMain.cc:104:9: warning: suggest parentheses around \'+\' inside \'>>\' [-Wparentheses]\n  104 |     rt=n+3>>1;\n      |        ~^~\n'),(1025,'Main.cc: In function \'void build(long long int, long long int, long long int)\':\nMain.cc:35:15: warning: suggest parentheses around \'+\' inside \'>>\' [-Wparentheses]\n   35 |     int mid=ll+rr>>1;\n      |             ~~^~~\nMain.cc:40:39: error: no matching function for call to \'max(long long int&, int)\'\n   40 |         lx[mid]=rx[mid]=max(val[mid],0);\n      |                                       ^\nIn file included from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from Main.cc:1:\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note: candidate: \'template<class _Tp> const _Tp& std::max(const _Tp&, const _Tp&)\'\n  222 |     max(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template argument deduction/substitution failed:\nMain.cc:40:39: note:   deduced conflicting types for parameter \'const _Tp\' (\'long long int\' and \'int\')\n   40 |         lx[mid]=rx[mid]=max(val[mid],0);\n      |                                       ^\nIn file included from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from Main.cc:1:\n/usr/include/c++/9/bits/stl_algobase.h:268:5: note: candidate: \'template<class _Tp, class _Compare> const _Tp& std::max(const _Tp&, const _Tp&, _Compare)\'\n  268 |     max(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5: note:   template argument deduction/substitution failed:\nMain.cc:40:39: note:   deduced conflicting types for parameter \'const _Tp\' (\'long long int\' and \'int\')\n   40 |         lx[mid]=rx[mid]=max(val[mid],0);\n      |                                       ^\nIn file included from /usr/include/c++/9/algorithm:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from Main.cc:1:\n/usr/include/c++/9/bits/stl_algo.h:3462:5: note: candidate: \'template<class _Tp> _Tp std::max(std::initializer_list<_Tp>)\'\n 3462 |     max(initializer_list<_Tp> __l)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algo.h:3462:5: note:   template argument deduction/substitution failed:\nMain.cc:40:39: note:   mismatched types \'std::initializer_list<_Tp>\' and \'long long int\'\n   40 |         lx[mid]=rx[mid]=max(val[mid],0);\n      |                                       ^\nIn file included from /usr/include/c++/9/algorithm:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from Main.cc:1:\n/usr/include/c++/9/bits/stl_algo.h:3468:5: note: candidate: \'template<class _Tp, class _Compare> _Tp std::max(std::initializer_list<_Tp>, _Compare)\'\n 3468 |     max(initializer_list<_Tp> __l, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algo.h:3468:5: note:   template argument deduction/substitution failed:\nMain.cc:40:39: note:   mismatched types \'std::initializer_list<_Tp>\' and \'long long int\'\n   40 |         lx[mid]=rx[mid]=max(val[mid],0);\n      |                                       ^\nMain.cc: In function \'void query(long long int, long long int)\':\nMain.cc:95:14: warning: format \'%d\' expects argument of type \'int\', but argument 2 has type \'long long int\' [-Wformat=]\n   95 |     printf(\"%d\\n\",mx[ch[y][0]]);\n      |             ~^    ~~~~~~~~~~~~\n      |              |               |\n      |              int             long long int\n      |             %lld\nMain.cc: In function \'int main()\':\nMain.cc:104:9: warning: suggest parentheses around \'+\' inside \'>>\' [-Wparentheses]\n  104 |     rt=n+3>>1;\n      |        ~^~\n'),(1040,''),(1041,'Main.c:1:10: fatal error: bits/stdc++.h: No such file or directory\n    1 | #include <bits/stdc++.h>\n      |          ^~~~~~~~~~~~~~~\ncompilation terminated.\n'),(1066,'Main.cc: In function ‘void bfs(int)’:\nMain.cc:93:20: error: no matching function for call to ‘std::deque<int>::push_back(<brace-enclosed initializer list>)’\n  q.push_back({x, 0});\r\n                    ^\nIn file included from /usr/include/c++/5/deque:64:0,\n                 from /usr/include/x86_64-linux-gnu/c++/5/bits/stdc++.h:67,\n                 from Main.cc:1:\n/usr/include/c++/5/bits/stl_deque.h:1516:7: note: candidate: void std::deque<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = int; _Alloc = std::allocator<int>; std::deque<_Tp, _Alloc>::value_type = int]\n       push_back(const value_type& __x)\n       ^\n/usr/include/c++/5/bits/stl_deque.h:1516:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const int&}’\n/usr/include/c++/5/bits/stl_deque.h:1531:7: note: candidate: void std::deque<_Tp, _Alloc>::push_back(std::deque<_Tp, _Alloc>::value_type&&) [with _Tp = int; _Alloc = std::allocator<int>; std::deque<_Tp, _Alloc>::value_type = int]\n       push_back(value_type&& __x)\n       ^\n/usr/include/c++/5/bits/stl_deque.h:1531:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::deque<int>::value_type&& {aka int&&}’\nMain.cc:94:15: error: ‘size’ was not declared in this scope\n  while (size(q)) {\r\n               ^\nMain.cc:95:18: error: conversion from ‘__gnu_cxx::__alloc_traits<std::allocator<int> >::value_type {aka int}’ to non-scalar type ‘pii {aka std::pair<int, int>}’ requested\n   pii t = q.front(); q.pop_front();\r\n                  ^\nMain.cc:101:48: error: no matching function for call to ‘std::deque<int>::push_front(<brace-enclosed initializer list>)’\n    if (e[i].w == 0) q.push_front({e[i].to, dis});\r\n                                                ^\nIn file included from /usr/include/c++/5/deque:64:0,\n                 from /usr/include/x86_64-linux-gnu/c++/5/bits/stdc++.h:67,\n                 from Main.cc:1:\n/usr/include/c++/5/bits/stl_deque.h:1483:7: note: candidate: void std::deque<_Tp, _Alloc>::push_front(const value_type&) [with _Tp = int; _Alloc = std::allocator<int>; std::deque<_Tp, _Alloc>::value_type = int]\n       push_front(const value_type& __x)\n       ^\n/usr/include/c++/5/bits/stl_deque.h:1483:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const int&}’\n/usr/include/c++/5/bits/stl_deque.h:1498:7: note: candidate: void std::deque<_Tp, _Alloc>::push_front(std::deque<_Tp, _Alloc>::value_type&&) [with _Tp = int; _Alloc = std::allocator<int>; std::deque<_Tp, _Alloc>::value_type = int]\n       push_front(value_type&& __x)\n       ^\n/usr/include/c++/5/bits/stl_deque.h:1498:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::deque<int>::value_type&& {aka int&&}’\nMain.cc:102:39: error: no matching function for call to ‘std::deque<int>::push_back(<brace-enclosed initializer list>)’\n    else q.push_back({e[i].to, dis + 1});\r\n                                       ^\nIn file included from /usr/include/c++/5/deque:64:0,\n                 from /usr/include/x86_64-linux-gnu/c++/5/bits/stdc++.h:67,\n                 from Main.cc:1:\n/usr/include/c++/5/bits/stl_deque.h:1516:7: note: candidate: void std::deque<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = int; _Alloc = std::allocator<int>; std::deque<_Tp, _Alloc>::value_type = int]\n       push_back(const value_type& __x)\n       ^\n/usr/include/c++/5/bits/stl_deque.h:1516:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const int&}’\n/usr/include/c++/5/bits/stl_deque.h:1531:7: note: candidate: void std::deque<_Tp, _Alloc>::push_back(std::deque<_Tp, _Alloc>::value_type&&) [with _Tp = int; _Alloc = std::allocator<int>; std::deque<_Tp, _Alloc>::value_type = int]\n       push_back(value_type&& __x)\n       ^\n/usr/include/c++/5/bits/stl_deque.h:1531:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::deque<int>::value_type&& {aka int&&}’\nMain.cc: In function ‘int main()’:\nMain.cc:108:23: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n  scanf(\"%d%d\", &n, &m);\r\n                       ^\nMain.cc:110:30: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n   scanf(\"%d%d%d\", &u, &v, &w);\r\n                              ^\nMain.cc:116:20: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n  scanf(\"%d\", &qNum);\r\n                    ^\n'),(1067,'Main.cc: In function ‘void bfs(int)’:\nMain.cc:94:15: error: ‘size’ was not declared in this scope\n  while (size(q)) {\r\n               ^\nMain.cc: In function ‘int main()’:\nMain.cc:108:23: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n  scanf(\"%d%d\", &n, &m);\r\n                       ^\nMain.cc:110:30: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n   scanf(\"%d%d%d\", &u, &v, &w);\r\n                              ^\nMain.cc:116:20: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n  scanf(\"%d\", &qNum);\r\n                    ^\n'),(1069,'Main.cc: In function ‘void bfs(int)’:\nMain.cc:94:15: error: ‘size’ was not declared in this scope\n  while (size(q)) {\r\n               ^\nMain.cc: In function ‘int main()’:\nMain.cc:108:23: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n  scanf(\"%d%d\", &n, &m);\r\n                       ^\nMain.cc:110:30: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n   scanf(\"%d%d%d\", &u, &v, &w);\r\n                              ^\nMain.cc:116:20: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n  scanf(\"%d\", &qNum);\r\n                    ^\n'),(1077,'Main.cc: In function ‘int main()’:\nMain.cc:21:13: error: ‘ma’ was not declared in this scope\n    mx = max(ma, f[j]);\r\n             ^\n'),(1088,'Main.cs(4,22): error CS0542: `Main.Main(string[])\': member names cannot be the same as their enclosing type\nMain.cs(3,14): (Location of the symbol related to previous error)\n');
/*!40000 ALTER TABLE `compileinfo` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `contest`
--

DROP TABLE IF EXISTS `contest`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `contest` (
  `contest_id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) DEFAULT NULL,
  `start_time` datetime DEFAULT NULL,
  `end_time` datetime DEFAULT NULL,
  `defunct` char(1) NOT NULL DEFAULT 'N',
  `description` text,
  `private` tinyint(4) NOT NULL DEFAULT '0',
  `langmask` int(11) NOT NULL DEFAULT '0' COMMENT 'bits for LANG to mask',
  `password` char(16) NOT NULL DEFAULT '',
  `user_id` varchar(48) NOT NULL DEFAULT 'admin',
  PRIMARY KEY (`contest_id`)
) ENGINE=MyISAM AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `contest`
--

LOCK TABLES `contest` WRITE;
/*!40000 ALTER TABLE `contest` DISABLE KEYS */;
/*!40000 ALTER TABLE `contest` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `contest_problem`
--

DROP TABLE IF EXISTS `contest_problem`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `contest_problem` (
  `problem_id` int(11) NOT NULL DEFAULT '0',
  `contest_id` int(11) DEFAULT NULL,
  `title` char(200) NOT NULL DEFAULT '',
  `num` int(11) NOT NULL DEFAULT '0',
  `c_accepted` int(11) NOT NULL DEFAULT '0',
  `c_submit` int(11) NOT NULL DEFAULT '0',
  KEY `Index_contest_id` (`contest_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `contest_problem`
--

LOCK TABLES `contest_problem` WRITE;
/*!40000 ALTER TABLE `contest_problem` DISABLE KEYS */;
/*!40000 ALTER TABLE `contest_problem` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `custominput`
--

DROP TABLE IF EXISTS `custominput`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `custominput` (
  `solution_id` int(11) NOT NULL DEFAULT '0',
  `input_text` text,
  PRIMARY KEY (`solution_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `custominput`
--

LOCK TABLES `custominput` WRITE;
/*!40000 ALTER TABLE `custominput` DISABLE KEYS */;
/*!40000 ALTER TABLE `custominput` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `loginlog`
--

DROP TABLE IF EXISTS `loginlog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `loginlog` (
  `user_id` varchar(48) NOT NULL DEFAULT '',
  `password` varchar(40) DEFAULT NULL,
  `ip` varchar(46) DEFAULT NULL,
  `time` datetime DEFAULT NULL,
  KEY `user_log_index` (`user_id`,`time`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `loginlog`
--

LOCK TABLES `loginlog` WRITE;
/*!40000 ALTER TABLE `loginlog` DISABLE KEYS */;
INSERT INTO `loginlog` VALUES ('admin','no save','49.77.72.76','2022-05-05 08:46:42'),('admin','login ok','49.77.72.76','2022-05-05 08:56:59'),('admin','login ok','58.213.105.62','2022-05-05 23:31:17'),('admin','login ok','49.77.72.76','2022-05-06 04:55:54'),('2023_YZB','no save','180.111.215.58','2022-05-06 08:22:00'),('2023_YZB','no save','180.111.215.58','2022-05-06 08:23:48'),('yangzhibo123','user added','49.77.72.76','2022-05-06 08:25:17'),('yangzhibo123','login ok','180.111.215.58','2022-05-06 08:26:36'),('yangzhibo123','login ok','180.111.215.58','2022-05-06 08:27:45'),('admin','login ok','49.77.72.76','2022-05-06 08:29:43'),('DerekXu','no save','180.111.51.240','2022-05-06 08:33:21'),('DerekXu','login ok','180.111.51.240','2022-05-06 08:35:41'),('qianruiyi','no save','183.209.50.194','2022-05-06 08:56:46'),('admin','login ok','49.93.4.132','2022-05-07 07:31:57'),('admin','login ok','49.77.72.76','2022-05-10 05:21:12'),('admin','login ok','49.77.72.76','2022-05-10 05:39:54'),('admin','login ok','49.77.72.76','2022-05-10 08:04:06'),('admin','login ok','49.77.72.76','2022-05-11 05:49:58'),('admin','login ok','49.77.72.76','2022-05-11 07:07:38'),('mhb2010','no save','180.110.197.159','2022-05-11 07:27:25'),('mhb2010','login ok','180.110.197.159','2022-05-11 07:27:47'),('yangzhibo123','login ok','49.77.72.76','2022-05-11 07:30:52'),('admin','login ok','49.77.72.76','2022-05-11 07:31:42'),('yangzhibo123','login ok','49.77.72.76','2022-05-11 07:34:44'),('admin','login ok','49.77.72.76','2022-05-11 07:35:20'),('yangzhibo123','login ok','180.111.215.58','2022-05-11 07:42:18'),('qianruiyi','login ok','183.209.50.194','2022-05-11 07:58:00'),('DerekXu','login ok','180.109.235.179','2022-05-11 08:01:08'),('lihaoze','no save','112.20.78.176','2022-05-11 08:03:26'),('adminxcx','no save','49.77.72.76','2022-05-11 08:14:23'),('admin','login ok','49.77.72.76','2022-05-11 08:14:34'),('admin','login ok','49.77.72.76','2022-05-11 08:14:58'),('adminxcx','login ok','49.77.72.76','2022-05-11 08:15:53'),('lihaoze','login ok','112.20.78.176','2022-05-11 08:20:48'),('admin','login ok','49.77.72.76','2022-05-11 08:23:04'),('adminxcx','login ok','49.77.72.76','2022-05-11 08:25:10'),('admin','login ok','49.77.72.76','2022-05-11 08:35:05'),('DerekXu','login ok','180.109.90.155','2022-05-13 20:00:43'),('DerekXu','login ok','180.109.90.155','2022-05-13 20:02:23'),('qianruiyi','login ok','180.109.90.155','2022-05-13 20:02:47'),('admin','login ok','180.109.90.155','2022-05-13 20:03:52'),('qianruiyi','login ok','180.109.90.155','2022-05-13 20:15:29'),('admin','login ok','180.109.90.155','2022-05-13 20:26:04'),('admin','login ok','180.109.204.243','2022-05-14 18:51:02'),('admin','login ok','180.109.204.243','2022-05-15 21:11:26'),('admin','login ok','180.109.204.243','2022-05-16 18:39:14'),('admin','login ok','180.109.204.243','2022-05-16 18:41:45'),('admin','login ok','180.109.204.243','2022-05-18 17:54:28'),('admin','login ok','180.101.233.174','2022-05-20 11:36:08'),('lihaoze','login ok','117.62.165.126','2022-05-20 17:38:01'),('admin','login ok','117.62.165.126','2022-05-20 17:46:47'),('mhb2010','login ok','117.62.165.126','2022-05-20 17:54:55'),('admin','login ok','117.62.165.126','2022-05-20 17:55:07'),('DerekXu','login ok','117.62.165.126','2022-05-20 20:23:01'),('qianruiyi','login ok','117.62.165.126','2022-05-22 09:02:31'),('wangzining','no save','117.62.165.126','2022-05-22 09:19:30'),('WZN','no save','117.62.165.126','2022-05-22 09:21:44'),('admin','login ok','180.109.204.243','2022-05-23 21:13:09'),('admin','login ok','180.109.204.243','2022-05-24 20:29:31'),('admin','login ok','180.109.29.36','2022-08-16 21:03:21'),('yangzhibo123','login ok','180.109.29.36','2022-08-16 21:18:46'),('admin','login ok','180.109.29.36','2022-08-16 21:20:48'),('admin','login ok','121.237.136.18','2022-08-17 09:55:33'),('xcx0902','no save','180.109.29.36','2022-08-17 21:02:10'),('admin','login ok','180.109.29.36','2022-08-17 21:02:27'),('adminxcx','login ok','180.109.29.36','2022-08-17 21:03:29'),('admin','login ok','180.109.29.36','2022-08-17 21:04:33'),('admin','login ok','180.109.29.36','2022-08-17 21:07:59'),('admin','login ok','121.237.136.18','2022-08-18 11:44:34'),('admin','login ok','222.190.121.121','2022-08-18 13:48:05'),('admin','login ok','222.190.121.121','2022-08-18 16:48:10'),('admin','login ok','222.190.121.121','2022-08-18 17:36:09'),('admin','login ok','180.109.29.36','2022-08-18 19:49:09'),('admin','login ok','222.190.121.121','2022-08-19 17:23:23'),('admin','login ok','180.109.29.36','2022-08-19 19:50:13'),('admin','login ok','180.98.3.124','2022-08-20 12:17:54'),('admin','login ok','180.109.29.36','2022-08-20 14:02:52'),('xcx0902','login ok','180.109.29.36','2022-08-20 19:52:03'),('admin','login ok','180.109.29.36','2022-08-20 20:17:08'),('xcx0902','login ok','180.109.29.36','2022-08-21 18:16:07'),('admin','login ok','180.109.29.36','2022-08-21 18:19:58'),('admin','login ok','180.109.29.36','2022-08-21 18:26:08'),('xcx0902','login ok','180.109.29.36','2022-08-21 18:26:12'),('admin','login ok','180.109.29.36','2022-08-21 18:28:02'),('admin','login ok','180.109.29.36','2022-08-21 18:30:27'),('admin','login ok','180.109.29.36','2022-08-21 19:19:33'),('admin','login ok','180.109.29.36','2022-08-21 20:42:42'),('admin','login ok','180.109.29.36','2022-08-21 20:46:34'),('test_smtp','no save','180.109.29.36','2022-08-21 21:20:20'),('admin','login ok','180.109.29.36','2022-08-21 21:22:13'),('admin','login ok','180.109.29.36','2022-08-21 21:40:13'),('admin','login ok','180.109.29.36','2022-08-22 12:07:03'),('admin','login ok','180.109.29.36','2022-08-22 13:57:18'),('xcx0902','login ok','180.109.29.36','2022-08-22 16:12:17'),('admin','login ok','180.109.29.36','2022-08-22 16:23:46'),('admin','login ok','180.109.29.36','2022-08-22 16:39:11'),('xcx0902','login ok','180.109.29.36','2022-08-22 17:19:42'),('admin','login ok','180.109.29.36','2022-08-22 17:21:45'),('admin','login ok','180.109.29.36','2022-08-22 18:33:34'),('admin','login ok','180.109.29.36','2022-08-22 18:34:05'),('admin','login ok','180.109.29.36','2022-08-23 11:18:11'),('Lyrically','no save','112.2.78.103','2022-08-23 21:11:52'),('admin','login ok','180.109.29.36','2022-08-24 16:48:04'),('admin','login ok','180.109.29.36','2022-08-24 18:10:36'),('xcx0902','login ok','180.109.29.36','2022-08-25 20:13:55'),('admin','login ok','180.109.29.36','2022-08-25 20:14:05'),('xcx0902','login ok','180.109.29.36','2022-08-25 21:02:26'),('admin','login ok','180.109.29.36','2022-08-25 21:03:05'),('FReQuenter','no save','49.77.60.242','2022-08-26 11:02:25'),('tommychen','no save','112.23.190.51','2022-08-26 21:03:36'),('oimaster','no save','121.237.136.18','2022-08-27 08:54:47'),('admin','login ok','49.77.74.68','2022-08-27 11:41:21'),('admin','login ok','49.77.74.68','2022-08-27 13:16:45'),('adminxcx','login ok','49.77.74.68','2022-08-27 14:47:26'),('admin','login ok','49.77.74.68','2022-08-27 14:58:16'),('xcx0902','login ok','49.77.74.68','2022-08-27 15:21:39'),('admin','login ok','49.77.74.68','2022-08-27 15:21:53'),('adminxcx','login ok','49.77.74.68','2022-08-27 19:48:13'),('admin','login ok','49.77.74.68','2022-08-27 19:50:34'),('yangzd','no save','114.222.131.88','2022-08-28 00:16:01'),('admin','login ok','49.77.74.68','2022-08-28 10:37:17'),('yangzd','login ok','114.222.131.88','2022-08-28 15:24:05'),('yangzd','login ok','114.222.131.88','2022-08-28 15:24:33'),('yangzd','login ok','114.222.131.88','2022-08-28 15:24:57'),('admin','login ok','49.77.74.68','2022-08-28 16:57:56'),('admin','login ok','49.77.74.68','2022-08-28 17:01:13'),('xcx0902','login ok','49.77.74.68','2022-08-28 17:05:15'),('admin','login ok','49.77.74.68','2022-08-28 21:05:46'),('admin','login ok','49.77.74.68','2022-08-29 14:18:51'),('admin','login ok','49.77.74.68','2022-08-30 10:42:37'),('admin','login ok','49.77.74.68','2022-08-30 15:49:45'),('admin','login ok','49.77.74.68','2022-08-30 16:05:34'),('admin','login ok','49.77.74.68','2022-08-30 16:17:12'),('admin','login ok','49.77.74.68','2022-08-30 16:17:16'),('admin','login ok','49.77.74.68','2022-08-30 16:17:35'),('admin','login ok','49.77.74.68','2022-08-30 16:57:33'),('admin','login ok','49.77.74.68','2022-08-30 16:57:47'),('xcx0902','login ok','49.77.74.68','2022-08-31 15:40:56'),('admin','login ok','49.77.74.68','2022-08-31 15:41:18'),('admin','login ok','192.168.1.100','2022-08-31 17:56:51'),('admin','login ok','49.77.74.68','2022-08-31 18:57:47'),('admin','login ok','49.77.74.68','2022-09-01 07:02:38'),('admin','login ok','121.237.136.18','2022-09-02 17:53:20'),('oimaster','login ok','112.2.78.161','2022-09-04 13:47:13'),('LCN','no save','117.60.76.238','2022-09-04 14:15:59'),('admin','login ok','49.77.74.68','2022-09-04 15:42:58'),('GX_halxf08','no save','114.106.123.142','2022-09-04 18:21:36'),('admin','login ok','49.77.74.68','2022-09-05 19:24:42'),('admin','login ok','180.109.90.20','2022-09-09 19:48:46'),('admin','login ok','180.109.90.20','2022-09-09 19:49:06'),('yangzd','login ok','180.109.90.20','2022-09-09 19:50:24'),('xcx0902','login ok','180.109.90.20','2022-09-09 21:20:28'),('admin','login ok','180.109.90.20','2022-09-09 21:20:45'),('yhq123','no save','180.109.90.20','2022-09-10 09:38:46'),('sszcdjr','no save','49.74.95.30','2022-09-11 21:55:37'),('sszcdjr','login ok','49.74.95.30','2022-09-13 21:27:48'),('yhq123','login ok','58.213.232.97','2022-09-15 10:35:24'),('test_reg_remind','no save','49.77.9.214','2022-09-19 18:21:55'),('admin','login ok','49.77.9.214','2022-09-19 18:22:40'),('JerryCKB','no save','101.224.100.228','2022-09-28 21:03:57'),('qianruiyi','login ok','183.209.50.120','2022-10-01 10:15:56'),('GX_halxf08','login ok','36.63.186.110','2022-10-02 21:39:22'),('adminxcx','login ok','180.109.31.107','2022-10-12 21:23:17'),('admin','login ok','180.109.31.107','2022-10-16 17:42:39'),('admin','login ok','114.221.224.67','2022-10-20 17:03:12'),('qianruiyi','login ok','183.209.48.217','2022-10-24 21:50:27'),('Derek0919','no save','180.111.27.242','2022-11-04 19:59:31'),('DerekXu','login ok','180.111.27.242','2022-11-04 20:03:13'),('Derek0919','login ok','180.111.27.242','2022-11-04 20:05:31'),('GX_halxf08','login ok','36.63.223.211','2022-11-11 21:06:45'),('admin','login ok','114.221.224.67','2022-11-17 19:00:27'),('admin','login ok','185.187.239.152','2022-11-18 19:26:51'),('admin','login ok','180.109.88.233','2022-11-18 19:28:14'),('yhq123','login ok','49.65.161.136','2022-11-26 09:02:07'),('admin','login ok','121.225.244.35','2022-12-04 17:05:04'),('admin','login ok','121.225.244.35','2022-12-04 17:37:05'),('admin','login ok','49.77.11.164','2022-12-20 17:18:42');
/*!40000 ALTER TABLE `loginlog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mail`
--

DROP TABLE IF EXISTS `mail`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mail` (
  `mail_id` int(11) NOT NULL AUTO_INCREMENT,
  `to_user` varchar(48) NOT NULL DEFAULT '',
  `from_user` varchar(48) NOT NULL DEFAULT '',
  `title` varchar(200) NOT NULL DEFAULT '',
  `content` text,
  `new_mail` tinyint(1) NOT NULL DEFAULT '1',
  `reply` tinyint(4) DEFAULT '0',
  `in_date` datetime DEFAULT NULL,
  `defunct` char(1) NOT NULL DEFAULT 'N',
  PRIMARY KEY (`mail_id`),
  KEY `uid` (`to_user`)
) ENGINE=MyISAM AUTO_INCREMENT=1017 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mail`
--

LOCK TABLES `mail` WRITE;
/*!40000 ALTER TABLE `mail` DISABLE KEYS */;
INSERT INTO `mail` VALUES (1013,'mhb2010','admin','fuck you','',0,0,'2022-09-02 18:05:54','N'),(1014,'admin','user_reg','Registration Confirm Reminding','test_reg_remind registered an account on GXOJ, please confirm it ASAP.',0,0,'2022-09-19 18:21:55','N'),(1015,'admin','user_reg','Registration Confirm Reminding','JerryCKB registered an account on GXOJ, please confirm it ASAP.',0,0,'2022-09-28 21:03:57','N'),(1016,'admin','user_reg','Registration Confirm Reminding','Derek0919 registered an account on GXOJ, please confirm it ASAP.',0,0,'2022-11-04 19:59:31','N');
/*!40000 ALTER TABLE `mail` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `news`
--

DROP TABLE IF EXISTS `news`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `news` (
  `news_id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` varchar(48) NOT NULL DEFAULT '',
  `title` varchar(200) NOT NULL DEFAULT '',
  `content` text NOT NULL,
  `time` datetime NOT NULL DEFAULT '2016-05-13 19:24:00',
  `importance` tinyint(4) NOT NULL DEFAULT '0',
  `menu` int(11) NOT NULL DEFAULT '0',
  `defunct` char(1) NOT NULL DEFAULT 'N',
  PRIMARY KEY (`news_id`)
) ENGINE=MyISAM AUTO_INCREMENT=1007 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `news`
--

LOCK TABLES `news` WRITE;
/*!40000 ALTER TABLE `news` DISABLE KEYS */;
INSERT INTO `news` VALUES (1005,'admin','欢迎','\r\n	Welcome to GXOJ!\r\n<br />\r\n\r\n	Hope for your idea to improve this OJ!\r\n<br />','2022-08-19 20:30:10',0,0,'N'),(1006,'admin','XCX Round #1 题解','        题目：<br />\r\n[plist=1007&#44;1008&#44;1009&#44;1010&#44;1011&#44;1012]XCX Round #1 题单[/plist]\r\n题解链接：<a href=\"/file/solution/xcxround1/editorial.html\">Editorial li<x>nk</a> <br />      ','2022-08-27 11:46:34',0,0,'N');
/*!40000 ALTER TABLE `news` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `online`
--

DROP TABLE IF EXISTS `online`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `online` (
  `hash` varchar(32) COLLATE utf8mb4_unicode_ci NOT NULL,
  `ip` varchar(46) CHARACTER SET utf8mb4 NOT NULL DEFAULT '',
  `ua` varchar(255) CHARACTER SET utf8mb4 NOT NULL DEFAULT '',
  `refer` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `lastmove` int(11) NOT NULL,
  `firsttime` int(11) DEFAULT NULL,
  `uri` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`hash`),
  UNIQUE KEY `hash` (`hash`)
) ENGINE=MEMORY DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `online`
--

LOCK TABLES `online` WRITE;
/*!40000 ALTER TABLE `online` DISABLE KEYS */;
INSERT INTO `online` VALUES ('4d29ecc8be9da76e8a23858c67dd4bc1','23.251.102.74','guest@Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36','http://111.67.199.74/',1671626131,1671626131,'/loginpage.php');
/*!40000 ALTER TABLE `online` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `printer`
--

DROP TABLE IF EXISTS `printer`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `printer` (
  `printer_id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` char(48) NOT NULL,
  `in_date` datetime NOT NULL DEFAULT '2018-03-13 19:38:00',
  `status` smallint(6) NOT NULL DEFAULT '0',
  `worktime` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `printer` char(16) NOT NULL DEFAULT 'LOCAL',
  `content` text NOT NULL,
  PRIMARY KEY (`printer_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `printer`
--

LOCK TABLES `printer` WRITE;
/*!40000 ALTER TABLE `printer` DISABLE KEYS */;
/*!40000 ALTER TABLE `printer` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `privilege`
--

DROP TABLE IF EXISTS `privilege`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `privilege` (
  `user_id` char(48) NOT NULL DEFAULT '',
  `rightstr` char(30) NOT NULL DEFAULT '',
  `valuestr` char(11) NOT NULL DEFAULT 'true',
  `defunct` char(1) NOT NULL DEFAULT 'N',
  KEY `user_id_index` (`user_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `privilege`
--

LOCK TABLES `privilege` WRITE;
/*!40000 ALTER TABLE `privilege` DISABLE KEYS */;
INSERT INTO `privilege` VALUES ('admin','administrator','true','N'),('admin','http_judge','true','N'),('admin','p1000','true','N'),('admin','source_browser','true','N'),('admin','p1003','true','N'),('adminxcx','administrator','true','N'),('adminxcx','source_browser','true','N'),('admin','p1004','true','N'),('admin','p1005','true','N'),('admin','p1006','true','N'),('admin','p1007','true','N'),('admin','p1008','true','N'),('admin','p1009','true','N'),('admin','p1010','true','N'),('admin','p1011','true','N'),('admin','p1012','true','N'),('admin','p1013','true','N'),('admin','p1014','true','N'),('admin','p1015','true','N'),('admin','p1016','true','N');
/*!40000 ALTER TABLE `privilege` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `problem`
--

DROP TABLE IF EXISTS `problem`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `problem` (
  `problem_id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(200) NOT NULL DEFAULT '',
  `description` text,
  `input` text,
  `output` text,
  `sample_input` text,
  `sample_output` text,
  `spj` char(1) NOT NULL DEFAULT '0',
  `hint` text,
  `source` varchar(100) DEFAULT NULL,
  `in_date` datetime DEFAULT NULL,
  `time_limit` decimal(10,3) NOT NULL DEFAULT '0.000',
  `memory_limit` int(11) NOT NULL DEFAULT '0',
  `defunct` char(1) NOT NULL DEFAULT 'N',
  `accepted` int(11) DEFAULT '0',
  `submit` int(11) DEFAULT '0',
  `solved` int(11) DEFAULT '0',
  PRIMARY KEY (`problem_id`)
) ENGINE=MyISAM AUTO_INCREMENT=1017 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `problem`
--

LOCK TABLES `problem` WRITE;
/*!40000 ALTER TABLE `problem` DISABLE KEYS */;
INSERT INTO `problem` VALUES (1000,'Hello World!','\r\n	Print <span style=\"font-family:Courier New;\">Hello World!</span>.\r\n<br />\r\n\r\n	<img src=\"/upload/gxoj.ddwoo.top/20220824/20220824170747_87002.ico\" alt=\"\" />\r\n<br />','No Input.','<span style=\"font-family:Courier New;\">Hello World!</span>','\n','Hello World!','0','','入门','2022-08-24 17:08:21',1.000,128,'N',13,14,0),(1001,'A + B Problem','求两个整数的和。','两个整数 $a&#44; b$。','$a + b$','1 2','3','0','',' 入门','2022-05-06 08:51:54',1.000,128,'N',4,5,0),(1002,'火车售票系统','<div style=\"background-color:#FFFFFE;font-family:Consolas&#44;font-size:14px;\">\n	某次列车途经 $C$ 个城市，城市编号依次为 $1$ 到 $C$，列车上共有 $S$ 个座位，铁路局规定售出的车票只能是坐票，即车上所有的旅客都有座，售票系统是由计算机执行的，每一个售票申请包含三个参数，分别用 $O$、$D$、$N$ 表示，$O$ 为起始站，$D$ 为目的地站，$N$ 为车票张数，售票系统对该售票申请作出受理或不受理的决定，只有在从 $O$ 到 $D$ 的区段内列车上都有 $N$ 个或 $N$ 个以上的空座位时该售票申请才被受理，请你写一个程序，实现这个自动售票系统。\n</div>','<div style=\"background-color:#FFFFFE;font-family:Consolas&#44;font-size:14px;\">\n	输入文件第一行包含三个用空格隔开的整数 $C$、$S$ 和 $R$，其中 $1 \\le C \\le 60000$，$1 \\le S \\le 60000$，$1 \\le R \\le 60000$，$C$ 为城市个数，$S$ 为列车上的座位数，$R$ 为所有售票申请总数。接下来的 $R$ 行每行为一个售票申请，用三个由空格隔开的整数 $O&#44; D$ 和 $N$ 表示，$O$ 为起始站，$D$ 为目的地站，$N$ 为车票站数，其中 $1 \\le D \\le C$，$1 \\le N \\le C$，所有的售票申请按申请的时间从早到晚给出。\n</div>','<div style=\"background-color:#FFFFFE;font-family:Consolas&#44;font-size:14px;\">\n	输出文件共有 $R$ 行，每行输出一个 <span>$\\text{YES}$</span>&nbsp;或 <span>$\\text{NO}$</span>，表示当前的售票申请被受理或不被受理。\n</div>','4 6 4\n1 4 2\n1 3 2\n2 4 3\n1 2 3','YES\nYES\nNO\nNO','0','','普及+/提高 线段树','2022-05-06 08:51:54',5.000,256,'N',2,2,0),(1003,'GSS3 - Can you answer these queries III','\r\n	1查询，2修改<br />\r\nPS: $n \\le 500000$\r\n<br />\r\n<span style=\"color:rgba(0&#44;font-family:-apple-system&#44;font-size:16px;background-color:#FFFFFF;\">You are given a sequence A of N (N &lt;= 50000) integers between -10000 and 10000. On this sequence you have to apply M (M &lt;= 50000) operations:</span><br />\r\n<span style=\"color:rgba(0&#44;font-family:-apple-system&#44;font-size:16px;background-color:#FFFFFF;\">modify the i-th element in the sequence or for given x y print max{Ai + Ai+1 + .. + Aj | x&lt;=i&lt;=j&lt;=y }.</span> <br />\r\n<img src=\"data:image/png;base64&#44;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<x>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\" alt=\"\" /> <br />','<img src=\"data:image/png;base64&#44;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<x>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<x>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\" alt=\"\" /><span style=\"color:rgba(0&#44;font-family:-apple-system&#44;font-size:16px;background-color:#FFFFFF;\">The first line of input contains an integer N. The following line contains N integers&#44; representing the sequence A1..AN.</span><br />\r\n<span style=\"color:rgba(0&#44;font-family:-apple-system&#44;font-size:16px;background-color:#FFFFFF;\">The third line contains an integer M. The next M lines contain the operations in following form:</span><br />\r\n<span style=\"color:rgba(0&#44;font-family:-apple-system&#44;font-size:16px;background-color:#FFFFFF;\">0 x y: modify Ax into y (|y|&lt;=10000).</span><br />\r\n<span style=\"color:rgba(0&#44;font-family:-apple-system&#44;font-size:16px;background-color:#FFFFFF;\">1 x y: print max{Ai + Ai+1 + .. + Aj | x&lt;=i&lt;=j&lt;=y }.</span>','<span style=\"color:rgba(0&#44;font-family:-apple-system&#44;font-size:16px;background-color:#FFFFFF;\">For each query&#44; print an integer as the problem required.</span>','4\r\n1 2 3 4\r\n4\r\n1 1 3\r\n2 3 -3\r\n1 2 4\r\n1 3 3','6\r\n4\r\n-3','0','$n \\le 500000$<br />\r\n翻译 <br />\r\n<img src=\"data:image/png;base64&#44;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\" alt=\"\" /> <br />','提高+/省选- 线段树','2022-08-21 21:46:59',2.000,128,'N',3,20,0),(1013,'(XCX Round #2 A) 小 X 的计算器','小 X 要计算 $\\sqrt{x}$，可是他的计算器上 $\\sqrt{}$ 键坏了，于是他只好向你求助。','第一行一个整数 $t$，表示测试数据组数。 <br />\r\n接下来 $t$ 行，每一行一个 $x$，表示要开方的数。 <br />','输出共 $t$ 行，每一行为 $\\sqrt{x}$（保留 $120$ 位小数，若答案为整数则直接输出，参见样例）。','5\r\n0\r\n1\r\n2\r\n3\r\n4','0\r\n1\r\n1.414213562373095048801688724209698078569671875376948073176679737990732478462107038850387534327641572735013846230912297024\r\n1.732050807568877293527446341505872366942805253810380628055806979451933016908800037081146186757248575675626141415406703029\r\n2','0','对于 $100\\%$ 的数据，$t=100&#44; 0 \\le x \\le 10^9$。','普及+/提高 XCXRound#2 高精度 二分','2022-08-29 18:26:44',1.000,128,'Y',1,1,0),(1014,'(XCX Round #2 B) 小 X 的图','小 X 有一个边权为 $0$ 或 $1$ 的无向图。他想知道图中两点之间的最短路，可是图太大了，他看地眼花缭乱，所以这个任务就交给了你。 <br />','第一行，$n&#44; m$，表示图的点数和边数。 <br />\r\n接下来 $m$ 行，每行三个数 $u&#44; v&#44; w$，表示每一条边的起点、终点、权值。 <br />\r\n接下来一行，一个整数 $q$，表示询问数量。 <br />\r\n接下来 $q$ 行，每行两个数 $u&#44; v$，表示询问的起点、终点（若起点和终点相同则答案为 $0$）。 <br />','输出共 $q$ 行，表示每一个询问的答案（若两点无法到达请输出 <span style=\"font-family:Courier New;\">INF<span style=\"font-family:Courier New;\">）</span></span>。','3 3\r\n1 2 0\r\n1 3 1\r\n2 3 1\r\n5\r\n1 2\r\n1 3\r\n2 3\r\n3 2\r\n1 1','0\r\n1\r\n1\r\n1\r\n0','0','本题使用 Python 数据生成器生成，代码如下： <br />\r\n<img src=\"/upload/gxoj.ddwoo.top/20220827/20220827142211_14373.png\" alt=\"\" /><br />','普及/提高- XCXRound#2 搜索 01BFS','2022-08-29 15:27:21',2.000,128,'Y',3,3,0),(1015,'(XCX Round #2 C) 小 X 的树','小 X 有一棵树，这棵树有 $n$ 个节点，并且每一个节点都有一个权值 $w_i$。现在，小 X 想计算这个问题：<br />\r\n令 $f(u&#44;v)$ 表示 $u$ 到 $v$ 的最短路径上的所有权值的异或。求 $\\max_{i=1}^{n}\\max_{j=i+1}^{n}f(i&#44;j)$。<br />\r\n可是树太大了，小 X 算不过来了，于是他向你求助。<br />','第一行，一个整数 $n$。<br />\r\n第二行，$n$ 个整数，表示每个节点的权值 $w_i$。<br />\r\n第三至 $n+1$ 行，每行两个整数 $u&#44; v$，表示 $u$ 和 $v$ 连边。<br />','一行，表示答案。','5\r\n1 2 3 4 5\r\n1 2\r\n1 3\r\n2 4\r\n2 5','7','0','对于 $20\\%$ 的数据，$1 \\le n \\le 100$。<br />\r\n对于 $40\\%$ 的数据，$1 \\le n \\le 1000$。<br />\r\n对于 $100\\%$ 的数据，$1 \\le n \\le 100000&#44; 0 \\le w_i &lt; 2^{32}$。<br />',' 普及+/提高 XCXRound#2 Trie 01Trie','2022-08-29 15:27:32',1.000,512,'Y',1,2,0),(1016,'(XCX Round #2 D) 小 X 的 Linux','小 X 想练习基本的 Linux 操作方式，但是他手头没有一个现成的 Linux 系统，于是他就让你帮他做一个简易版的 Linux 用来练习。 <br />\r\n要求：简易版 Linux 要提供以下几个功能： <br />\r\n<li>\r\n	mkdir\r\n</li>\r\n<li>\r\n	ls\r\n</li>\r\n<li>\r\n	cd\r\n</li>\r\n<li>\r\n	rm\r\n</li>\r\n<li>\r\n	touch\r\n</li>\r\n<li>\r\n	pwd\r\n</li>\r\n关于以上命令的用法，参见样例。 <br />\r\n\r\n	<strong>暂无测试数据。</strong>\r\n<br />\r\n\r\n	<strong>本题数据为手造。</strong>\r\n<br />','第一行一个整数 $n$，表示命令条数。 <br />\r\n后面 $n$ 行，代表每个命令。 <br />','参见样例。','24\r\nmkdir /home\r\nls\r\ncd home\r\npwd\r\ntouch file\r\nls\r\nmkdir /home\r\nmkdir /root/c++\r\ncd ..\r\npwd\r\ncd /root\r\nls\r\ncd c++\r\npwd\r\ncd ../..\r\nls\r\nrm /root\r\nls\r\ncd root\r\ncd home\r\nrm file\r\nrm file2\r\nls\r\ncd ..\r\n','ok\r\nhome\r\nok\r\n/home/\r\nok\r\n*file\r\nerr\r\nok\r\nok\r\n/\r\nok\r\nc++\r\nok\r\n/root/c++/\r\nok\r\nhome root\r\nok\r\nhome\r\nerr\r\nok\r\nok\r\nerr\r\nEMPTY\r\nok','0','','提高+/省选- XCXRound#2 树 模拟','2022-10-16 18:05:49',1.000,128,'Y',1,2,0),(1004,'魔法阵','六十年一次的魔法战争就要开始了，大魔法师准备从附近的魔法场中汲取魔法能量。<br />\r\n大魔法师有 $m$ 个魔法物品，编号分别为 $1&#44;2&#44;\\ldots&#44;m$。每个物品具有一个魔法值，我们用 $X_i$ 表示编号为 $i$ 的物品的魔法值。每个魔法值 $X_i$ 是不超过 $n$ 的正整数，可能有多个物品的魔法值相同。<br />\r\n大魔法师认为，当且仅当四个编号为 $a&#44;b&#44;c&#44;d$ 的魔法物品满足 $X_a&lt;X_b&lt;X_c&lt;X_d&#44;X_b-X_a=2(X_d-X_c)$，并且 $X_b-X_a&lt;(X_c-X_b)$ 时，这四个魔法物品形成了一个魔法阵，他称这四个魔法物品分别为这个魔法阵的 $A$ 物品，$B$ 物品，$C$ 物品，$D$ 物品。<br />\r\n现在，大魔法师想要知道，对于每个魔法物品，作为某个魔法阵的 $A$ 物品出现的次数，作为 $B$ 物品的次数，作为 $C$ 物品的次数，和作为 $D$ 物品的次数。<br />','第一行包含两个空格隔开的正整数 $n&#44;m$。<br />\r\n接下来 $m$ 行，每行一个正整数，第 $i+1$ 行的正整数表示 $X_i$，即编号为 $i$ 的物品的魔法值。<br />\r\n保证 $1 \\le n \\le 15000&#44;1 \\le m \\le 40000&#44;1 \\le Xi \\le n$。每个 $X_i$ 是分别在合法范围内等概率随机生成的。<br />','共 $m$ 行，每行 $4$ 个整数。第 $i$ 行的 $4$ 个整数依次表示编号为 $i$ 的物品作 为 $A&#44;B&#44;C&#44;D$ 物品分别出现的次数。<br />\r\n保证标准输出中的每个数都不会超过 $10^9$。每行相邻的两个数之间用恰好一个空格隔开。<br />','30 8\r\n1\r\n24\r\n7\r\n28\r\n5\r\n29\r\n26\r\n24','4 0 0 0\r\n0 0 1 0\r\n0 2 0 0\r\n0 0 1 1\r\n1 3 0 0\r\n0 0 0 2\r\n0 0 2 2\r\n0 0 1 0','0','<h1>\r\n	样例 1 说明\r\n</h1>\r\n共有 $5$ 个魔法阵，分别为：<br />\r\n物品 $1&#44;3&#44;7&#44;6$，其魔法值分别为 $1&#44;7&#44;26&#44;29$；<br />\r\n物品 $1&#44;5&#44;2&#44;7$，其魔法值分别为 $1&#44;5&#44;24&#44;26$；<br />\r\n物品 $1&#44;5&#44;7&#44;4$，其魔法值分别为 $1&#44;5&#44;26&#44;28$；<br />\r\n物品 $1&#44;5&#44;8&#44;7$，其魔法值分别为 $1&#44;5&#44;24&#44;26$；<br />\r\n物品 $5&#44;3&#44;4&#44;6$，其魔法值分别为 $5&#44;7&#44;28&#44;29$。<br />\r\n以物品 $5$ 为例，它作为 $A$ 物品出现了 $1$ 次，作为 $B$ 物品出现了 $3$ 次，没有作为 $C$ 物品或者 $D$ 物品出现，所以这一行输出的四个数依次为 $1&#44;3&#44;0&#44;0$。<br />\r\n此外，如果我们将输出看作一个 $m$ 行 4 列的矩阵，那么每一列上的 $m$ 个数之和都应等于魔法阵的总数。所以，如果你的输出不满足这个性质，那么这个输出一定不正确。你可以通过这个性质在一定程度上检查你的输出的正确性。<br />\r\n<h1>\r\n	数据范围与提示\r\n</h1>\r\n编号<span> </span>n<span> </span>m<br />\r\n1<span> </span>=10<span> </span>=12<br />\r\n2<span> </span>=15<span> </span>=18<br />\r\n3<span> </span>=20<span> </span>=25<br />\r\n4<span> </span>=30<span> </span>=35<br />\r\n5<span> </span>=40<span> </span>=50<br />\r\n6<span> </span>=50<span> </span>=70<br />\r\n7<span> </span>=65<span> </span>=100<br />\r\n8<span> </span>=80<span> </span>=125<br />\r\n9<span> </span>=100<span> </span>=150<br />\r\n10<span> </span>=125<span> </span>=200<br />\r\n11<span> </span>=150<span> </span>=250<br />\r\n12<span> </span>=200<span> </span>=350<br />\r\n13<span> </span>=250<span> </span>=500<br />\r\n14<span> </span>=350<span> </span>=700<br />\r\n15<span> </span>=500<span> </span>=1000<br />\r\n16<span> </span>=700<span> </span>=2000<br />\r\n17<span> </span>=1000<span> </span>=5000<br />\r\n18<span> </span>=2000<span> </span>=10000<br />\r\n19<span> </span>=5000<span> </span>=20000<br />\r\n20<span> </span>=15000<span> </span>=40000<br />',' 普及+/提高 数学','2022-05-11 10:05:47',1.000,128,'N',2,2,0),(1005,'推销员','','','','Sample Input 1\r\n5\r\n1 2 3 4 5\r\n1 2 3 4 5\r\n\r\nSample Input 2\r\n5\r\n1 2 2 4 5\r\n5 4 3 4 1','Sample Output 1\r\n15\r\n19\r\n22\r\n24\r\n25\r\n\r\nSample Output 2\r\n12\r\n17\r\n21\r\n24\r\n27','0','','普及+/提高 排序 前后缀最大值','2022-05-18 22:01:52',5.000,128,'N',2,2,0),(1006,'纪念品','<a href=\"https://www.luogu.com.cn/problem/P5662\">题面</a>','','','\n','\n','0','',' 普及/提高- DP','2022-05-25 21:22:54',1.000,128,'N',2,6,0),(1007,'(XCX Round #1 A) Three Numbers','Give you a string $\\texttt{op}$ and a number $n$. Please output $a&#44; b&#44; c (0 \\le a&#44; b&#44; c \\le 10^9)$ that satisfy $\\texttt{op}(a&#44; b) + \\texttt{op}(b&#44; c) + \\texttt{op}(c&#44; a) = n$.<br />\r\nNote: $\\texttt{op}$ can be:<br />\r\n<li>\r\n	$\\texttt{diff}$ (Note: $\\texttt{diff}(x&#44; y) = |x - y|$)<br />\r\n</li>\r\n<li>\r\n	$\\texttt{gcd}$<br />\r\n</li>\r\n<li>\r\n	$\\texttt{xor}$ (Note: $\\texttt{xor}(x&#44; y) = x \\oplus y$)<br />\r\n</li>','The first line contains an interger $t$ (the number of test cases).<br />\r\nThe second line to the $(t+1)$th line contains $\\texttt{op}$ and $n$.<br />','The output contains $t$ lines.<br />\r\nFor each line&#44; it contains three numbers $a&#44; b&#44; c$ or just $-1$ for no solution.<br />','5\r\ndiff 4\r\ngcd 10\r\ndiff 3\r\nxor 5\r\ngcd 4','0 0 2\r\n1 8 8\r\n-1\r\n-1\r\n1 2 2','1','$t \\le 10000$<br />\r\nWhen $\\texttt{op}=\\texttt{diff}$&#44; $0 \\le n \\le 10^9$.<br />\r\nWhen $\\texttt{op}=\\texttt{gcd}$&#44; $3 \\le n \\le 10^9$.<br />\r\nWhen $\\texttt{op}=\\texttt{xor}$&#44; $1 \\le n \\le 10^9$.<br />','普及- XCXRound#1 构造','2022-08-21 18:33:26',1.000,128,'N',3,5,0),(1008,'(XCX Round #1 B1) 跳蚤 Easy','<img src=\"/upload/111.67.199.74/20220820/20220820172249_69116.jpg\" alt=\"\" /> <br />\r\n有两只跳蚤在一个正六边形上跳动，他们一开始处在正六边形的两个对角上，问跳 $n$ 次一共有多少种情况。 <br />\r\n注意：每一步两只跳蚤都可以跳动一个单位距离（即：正六边形的边长），并且在每一时刻两只跳蚤都不得在同一个点上。<br />','$n$。','情况数模 $988244533$。','2','9','0','对于 $100\\%$ 的数据，$1 \\le n \\le 10^9$。<br />','普及/提高- XCXRound#1 找规律','2022-08-21 18:38:49',1.000,128,'N',1,1,0),(1009,'(XCX Round #1 B2) 跳蚤 Hard','<img src=\"/upload/111.67.199.74/20220820/20220820173009_63911.jpg\" alt=\"\" /><br />\r\n有两只跳蚤在一个正六边形上跳动，他们一开始处在正六边形的两个角（用字符 $pos1&#44; pos2$ 表示）上，问跳 $n$ 次一共有多少种情况。 <br />\r\n注意：每一步两只跳蚤都可以跳动一个单位距离（即：正六边形的边长），并且在每一时刻两只跳蚤都不得在同一个点上。<br />','$pos1&#44; pos2&#44; n$','情况数模 $988244533$。','A C 2','9','0','对于 $100\\%$ 的数据，$pos1&#44; pos2 \\in [A&#44; F]&#44; 1 \\le n \\le 10^6$。<br />\r\n<strong>部分分</strong><br />\r\n对于测试点 $1$ 至 $3$，$0 &lt; n \\le 100$<br />\r\n对于测试点 $4$ 至 $6$，$100 &lt; n \\le 1000$<br />\r\n对于测试点 $7$ 至 $9$，$1000 &lt; n \\le 10000$<br />\r\n对于测试点 $10$ 至 $14$，$10000 &lt; n \\le 100000$<br />\r\n对于测试点 $15$ 至 $16$，$100000 &lt; n \\le 1000000$<br />\r\n对于测试点 $17$ 至 $20$，$n = 1000000$<br />\r\n<strong>注意</strong><br />\r\n请注意本题时间 &amp; 空间限制。<br />\r\n<div>\r\n	<br />\r\n</div>','普及/提高- XCXRound#1 DP 滚动数组','2022-08-21 18:38:58',1.000,8,'N',1,1,0),(1010,'(XCX Round #1 C1) 因式分解 Easy','小 X 在学因式分解，但是他喜欢打 <a href=\"https://github.com/xcx0902/nfls/blob/main/generals/fake-generals.cpp\" target=\"_blank\">fake-generals</a>，不想写作业，于是他让你写。<br />\r\n给出一个多项式，求它的最大公因式。<br />','第一行：$n$，表示多项式的项数。<br />\r\n后面，对于每个 $i(1 \\le i \\le n)$：<br />\r\n第一行：$m&#44; t$，分别表示该项字母个数和该项的系数。<br />\r\n第二至 $m+1$ 行：$c&#44; num$，分别表示每个字母以及它的指数。<br />','输出这个多项式的最大公因数（如有同类项，需要先合并同类项），具体格式见样例。','Sample 1:\r\n3\r\n2 10\r\na 1\r\nb 3\r\n3 15\r\na 2\r\nb 2\r\nc 2\r\n2 30\r\na 1\r\nb 3\r\n\r\nSample 2:\r\n2\r\n1 1\r\na 1\r\n1 2\r\na 1','Sample 1:\r\n5*a*b^2\r\n\r\nSample 2:\r\n3*a','0','$n \\le 10000$<br />\r\n$m \\le 26&#44; t \\le 10^9$<br />\r\n$c \\in [a&#44; z]&#44; num \\le 10^9$<br />','普及/提高- XCXRound#1 模拟','2022-08-21 18:46:14',1.000,128,'N',1,1,0),(1011,'(XCX Round #1 C2) 因式分解 Hard','小 X 刚学过因式分解，老师让他写因式分解的题目，可是他不想写，于是就想让你帮他做。<br />\r\n给出 $a&#44; b&#44; c&#44; d&#44; e&#44; f$，因式分解 $ax^2+bxy+cy^2+dx+ey+f$（保证可以分解成 $t(kx+ly+m)(nx+py+q)$ 的形式）。<br />','$a&#44; b&#44; c&#44; d&#44; e&#44; f$。','形如 $t(kx+ly+m)(nx+py+q)$ 的分解式。注意当 $k=1$ 或 $l=1$ 或 $n=1$ 或 $p=1$ 时应该省略系数 $1$。同理，当 $k=-1$ 或 $l=-1$ 或 $n=-1$ 或 $p=-1$ 时应该省略数字 $1$（保留符号 $-$）。','Sample 1:\r\n1 2 1 2 2 1\r\n\r\nSample 2:\r\n4 10 4 8 10 4\r\n','Sample 1:\r\n(x+y+1)(x+y+1)\r\n\r\nSample 2:\r\n2(x+2y+1)(2x+y+1)','1','$-10000 \\le a&#44; b&#44; c&#44; d&#44; e&#44; f \\le 100000$ 且 $acf \\ne 0$。<br />\r\n<strong>输出规定</strong><br />\r\n输出中 $t$ 必须为正数，即使当某一括号内都为负。另，每个括号内不需要保证第一个符号为正，只要按照 $x&#44; y&#44; 1$ 得顺序输出即可。<br />','普及+/提高 XCXRound#1 数学','2022-08-21 18:56:33',1.000,128,'N',2,2,0),(1012,'(XCX Round #1 D) 表达式','小 X 有一个表达式，包含英文小写字母，<span style=\"font-family:Courier New;\">|</span>，<span style=\"font-family:Courier New;\">*</span> 和 <span style=\"font-family:Courier New;\">?</span>。<br />\r\n老师对小 X 说，如果你能求出有多少个字符串（只包含英文小写字母）能匹配这个表达式，就可以免写作业。<br />\r\n具体地，如果一个字符串 $s$ 匹配一个表达式 $t$，那么：<br />\r\n<li>\r\n	将 $t$ 以 <span style=\"font-family:Courier New;\">|</span> 隔开后，$s$ 至少能匹配其中一个。\r\n</li>\r\n<li>\r\n	若 $t$ 中没有 <span style=\"font-family:Courier New;\">|</span> 那么至少有一种情况，使得 $t$ 中的 <span style=\"font-family:Courier New;\">?</span> 用一个字符替换，<span style=\"font-family:Courier New;\">*</span> 用任意多个字符替换后，与 $s$ 相等。\r\n</li>\r\n可是，小 X 很懒，既不想算，也不想写作业，于是就请你帮助他计算这个问题。<br />','只有一行，包含 $t$（即小 X 的表达式）。','只有一行，为能匹配 $t$ 的字符串（只包含英文小写字母）的数量，模 $988244533$。<br />\r\n如果有无数多个字符串（只包含英文小写字母）能匹配 $t$，输出 INF。<br />','Sample 1:\r\n???akioi|???afioi|xcxakioi|xcxafioi|???ak???|???af???\r\n\r\nSample 2:\r\n*ak*','Sample 1:\r\n617831552\r\n\r\nSample 2:\r\nINF','0','对于 $100\\%$ 的数据，<span style=\"font-family:Courier New;\">|</span> 的个数 $\\le 14$，每个被 <span style=\"font-family:Courier New;\">|</span> 隔开的字符串长度 $\\le 100$。<br />\r\n<strong>关于数据</strong><br />\r\n本题数据由数据生成器生成，你可以在<a href=\"https://codeforces.com/gym/390808/attachments/download/16835/gen.exe\">这里</a>下载。<br />\r\n数据生成命令： <br />\r\n<pre class=\"prettyprint lang-xm<x>l\">gen.exe 3 5 5 5 1\r\ngen.exe 4 5 5 5 1\r\ngen.exe 5 5 5 5 0\r\ngen.exe 6 5 5 5 0\r\ngen.exe 7 10 5 5 1\r\ngen.exe 8 10 5 5 0\r\ngen.exe 9 10 5 5 0\r\ngen.exe 10 10 5 5 0\r\ngen.exe 11 5 10 10 1\r\ngen.exe 12 5 10 10 1\r\ngen.exe 13 5 10 10 0\r\ngen.exe 14 5 10 10 0\r\ngen.exe 15 10 10 10 0\r\ngen.exe 16 10 50 55 0\r\ngen.exe 17 15 95 100 0\r\ngen.exe 18 15 95 100 0\r\ngen.exe 19 15 95 100 0\r\ngen.exe 20 15 95 100 0\r\ngen.exe 21 15 95 100 0\r\ngen.exe 22 15 95 100 0</pre>','提高+/省选- XCXRound#1 容斥','2022-08-21 19:42:22',1.000,128,'N',1,1,0);
/*!40000 ALTER TABLE `problem` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `reply`
--

DROP TABLE IF EXISTS `reply`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `reply` (
  `rid` int(11) NOT NULL AUTO_INCREMENT,
  `author_id` varchar(48) NOT NULL,
  `time` datetime NOT NULL DEFAULT '2016-05-13 19:24:00',
  `content` text NOT NULL,
  `topic_id` int(11) NOT NULL,
  `status` int(11) NOT NULL DEFAULT '0',
  `ip` varchar(46) NOT NULL,
  PRIMARY KEY (`rid`),
  KEY `author_id` (`author_id`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `reply`
--

LOCK TABLES `reply` WRITE;
/*!40000 ALTER TABLE `reply` DISABLE KEYS */;
INSERT INTO `reply` VALUES (1,'admin','2022-08-16 21:14:42','Hello everyone!\r\n\r\nWelcome to GXOJ!',1,0,'180.109.29.36');
/*!40000 ALTER TABLE `reply` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `runtimeinfo`
--

DROP TABLE IF EXISTS `runtimeinfo`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `runtimeinfo` (
  `solution_id` int(11) NOT NULL DEFAULT '0',
  `error` text,
  PRIMARY KEY (`solution_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `runtimeinfo`
--

LOCK TABLES `runtimeinfo` WRITE;
/*!40000 ALTER TABLE `runtimeinfo` DISABLE KEYS */;
INSERT INTO `runtimeinfo` VALUES (1001,'time_space_table:\n/1000/sample.in:AC mem=33740k time=29ms\n\n'),(1002,'time_space_table:\n/1000/sample.in:AC mem=4124k time=7ms\n\n'),(1003,'time_space_table:\n/1000/sample.in:AC mem=2016k time=0ms\n\n'),(1004,'time_space_table:\n/1000/sample.in:AC mem=33656k time=29ms\n\n'),(1005,'time_space_table:\n/1000/sample.in:AC mem=4128k time=7ms\n\n'),(1006,'time_space_table:\n/1000/sample.in:AC mem=33744k time=32ms\n\n'),(1007,'time_space_table:\n/1000/sample.in:AC mem=4120k time=7ms\n\n'),(1008,'========[sample.out]=========\nExpected						      |	Yours\nHello World!						      \\	<script languge=\"php\">\r								\n							      >	    echo(\"Hello World!\");\r								\n							      >	</script>\n==============================\ntime_space_table:\n/1000/sample.in:WA mem=4116k time=7ms\n\n'),(1010,'time_space_table:\n/1001/sample.in:AC mem=1116k time=0ms\n\n'),(1011,'time_space_table:\n/1001/sample.in:AC mem=33656k time=36ms\n\n'),(1012,'time_space_table:\n/1002/railway1.in:AC mem=1452k time=3ms\n/1002/railway10.in:AC mem=2384k time=212ms\n/1002/railway11.in:AC mem=7096k time=65ms\n/1002/railway12.in:AC mem=7096k time=628ms\n/1002/railway2.in:AC mem=7096k time=2ms\n/1002/railway3.in:AC mem=7096k time=7ms\n/1002/railway4.in:AC mem=7096k time=19ms\n/1002/railway5.in:AC mem=7096k time=729ms\n/1002/railway6.in:AC mem=7096k time=16ms\n/1002/railway7.in:AC mem=7096k time=109ms\n/1002/railway8.in:AC mem=7096k time=100ms\n/1002/railway9.in:AC mem=7096k time=156ms\n/1002/sample.in:AC mem=7096k time=4ms\n\n'),(1013,'time_space_table:\n/1000/sample.in:AC mem=33656k time=25ms\n\n'),(1014,'Traceback (most recent call last):\n  File \"Main.py\", line 2, in <module>\n    a=int(input())\nValueError: invalid literal for int() with base 10: \'1 2\'\n/1001/sample.in:	    non-zero return = 1 \n\n----time_space_table:----\n/1001/sample.in:RE mem=33656k time=32ms\n\n'),(1015,'time_space_table:\n/1001/sample.in:AC mem=2020k time=0ms\n\n'),(1016,'time_space_table:\n/1002/railway1.in:AC mem=1416k time=1ms\n/1002/railway10.in:AC mem=1928k time=236ms\n/1002/railway11.in:AC mem=1928k time=84ms\n/1002/railway12.in:AC mem=3456k time=707ms\n/1002/railway2.in:AC mem=3456k time=3ms\n/1002/railway3.in:AC mem=3456k time=6ms\n/1002/railway4.in:AC mem=3456k time=15ms\n/1002/railway5.in:AC mem=3464k time=727ms\n/1002/railway6.in:AC mem=3464k time=15ms\n/1002/railway7.in:AC mem=3464k time=115ms\n/1002/railway8.in:AC mem=3464k time=103ms\n/1002/railway9.in:AC mem=3464k time=165ms\n/1002/sample.in:AC mem=3464k time=3ms\n\n'),(1017,'time_space_table:\n/1001/sample.in:AC mem=2020k time=0ms\n\n'),(1018,'time_space_table:\n/1003/b0.in:AC mem=51004k time=0ms\n/1003/b1.in:AC mem=51004k time=66ms\n/1003/b2.in:AC mem=51004k time=227ms\n/1003/b3.in:AC mem=51004k time=66ms\n/1003/b4.in:AC mem=51004k time=647ms\n/1003/b5.in:AC mem=51004k time=684ms\n/1003/b6.in:AC mem=51004k time=746ms\n/1003/b7.in:AC mem=51004k time=632ms\n/1003/b8.in:AC mem=51004k time=702ms\n/1003/b9.in:AC mem=51004k time=839ms\n\n'),(1019,'/1003/b0.in:Killed\n/1003/b1.in:Killed\n/1003/b2.in:Killed\n/1003/b3.in:Killed\n/1003/b4.in:Killed\n/1003/b5.in:Segmentation fault\n/1003/b6.in:Segmentation fault\n/1003/b7.in:Segmentation fault\n/1003/b8.in:Segmentation fault\n/1003/b9.in:Segmentation fault\n----time_space_table:----\n/1003/b0.in:TLE mem=1404k time=2766ms\n/1003/b1.in:TLE mem=1720k time=2749ms\n/1003/b2.in:TLE mem=2488k time=2735ms\n/1003/b3.in:TLE mem=3644k time=2744ms\n/1003/b4.in:TLE mem=3660k time=2783ms\n/1003/b5.in:RE mem=3660k time=14ms\n/1003/b6.in:RE mem=3660k time=29ms\n/1003/b7.in:RE mem=3660k time=23ms\n/1003/b8.in:RE mem=3660k time=28ms\n/1003/b9.in:RE mem=3660k time=25ms\n\n'),(1020,'/1003/b0.in:Killed\n/1003/b1.in:Killed\n/1003/b2.in:Killed\n/1003/b3.in:Killed\n/1003/b4.in:Killed\n/1003/b5.in:Segmentation fault\n/1003/b6.in:Segmentation fault\n/1003/b7.in:Segmentation fault\n/1003/b8.in:Segmentation fault\n/1003/b9.in:Segmentation fault\n----time_space_table:----\n/1003/b0.in:TLE mem=1424k time=2774ms\n/1003/b1.in:TLE mem=1696k time=2749ms\n/1003/b2.in:TLE mem=2520k time=2751ms\n/1003/b3.in:TLE mem=3636k time=2773ms\n/1003/b4.in:TLE mem=3636k time=2766ms\n/1003/b5.in:RE mem=3636k time=15ms\n/1003/b6.in:RE mem=3636k time=22ms\n/1003/b7.in:RE mem=3636k time=25ms\n/1003/b8.in:RE mem=3636k time=27ms\n/1003/b9.in:RE mem=3636k time=22ms\n\n'),(1021,'/1003/b0.in:Killed\n/1003/b1.in:Killed\n/1003/b2.in:Killed\n/1003/b3.in:Killed\n/1003/b4.in:Killed\n/1003/b5.in:Segmentation fault\n/1003/b6.in:Segmentation fault\n/1003/b7.in:Segmentation fault\n/1003/b8.in:Segmentation fault\n/1003/b9.in:Segmentation fault\n----time_space_table:----\n/1003/b0.in:TLE mem=1428k time=2753ms\n/1003/b1.in:TLE mem=1588k time=2761ms\n/1003/b2.in:TLE mem=2124k time=2759ms\n/1003/b3.in:TLE mem=3168k time=2756ms\n/1003/b4.in:TLE mem=3168k time=2768ms\n/1003/b5.in:RE mem=3168k time=2ms\n/1003/b6.in:RE mem=3168k time=2ms\n/1003/b7.in:RE mem=3168k time=2ms\n/1003/b8.in:RE mem=3168k time=2ms\n/1003/b9.in:RE mem=3168k time=1ms\n\n'),(1022,'/1003/b0.in:Killed\n/1003/b1.in:Killed\n/1003/b2.in:Killed\n/1003/b3.in:Killed\n/1003/b4.in:Killed\n/1003/b5.in:Segmentation fault\n/1003/b6.in:Segmentation fault\n/1003/b7.in:Segmentation fault\n/1003/b8.in:Segmentation fault\n/1003/b9.in:Segmentation fault\n----time_space_table:----\n/1003/b0.in:TLE mem=1412k time=2766ms\n/1003/b1.in:TLE mem=1684k time=2749ms\n/1003/b2.in:TLE mem=2504k time=2775ms\n/1003/b3.in:TLE mem=3624k time=2765ms\n/1003/b4.in:TLE mem=3632k time=2751ms\n/1003/b5.in:RE mem=3632k time=15ms\n/1003/b6.in:RE mem=3632k time=22ms\n/1003/b7.in:RE mem=3632k time=22ms\n/1003/b8.in:RE mem=3632k time=22ms\n/1003/b9.in:RE mem=3632k time=31ms\n\n'),(1023,'/1003/b0.in:Killed\n/1003/b1.in:Killed\n/1003/b2.in:Killed\n/1003/b3.in:Killed\n/1003/b4.in:Killed\n/1003/b5.in:Segmentation fault\n/1003/b6.in:Segmentation fault\n/1003/b7.in:Segmentation fault\n/1003/b8.in:Segmentation fault\n/1003/b9.in:Segmentation fault\n----time_space_table:----\n/1003/b0.in:TLE mem=1448k time=2767ms\n/1003/b1.in:TLE mem=1596k time=2761ms\n/1003/b2.in:TLE mem=2128k time=2759ms\n/1003/b3.in:TLE mem=3164k time=2762ms\n/1003/b4.in:TLE mem=3164k time=2749ms\n/1003/b5.in:RE mem=3164k time=2ms\n/1003/b6.in:RE mem=3164k time=2ms\n/1003/b7.in:RE mem=3164k time=1ms\n/1003/b8.in:RE mem=3164k time=3ms\n/1003/b9.in:RE mem=3164k time=2ms\n\n'),(1026,'/1003/b5.in:Segmentation fault\n/1003/b6.in:Segmentation fault\n/1003/b7.in:Segmentation fault\n/1003/b8.in:Segmentation fault\n/1003/b9.in:Segmentation fault\n----time_space_table:----\n/1003/b0.in:AC mem=1404k time=5ms\n/1003/b1.in:AC mem=1964k time=72ms\n/1003/b2.in:AC mem=3608k time=226ms\n/1003/b3.in:AC mem=5872k time=81ms\n/1003/b4.in:AC mem=5896k time=660ms\n/1003/b5.in:RE mem=5896k time=84ms\n/1003/b6.in:RE mem=5896k time=138ms\n/1003/b7.in:RE mem=5896k time=140ms\n/1003/b8.in:RE mem=5896k time=142ms\n/1003/b9.in:RE mem=5896k time=139ms\n\n'),(1027,'/1003/b0.in:Killed\n/1003/b1.in:Killed\n/1003/b2.in:Killed\n/1003/b3.in:Killed\n/1003/b4.in:Killed\n/1003/b5.in:Segmentation fault\n/1003/b6.in:Segmentation fault\n/1003/b7.in:Segmentation fault\n/1003/b8.in:Segmentation fault\n/1003/b9.in:Segmentation fault\n----time_space_table:----\n/1003/b0.in:TLE mem=1412k time=2763ms\n/1003/b1.in:TLE mem=1780k time=2755ms\n/1003/b2.in:TLE mem=2840k time=2747ms\n/1003/b3.in:TLE mem=4936k time=2753ms\n/1003/b4.in:TLE mem=4936k time=2764ms\n/1003/b5.in:RE mem=4936k time=2ms\n/1003/b6.in:RE mem=4936k time=2ms\n/1003/b7.in:RE mem=4936k time=1ms\n/1003/b8.in:RE mem=4936k time=1ms\n/1003/b9.in:RE mem=4936k time=1ms\n\n'),(1028,'/1003/b5.in:Segmentation fault\n/1003/b6.in:Segmentation fault\n/1003/b7.in:Segmentation fault\n/1003/b8.in:Segmentation fault\n/1003/b9.in:Segmentation fault\n----time_space_table:----\n/1003/b0.in:AC mem=1432k time=3ms\n/1003/b1.in:AC mem=1984k time=70ms\n/1003/b2.in:AC mem=3648k time=223ms\n/1003/b3.in:AC mem=5896k time=86ms\n/1003/b4.in:AC mem=5940k time=686ms\n/1003/b5.in:RE mem=5940k time=80ms\n/1003/b6.in:RE mem=5940k time=143ms\n/1003/b7.in:RE mem=5940k time=138ms\n/1003/b8.in:RE mem=5940k time=143ms\n/1003/b9.in:RE mem=5940k time=140ms\n\n'),(1029,'/1003/b0.in:Killed\n/1003/b1.in:Killed\n/1003/b2.in:Killed\n/1003/b3.in:Killed\n/1003/b4.in:Killed\n/1003/b5.in:Segmentation fault\n/1003/b6.in:Segmentation fault\n/1003/b7.in:Segmentation fault\n/1003/b8.in:Segmentation fault\n/1003/b9.in:Segmentation fault\n----time_space_table:----\n/1003/b0.in:TLE mem=1452k time=2755ms\n/1003/b1.in:TLE mem=1772k time=2725ms\n/1003/b2.in:TLE mem=2852k time=2766ms\n/1003/b3.in:TLE mem=4944k time=2763ms\n/1003/b4.in:TLE mem=4944k time=2749ms\n/1003/b5.in:RE mem=4944k time=2ms\n/1003/b6.in:RE mem=4944k time=2ms\n/1003/b7.in:RE mem=4944k time=2ms\n/1003/b8.in:RE mem=4944k time=1ms\n/1003/b9.in:RE mem=4944k time=1ms\n\n'),(1030,'time_space_table:\n/1003/b0.in:OLE mem=12984k time=44ms\n/1003/b1.in:OLE mem=12984k time=38ms\n/1003/b2.in:OLE mem=12984k time=43ms\n/1003/b3.in:OLE mem=12984k time=40ms\n/1003/b4.in:OLE mem=12984k time=62ms\n/1003/b5.in:OLE mem=12984k time=62ms\n/1003/b6.in:OLE mem=12984k time=64ms\n/1003/b7.in:OLE mem=12984k time=59ms\n/1003/b8.in:OLE mem=12984k time=60ms\n/1003/b9.in:OLE mem=12984k time=67ms\n\n'),(1031,'time_space_table:\n/1003/b0.in:AC mem=1388k time=3ms\n/1003/b1.in:AC mem=1780k time=73ms\n/1003/b2.in:AC mem=3000k time=225ms\n/1003/b3.in:AC mem=4668k time=71ms\n/1003/b4.in:AC mem=4668k time=617ms\n/1003/b5.in:AC mem=27152k time=719ms\n/1003/b6.in:AC mem=27908k time=741ms\n/1003/b7.in:AC mem=27924k time=662ms\n/1003/b8.in:AC mem=27940k time=739ms\n/1003/b9.in:AC mem=27940k time=866ms\n\n'),(1032,'time_space_table:\n/1000/sample.in:AC mem=2016k time=0ms\n\n'),(1033,'/1003/b5.in:Segmentation fault\n/1003/b6.in:Segmentation fault\n/1003/b7.in:Segmentation fault\n/1003/b8.in:Segmentation fault\n/1003/b9.in:Segmentation fault\n----time_space_table:----\n/1003/b0.in:AC mem=1448k time=4ms\n/1003/b1.in:AC mem=1960k time=70ms\n/1003/b2.in:AC mem=3636k time=224ms\n/1003/b3.in:AC mem=5896k time=78ms\n/1003/b4.in:AC mem=5932k time=643ms\n/1003/b5.in:RE mem=20124k time=95ms\n/1003/b6.in:RE mem=20568k time=152ms\n/1003/b7.in:RE mem=20572k time=150ms\n/1003/b8.in:RE mem=20628k time=155ms\n/1003/b9.in:RE mem=20628k time=155ms\n\n'),(1034,'/1003/b5.in:Segmentation fault\n/1003/b6.in:Segmentation fault\n/1003/b7.in:Segmentation fault\n/1003/b8.in:Segmentation fault\n/1003/b9.in:Segmentation fault\n----time_space_table:----\n/1003/b0.in:AC mem=1404k time=5ms\n/1003/b1.in:AC mem=1980k time=70ms\n/1003/b2.in:AC mem=3640k time=260ms\n/1003/b3.in:AC mem=5896k time=82ms\n/1003/b4.in:AC mem=5920k time=667ms\n/1003/b5.in:RE mem=20072k time=117ms\n/1003/b6.in:RE mem=20552k time=157ms\n/1003/b7.in:RE mem=20552k time=158ms\n/1003/b8.in:RE mem=20552k time=156ms\n/1003/b9.in:RE mem=20576k time=158ms\n\n'),(1035,'time_space_table:\n/1003/b0.in:AC mem=1440k time=4ms\n/1003/b1.in:AC mem=1988k time=90ms\n/1003/b2.in:AC mem=3652k time=270ms\n/1003/b3.in:AC mem=5912k time=85ms\n/1003/b4.in:AC mem=5916k time=655ms\n/1003/b5.in:AC mem=36536k time=805ms\n/1003/b6.in:AC mem=38104k time=877ms\n/1003/b7.in:AC mem=38104k time=803ms\n/1003/b8.in:AC mem=38104k time=890ms\n/1003/b9.in:AC mem=38104k time=1021ms\n\n'),(1036,'/1003/b5.in:Segmentation fault\n/1003/b6.in:Segmentation fault\n/1003/b7.in:Segmentation fault\n/1003/b8.in:Segmentation fault\n/1003/b9.in:Segmentation fault\n----time_space_table:----\n/1003/b0.in:OLE mem=1404k time=3ms\n/1003/b1.in:OLE mem=2212k time=70ms\n/1003/b2.in:OLE mem=4632k time=217ms\n/1003/b3.in:OLE mem=7956k time=56ms\n/1003/b4.in:WA mem=7956k time=18ms\n/1003/b5.in:RE mem=7956k time=8ms\n/1003/b6.in:RE mem=7956k time=8ms\n/1003/b7.in:RE mem=7956k time=6ms\n/1003/b8.in:RE mem=7956k time=8ms\n/1003/b9.in:RE mem=7956k time=8ms\n\n'),(1037,'/1003/b5.in:Segmentation fault\n/1003/b6.in:Segmentation fault\n/1003/b7.in:Segmentation fault\n/1003/b8.in:Segmentation fault\n/1003/b9.in:Segmentation fault\n----time_space_table:----\n/1003/b0.in:OLE mem=1444k time=3ms\n/1003/b1.in:OLE mem=2200k time=50ms\n/1003/b2.in:OLE mem=4652k time=223ms\n/1003/b3.in:OLE mem=7948k time=56ms\n/1003/b4.in:WA mem=7988k time=22ms\n/1003/b5.in:RE mem=7988k time=6ms\n/1003/b6.in:RE mem=7988k time=8ms\n/1003/b7.in:RE mem=7988k time=6ms\n/1003/b8.in:RE mem=7988k time=8ms\n/1003/b9.in:RE mem=7988k time=8ms\n\n'),(1038,'========[b4.out]=========\nExpected						      |	Yours\n100907\r							      |	-1000000000000000000\n163272\r							      |	-1000000000000000000\n100907\r							      |	-1000000000000000000\n123761\r							      |	163272\n188727\r							      |	-1000000000000000000\n59312\r							      |	-1000000000000000000\n20528\r							      |	-1000000000000000000\n188727\r							      |	100907\n100907\r							      |	123761\n15813\r							      |	-1000000000000000000\n182250\r							      |	187789\n105825\r							      |	-1000000000000000000\n59312\r							      |	-1000000000000000000\n38403\r							      |	-1000000000000000000\n100105\r							      |	100907\n100907\r							      |	15813\n59312\r							      |	181312\n123761\r							      |	105825\n73589\r							      |	-1000000000000000000\n22801\r							      |	59312\n184108\r							      |	-1000000000000000000\n54753\r							      |	-1000000000000000000\n58585\r							      |	98404\n189498\r							      |	-1000000000000000000\n58585\r							      |	59312\n189498\r							      |	-1000000000000000000\n55517\r							      |	-1000000000000000000\n181670\r							      |	73589\n22130\r							      |	-1000000000000000000\n36800\r							      |	-1000000000000000000\n113234\r							      |	22801\n13016\r							      |	-1000000000000000000\n188458\r							      |	181312\n124193\r							      |	-1000000000000000000\n43008\r							      |	-1000000000000000000\n181981\r							      |	-1000000000000000000\n124193\r							      |	56166\n125521\r							      |	59312\n125521\r							      |	-1000000000000000000\n182302\r							      |	59312\n182302\r							      |	-1000000000000000000\n104843\r							      |	187789\n20774\r							      |	-1000000000000000000\n125521\r							      |	-1000000000000000000\n189423\r							      |	-1000000000000000000\n86465\r							      |	-1000000000000000000\n125716\r							      |	-1000000000000000000\n125716\r							      |	-1000000000000000000\n10261\r							      |	-1000000000000000000\n59405\r							      |	-1000000000000000000\n114562\r							      |	-1000000000000000000\n125716\r							      |	-1000000000000000000\n100907\r							      |	38403\n47374\r							      |	-1000000000000000000\n98799\r							      |	112802\n59405\r							      |	13016\n137352\r							      |	-1000000000000000000\n100907\r							      |	-1000000000000000000\n59405\r							      |	-1000000000000000000\n102930\r							      |	-1000000000000000000\n101898\r							      |	-1000000000000000000\n126342\r							      |	-1000000000000000000\n126342\r							      |	181312\n59405\r							      |	-1000000000000000000\n179773\r							      |	-1000000000000000000\n58572\r							      |	-1000000000000000000\n184423\r							      |	-1000000000000000000\n101898\r							      |	-1000000000000000000\n37519\r							      |	-1000000000000000000\n126342\r							      |	-1000000000000000000\n134477\r							      |	-1000000000000000000\n14175\r							      |	180408\n180914\r							      |	103083\n187724\r							      |	20774\n31064\r							      |	123761\n85002\r							      |	-1000000000000000000\n55226\r							      |	-1000000000000000000\n58572\r							      |	-1000000000000000000\n187724\r							      |	-1000000000000000000\n58572\r							      |	-1000000000000000000\n28717\r							      |	-1000000000000000000\n24952\r							      |	86465\n55226\r							      |	123761\n88132\r							      |	-1000000000000000000\n186068\r							      |	-1000000000000000000\n101898\r							      |	-1000000000000000000\n35198\r							      |	-1000000000000000000\n101898\r							      |	59312\n101898\r							      |	112802\n185564\r							      |	-1000000000000000000\n185564\r							      |	-1000000000000000000\n185564\r							      |	100907\n58572\r							      |	-1000000000000000000\n185564\r							      |	-1000000000000000000\n132317\r							      |	47689\n5069\r							      |	98799\n58572\r							      |	-1000000000000000000\n185564\r							      |	-1000000000000000000\n22342\r							      |	59312\n55681\r							      |	-1000000000000000000\n\n==============================\n========[b5.out]=========\nExpected						      |	Yours\n221383\r							      |	-1000000000000000000\n172954\r							      |	172954\n54998\r							      |	-1000000000000000000\n172954\r							      |	-1000000000000000000\n221853\r							      |	-1000000000000000000\n88142\r							      |	172954\n172954\r							      |	221383\n221853\r							      |	-1000000000000000000\n221853\r							      |	-1000000000000000000\n179050\r							      |	-1000000000000000000\n172954\r							      |	-1000000000000000000\n64949\r							      |	-1000000000000000000\n60441\r							      |	-1000000000000000000\n172954\r							      |	88142\n221853\r							      |	-1000000000000000000\n172954\r							      |	172954\n147535\r							      |	-1000000000000000000\n172954\r							      |	-1000000000000000000\n107607\r							      |	-1000000000000000000\n220983\r							      |	179050\n173334\r							      |	172954\n30678\r							      |	-1000000000000000000\n218122\r							      |	-1000000000000000000\n218339\r							      |	-1000000000000000000\n174675\r							      |	-1000000000000000000\n93990\r							      |	-1000000000000000000\n95635\r							      |	-1000000000000000000\n96523\r							      |	-1000000000000000000\n218339\r							      |	147065\n50096\r							      |	-1000000000000000000\n218339\r							      |	-1000000000000000000\n218339\r							      |	-1000000000000000000\n174675\r							      |	172954\n104821\r							      |	-1000000000000000000\n38637\r							      |	-1000000000000000000\n132680\r							      |	-1000000000000000000\n218339\r							      |	-1000000000000000000\n174675\r							      |	-1000000000000000000\n93990\r							      |	-1000000000000000000\n174675\r							      |	107571\n212156\r							      |	-1000000000000000000\n197639\r							      |	-1000000000000000000\n218339\r							      |	-1000000000000000000\n218339\r							      |	-1000000000000000000\n218339\r							      |	-1000000000000000000\n218339\r							      |	-1000000000000000000\n62182\r							      |	-1000000000000000000\n218122\r							      |	-1000000000000000000\n71403\r							      |	-1000000000000000000\n218122\r							      |	-1000000000000000000\n28364\r							      |	-1000000000000000000\n212156\r							      |	172954\n174257\r							      |	-1000000000000000000\n218122\r							      |	30678\n128390\r							      |	-1000000000000000000\n218122\r							      |	-1000000000000000000\n212804\r							      |	-1000000000000000000\n93990\r							      |	-1000000000000000000\n90248\r							      |	-1000000000000000000\n218770\r							      |	221383\n218770\r							      |	-1000000000000000000\n174257\r							      |	-1000000000000000000\n217425\r							      |	-1000000000000000000\n95635\r							      |	-1000000000000000000\n174257\r							      |	-1000000000000000000\n86075\r							      |	-1000000000000000000\n23443\r							      |	-1000000000000000000\n174257\r							      |	-1000000000000000000\n180831\r							      |	95178\n93990\r							      |	95635\n213164\r							      |	97228\n174257\r							      |	-1000000000000000000\n174257\r							      |	-1000000000000000000\n106864\r							      |	49320\n217781\r							      |	-1000000000000000000\n46131\r							      |	-1000000000000000000\n217781\r							      |	-1000000000000000000\n157806\r							      |	-1000000000000000000\n98855\r							      |	-1000000000000000000\n217781\r							      |	-1000000000000000000\n98855\r							      |	-1000000000000000000\n217781\r							      |	172954\n77277\r							      |	-1000000000000000000\n95635\r							      |	-1000000000000000000\n218167\r							      |	-1000000000000000000\n218167\r							      |	-1000000000000000000\n103087\r							      |	-1000000000000000000\n218167\r							      |	-1000000000000000000\n173739\r							      |	221383\n173739\r							      |	-1000000000000000000\n99403\r							      |	95178\n93990\r							      |	-1000000000000000000\n173739\r							      |	-1000000000000000000\n218167\r							      |	199720\n93990\r							      |	221383\n218167\r							      |	-1000000000000000000\n218167\r							      |	-1000000000000000000\n219114\r							      |	-1000000000000000000\n137096\r							      |	-1000000000000000000\n173739\r							      |	-1000000000000000000\n\n==============================\n========[b6.out]=========\nExpected						      |	Yours\n70070\r							      |	-1000000000000000000\n141004\r							      |	-1000000000000000000\n326515\r							      |	-1000000000000000000\n221638\r							      |	-1000000000000000000\n149148\r							      |	-1000000000000000000\n231804\r							      |	-1000000000000000000\n149148\r							      |	-1000000000000000000\n202582\r							      |	-1000000000000000000\n136830\r							      |	-1000000000000000000\n352540\r							      |	-1000000000000000000\n149148\r							      |	-1000000000000000000\n157016\r							      |	-1000000000000000000\n353029\r							      |	-1000000000000000000\n79319\r							      |	-1000000000000000000\n46755\r							      |	-1000000000000000000\n59479\r							      |	231804\n240171\r							      |	-1000000000000000000\n149148\r							      |	150191\n149148\r							      |	202582\n317861\r							      |	-1000000000000000000\n317176\r							      |	136830\n233407\r							      |	-1000000000000000000\n77930\r							      |	352157\n315785\r							      |	-1000000000000000000\n233023\r							      |	-1000000000000000000\n140888\r							      |	-1000000000000000000\n445530\r							      |	-1000000000000000000\n239787\r							      |	-1000000000000000000\n204185\r							      |	352157\n289208\r							      |	-1000000000000000000\n206015\r							      |	-1000000000000000000\n150467\r							      |	-1000000000000000000\n259253\r							      |	-1000000000000000000\n140888\r							      |	-1000000000000000000\n150467\r							      |	-1000000000000000000\n77920\r							      |	-1000000000000000000\n94105\r							      |	238568\n239020\r							      |	150191\n280553\r							      |	-1000000000000000000\n239020\r							      |	-1000000000000000000\n150467\r							      |	-1000000000000000000\n150467\r							      |	-1000000000000000000\n316599\r							      |	-1000000000000000000\n232256\r							      |	-1000000000000000000\n86262\r							      |	-1000000000000000000\n239020\r							      |	-1000000000000000000\n257740\r							      |	-1000000000000000000\n340555\r							      |	77930\n167720\r							      |	-1000000000000000000\n239020\r							      |	-1000000000000000000\n239020\r							      |	315190\n77986\r							      |	-1000000000000000000\n139502\r							      |	-1000000000000000000\n286322\r							      |	140333\n439257\r							      |	-1000000000000000000\n349521\r							      |	-1000000000000000000\n437766\r							      |	-1000000000000000000\n437766\r							      |	443261\n151805\r							      |	-1000000000000000000\n279861\r							      |	-1000000000000000000\n257256\r							      |	-1000000000000000000\n138073\r							      |	202582\n89589\r							      |	-1000000000000000000\n238344\r							      |	-1000000000000000000\n437643\r							      |	288504\n193043\r							      |	206015\n316451\r							      |	-1000000000000000000\n438441\r							      |	-1000000000000000000\n151805\r							      |	-1000000000000000000\n438613\r							      |	150191\n50962\r							      |	-1000000000000000000\n146115\r							      |	-1000000000000000000\n238344\r							      |	140333\n277240\r							      |	-1000000000000000000\n349857\r							      |	-1000000000000000000\n266107\r							      |	-1000000000000000000\n438739\r							      |	150191\n364352\r							      |	79531\n77920\r							      |	-1000000000000000000\n285645\r							      |	-1000000000000000000\n251761\r							      |	280894\n438840\r							      |	238568\n87466\r							      |	-1000000000000000000\n202742\r							      |	150191\n285746\r							      |	-1000000000000000000\n238332\r							      |	-1000000000000000000\n142339\r							      |	-1000000000000000000\n438980\r							      |	-1000000000000000000\n440104\r							      |	-1000000000000000000\n332675\r							      |	231804\n151805\r							      |	-1000000000000000000\n87466\r							      |	-1000000000000000000\n349549\r							      |	-1000000000000000000\n142339\r							      |	260115\n237480\r							      |	-1000000000000000000\n251862\r							      |	-1000000000000000000\n50962\r							      |	342225\n237480\r							      |	-1000000000000000000\n87466\r							      |	167015\n237480\r							      |	-1000000000000000000\n\n==============================\n========[b7.out]=========\nExpected						      |	Yours\n341639\r							      |	-1000000000000000000\n173117\r							      |	-1000000000000000000\n140263\r							      |	341196\n20403\r							      |	173117\n330072\r							      |	140263\n173117\r							      |	-1000000000000000000\n226130\r							      |	20403\n227748\r							      |	-1000000000000000000\n219707\r							      |	-1000000000000000000\n173117\r							      |	-1000000000000000000\n291001\r							      |	-1000000000000000000\n341801\r							      |	-1000000000000000000\n267798\r							      |	-1000000000000000000\n340595\r							      |	-1000000000000000000\n224445\r							      |	-1000000000000000000\n340595\r							      |	-1000000000000000000\n95357\r							      |	-1000000000000000000\n198208\r							      |	173117\n110541\r							      |	225984\n224104\r							      |	227783\n187622\r							      |	219707\n140263\r							      |	-1000000000000000000\n198208\r							      |	-1000000000000000000\n198208\r							      |	-1000000000000000000\n70858\r							      |	-1000000000000000000\n217681\r							      |	-1000000000000000000\n116518\r							      |	-1000000000000000000\n340934\r							      |	-1000000000000000000\n161755\r							      |	-1000000000000000000\n198208\r							      |	-1000000000000000000\n227748\r							      |	289882\n188367\r							      |	-1000000000000000000\n224784\r							      |	-1000000000000000000\n136806\r							      |	-1000000000000000000\n340934\r							      |	-1000000000000000000\n198208\r							      |	-1000000000000000000\n340934\r							      |	-1000000000000000000\n340934\r							      |	-1000000000000000000\n92069\r							      |	-1000000000000000000\n121309\r							      |	-1000000000000000000\n340349\r							      |	-1000000000000000000\n224603\r							      |	-1000000000000000000\n162387\r							      |	341196\n227344\r							      |	-1000000000000000000\n340281\r							      |	-1000000000000000000\n198208\r							      |	-1000000000000000000\n198208\r							      |	-1000000000000000000\n339082\r							      |	-1000000000000000000\n339082\r							      |	-1000000000000000000\n81622\r							      |	-1000000000000000000\n316326\r							      |	-1000000000000000000\n188999\r							      |	-1000000000000000000\n181342\r							      |	95555\n182411\r							      |	-1000000000000000000\n162387\r							      |	-1000000000000000000\n118696\r							      |	-1000000000000000000\n115221\r							      |	-1000000000000000000\n188999\r							      |	-1000000000000000000\n217681\r							      |	-1000000000000000000\n224468\r							      |	-1000000000000000000\n340211\r							      |	-1000000000000000000\n224468\r							      |	-1000000000000000000\n126203\r							      |	-1000000000000000000\n227344\r							      |	-1000000000000000000\n224468\r							      |	-1000000000000000000\n340211\r							      |	-1000000000000000000\n340211\r							      |	225984\n92069\r							      |	-1000000000000000000\n190737\r							      |	-1000000000000000000\n340211\r							      |	-1000000000000000000\n196619\r							      |	-1000000000000000000\n190737\r							      |	198221\n196619\r							      |	198221\n190737\r							      |	71101\n221412\r							      |	-1000000000000000000\n145834\r							      |	219707\n85284\r							      |	-1000000000000000000\n140263\r							      |	118949\n122117\r							      |	-1000000000000000000\n338541\r							      |	-1000000000000000000\n338486\r							      |	-1000000000000000000\n340167\r							      |	-1000000000000000000\n224408\r							      |	-1000000000000000000\n340167\r							      |	-1000000000000000000\n192350\r							      |	-1000000000000000000\n196619\r							      |	225984\n224408\r							      |	-1000000000000000000\n189565\r							      |	-1000000000000000000\n196619\r							      |	-1000000000000000000\n109572\r							      |	-1000000000000000000\n340528\r							      |	-1000000000000000000\n228119\r							      |	341196\n189905\r							      |	-1000000000000000000\n224408\r							      |	-1000000000000000000\n111335\r							      |	-1000000000000000000\n224408\r							      |	-1000000000000000000\n196619\r							      |	-1000000000000000000\n189905\r							      |	-1000000000000000000\n196619\r							      |	-1000000000000000000\n304914\r							      |	-1000000000000000000\n\n==============================\n========[b9.out]=========\nExpected						      |	Yours\n236348\r							      |	-1000000000000000000\n236348\r							      |	-1000000000000000000\n86593\r							      |	-1000000000000000000\n241368\r							      |	236348\n241368\r							      |	-1000000000000000000\n196157\r							      |	241368\n241368\r							      |	-1000000000000000000\n51650\r							      |	-1000000000000000000\n139733\r							      |	241368\n'),(1039,'time_space_table:\n/1004/magic1.in:AC mem=1428k time=4ms\n/1004/magic10.in:AC mem=1440k time=3ms\n/1004/magic11.in:AC mem=1440k time=5ms\n/1004/magic12.in:AC mem=1444k time=5ms\n/1004/magic13.in:AC mem=1444k time=7ms\n/1004/magic14.in:AC mem=1444k time=9ms\n/1004/magic15.in:AC mem=1444k time=11ms\n/1004/magic16.in:AC mem=1448k time=19ms\n/1004/magic17.in:AC mem=1448k time=47ms\n/1004/magic18.in:AC mem=1496k time=115ms\n/1004/magic19.in:AC mem=1572k time=239ms\n/1004/magic2.in:AC mem=1572k time=2ms\n/1004/magic20.in:AC mem=1864k time=502ms\n/1004/magic3.in:AC mem=1864k time=1ms\n/1004/magic4.in:AC mem=1864k time=2ms\n/1004/magic5.in:AC mem=1864k time=2ms\n/1004/magic6.in:AC mem=1864k time=15ms\n/1004/magic7.in:AC mem=1864k time=2ms\n/1004/magic8.in:AC mem=1864k time=9ms\n/1004/magic9.in:AC mem=1864k time=1ms\n\n'),(1040,'time_space_table:\n/1004/magic1.in:AC mem=2628k time=3ms\n/1004/magic10.in:AC mem=2628k time=5ms\n/1004/magic11.in:AC mem=2628k time=6ms\n/1004/magic12.in:AC mem=2628k time=6ms\n/1004/magic13.in:AC mem=2628k time=8ms\n/1004/magic14.in:AC mem=2628k time=10ms\n/1004/magic15.in:AC mem=2628k time=15ms\n/1004/magic16.in:AC mem=2628k time=26ms\n/1004/magic17.in:AC mem=2628k time=65ms\n/1004/magic18.in:AC mem=2628k time=122ms\n/1004/magic19.in:AC mem=2628k time=260ms\n/1004/magic2.in:AC mem=2628k time=2ms\n/1004/magic20.in:AC mem=2628k time=559ms\n/1004/magic3.in:AC mem=2628k time=2ms\n/1004/magic4.in:AC mem=2628k time=3ms\n/1004/magic5.in:AC mem=2628k time=1ms\n/1004/magic6.in:AC mem=2628k time=2ms\n/1004/magic7.in:AC mem=2628k time=3ms\n/1004/magic8.in:AC mem=2628k time=2ms\n/1004/magic9.in:AC mem=2628k time=8ms\n\n'),(1042,'time_space_table:\n/1005/salesman1.in:AC mem=6248k time=3ms\n/1005/salesman10.in:AC mem=6248k time=1125ms\n/1005/salesman2.in:AC mem=6248k time=1ms\n/1005/salesman3.in:AC mem=6248k time=3ms\n/1005/salesman4.in:AC mem=6248k time=4ms\n/1005/salesman5.in:AC mem=6248k time=12ms\n/1005/salesman6.in:AC mem=6248k time=15ms\n/1005/salesman7.in:AC mem=6248k time=1155ms\n/1005/salesman8.in:AC mem=6248k time=1226ms\n/1005/salesman9.in:AC mem=6248k time=1247ms\n\n'),(1041,''),(1043,'/1006/souvenir1.in:Segmentation fault\n/1006/souvenir10.in:Segmentation fault\n/1006/souvenir11.in:Segmentation fault\n/1006/souvenir12.in:Segmentation fault\n/1006/souvenir13.in:Segmentation fault\n/1006/souvenir14.in:Segmentation fault\n/1006/souvenir15.in:Segmentation fault\n/1006/souvenir16.in:Segmentation fault\n/1006/souvenir17.in:Segmentation fault\n/1006/souvenir18.in:Segmentation fault\n/1006/souvenir19.in:Segmentation fault\n/1006/souvenir2.in:Segmentation fault\n/1006/souvenir20.in:Segmentation fault\n/1006/souvenir3.in:Segmentation fault\n/1006/souvenir4.in:Segmentation fault\n/1006/souvenir5.in:Segmentation fault\n/1006/souvenir6.in:Segmentation fault\n/1006/souvenir7.in:Segmentation fault\n/1006/souvenir8.in:Segmentation fault\n/1006/souvenir9.in:Segmentation fault\n----time_space_table:----\n/1006/souvenir1.in:RE mem=952k time=0ms\n/1006/souvenir10.in:RE mem=952k time=0ms\n/1006/souvenir11.in:RE mem=952k time=0ms\n/1006/souvenir12.in:RE mem=952k time=0ms\n/1006/souvenir13.in:RE mem=952k time=0ms\n/1006/souvenir14.in:RE mem=952k time=0ms\n/1006/souvenir15.in:RE mem=952k time=0ms\n/1006/souvenir16.in:RE mem=952k time=0ms\n/1006/souvenir17.in:RE mem=952k time=0ms\n/1006/souvenir18.in:RE mem=952k time=0ms\n/1006/souvenir19.in:RE mem=952k time=0ms\n/1006/souvenir2.in:RE mem=952k time=0ms\n/1006/souvenir20.in:RE mem=952k time=0ms\n/1006/souvenir3.in:RE mem=952k time=0ms\n/1006/souvenir4.in:RE mem=952k time=0ms\n/1006/souvenir5.in:RE mem=952k time=0ms\n/1006/souvenir6.in:RE mem=952k time=0ms\n/1006/souvenir7.in:RE mem=952k time=0ms\n/1006/souvenir8.in:RE mem=952k time=0ms\n/1006/souvenir9.in:RE mem=952k time=0ms\n\n'),(1044,':Segmentation fault\n'),(1045,':Segmentation fault\n'),(1046,'/1006/souvenir1.in:Segmentation fault\n/1006/souvenir10.in:Segmentation fault\n/1006/souvenir11.in:Segmentation fault\n/1006/souvenir12.in:Segmentation fault\n/1006/souvenir13.in:Segmentation fault\n/1006/souvenir14.in:Segmentation fault\n/1006/souvenir15.in:Segmentation fault\n/1006/souvenir16.in:Segmentation fault\n/1006/souvenir17.in:Segmentation fault\n/1006/souvenir18.in:Segmentation fault\n/1006/souvenir19.in:Segmentation fault\n/1006/souvenir2.in:Segmentation fault\n/1006/souvenir20.in:Segmentation fault\n/1006/souvenir3.in:Segmentation fault\n/1006/souvenir4.in:Segmentation fault\n/1006/souvenir5.in:Segmentation fault\n/1006/souvenir6.in:Segmentation fault\n/1006/souvenir7.in:Segmentation fault\n/1006/souvenir8.in:Segmentation fault\n/1006/souvenir9.in:Segmentation fault\n----time_space_table:----\n/1006/souvenir1.in:RE mem=952k time=0ms\n/1006/souvenir10.in:RE mem=952k time=0ms\n/1006/souvenir11.in:RE mem=952k time=0ms\n/1006/souvenir12.in:RE mem=952k time=0ms\n/1006/souvenir13.in:RE mem=952k time=0ms\n/1006/souvenir14.in:RE mem=952k time=0ms\n/1006/souvenir15.in:RE mem=952k time=0ms\n/1006/souvenir16.in:RE mem=952k time=0ms\n/1006/souvenir17.in:RE mem=952k time=0ms\n/1006/souvenir18.in:RE mem=952k time=0ms\n/1006/souvenir19.in:RE mem=952k time=0ms\n/1006/souvenir2.in:RE mem=952k time=0ms\n/1006/souvenir20.in:RE mem=952k time=0ms\n/1006/souvenir3.in:RE mem=952k time=0ms\n/1006/souvenir4.in:RE mem=952k time=0ms\n/1006/souvenir5.in:RE mem=952k time=0ms\n/1006/souvenir6.in:RE mem=952k time=0ms\n/1006/souvenir7.in:RE mem=952k time=0ms\n/1006/souvenir8.in:RE mem=952k time=0ms\n/1006/souvenir9.in:RE mem=952k time=0ms\n\n'),(1009,'time_space_table:\n/1000/sample.in:AC mem=4120k time=6ms\n\n'),(1085,'Hello World!\n'),(1086,''),(1087,'Hello World!'),(1089,'Hello World!\n'),(1090,'Execution error, USE_DOCKER:0 !\nYou need to install compiler VM or runtime for your language.'),(1091,'Hello World!\n'),(1092,'Execution error, USE_DOCKER:0 !\nYou need to install compiler VM or runtime for your language.'),(1093,'Hello World\n'),(1094,'Execution error, USE_DOCKER:0 !\nYou need to install compiler VM or runtime for your language.'),(1095,'time_space_table:\n/1000/sample.in:AC mem=9984k time=139ms\n\n'),(1047,'time_space_table:\n/1007/02.in:AC mem=2020k time=98ms\n/1007/03.in:AC mem=2020k time=102ms\n/1007/04.in:AC mem=2020k time=109ms\n/1007/05.in:AC mem=2020k time=110ms\n/1007/06.in:AC mem=2020k time=109ms\n/1007/07.in:AC mem=2020k time=105ms\n/1007/08.in:AC mem=2020k time=109ms\n/1007/09.in:AC mem=2020k time=136ms\n/1007/10.in:AC mem=2020k time=113ms\n/1007/11.in:AC mem=2020k time=128ms\n/1007/12.in:AC mem=2020k time=109ms\n/1007/13.in:AC mem=2020k time=105ms\n/1007/14.in:AC mem=2020k time=98ms\n/1007/15.in:AC mem=2020k time=106ms\n/1007/16.in:AC mem=2020k time=102ms\n/1007/17.in:AC mem=2020k time=99ms\n/1007/18.in:AC mem=2020k time=102ms\n/1007/19.in:AC mem=2020k time=98ms\n/1007/20.in:AC mem=2020k time=109ms\n/1007/21.in:AC mem=2020k time=106ms\n\n'),(1048,'OK'),(1057,'Hello World!\n'),(1058,'3\n'),(1059,'4655\n'),(1060,'time_space_table:\n/1007/02.in:AC mem=2020k time=135ms\n/1007/03.in:AC mem=2020k time=113ms\n/1007/04.in:AC mem=2020k time=150ms\n/1007/05.in:AC mem=2020k time=169ms\n/1007/06.in:AC mem=2020k time=161ms\n/1007/07.in:AC mem=2020k time=169ms\n/1007/08.in:AC mem=2020k time=164ms\n/1007/09.in:AC mem=2020k time=161ms\n/1007/10.in:AC mem=2020k time=165ms\n/1007/11.in:AC mem=2020k time=165ms\n/1007/12.in:AC mem=2020k time=136ms\n/1007/13.in:AC mem=2020k time=120ms\n/1007/14.in:AC mem=2020k time=117ms\n/1007/15.in:AC mem=2020k time=120ms\n/1007/16.in:AC mem=2020k time=150ms\n/1007/17.in:AC mem=2020k time=136ms\n/1007/18.in:AC mem=2020k time=143ms\n/1007/19.in:AC mem=2020k time=150ms\n/1007/20.in:AC mem=2020k time=180ms\n/1007/21.in:AC mem=2020k time=150ms\n\n'),(1049,'time_space_table:\n/1007/02.in:AC mem=2020k time=113ms\n/1007/03.in:AC mem=2020k time=117ms\n/1007/04.in:WA mem=2020k time=113ms\n/1007/05.in:AC mem=2020k time=117ms\n/1007/06.in:AC mem=2020k time=121ms\n/1007/07.in:AC mem=2020k time=113ms\n/1007/08.in:AC mem=2020k time=109ms\n/1007/09.in:AC mem=2020k time=121ms\n/1007/10.in:AC mem=2020k time=105ms\n/1007/11.in:AC mem=2020k time=99ms\n/1007/12.in:AC mem=2020k time=105ms\n/1007/13.in:AC mem=2020k time=102ms\n/1007/14.in:AC mem=2020k time=99ms\n/1007/15.in:AC mem=2020k time=102ms\n/1007/16.in:AC mem=2020k time=106ms\n/1007/17.in:WA mem=2020k time=95ms\n/1007/18.in:AC mem=2020k time=95ms\n/1007/19.in:AC mem=2020k time=99ms\n/1007/20.in:AC mem=2020k time=102ms\n/1007/21.in:AC mem=2020k time=105ms\n\n'),(1050,'time_space_table:\n/1007/02.in:WA mem=2020k time=95ms\n/1007/03.in:WA mem=2020k time=95ms\n/1007/04.in:WA mem=2020k time=95ms\n/1007/05.in:WA mem=2020k time=102ms\n/1007/06.in:WA mem=2020k time=95ms\n/1007/07.in:WA mem=2020k time=91ms\n/1007/08.in:WA mem=2020k time=91ms\n/1007/09.in:WA mem=2020k time=94ms\n/1007/10.in:WA mem=2020k time=95ms\n/1007/11.in:WA mem=2020k time=95ms\n/1007/12.in:WA mem=2020k time=99ms\n/1007/13.in:WA mem=2020k time=106ms\n/1007/14.in:WA mem=2020k time=106ms\n/1007/15.in:WA mem=2020k time=106ms\n/1007/16.in:WA mem=2020k time=110ms\n/1007/17.in:WA mem=2020k time=109ms\n/1007/18.in:WA mem=2020k time=113ms\n/1007/19.in:WA mem=2020k time=110ms\n/1007/20.in:WA mem=2020k time=102ms\n/1007/21.in:WA mem=2020k time=117ms\n\n'),(1051,'time_space_table:\n/1008/02.in:AC mem=2020k time=0ms\n/1008/03.in:AC mem=2020k time=0ms\n/1008/04.in:AC mem=2020k time=0ms\n/1008/05.in:AC mem=2020k time=0ms\n/1008/06.in:AC mem=2020k time=0ms\n/1008/07.in:AC mem=2020k time=0ms\n/1008/08.in:AC mem=2020k time=0ms\n/1008/09.in:AC mem=2020k time=0ms\n/1008/10.in:AC mem=2020k time=0ms\n/1008/11.in:AC mem=2020k time=0ms\n/1008/12.in:AC mem=2020k time=0ms\n/1008/13.in:AC mem=2020k time=0ms\n/1008/14.in:AC mem=2020k time=0ms\n/1008/15.in:AC mem=2020k time=0ms\n/1008/16.in:AC mem=2020k time=0ms\n/1008/17.in:AC mem=2020k time=0ms\n/1008/18.in:AC mem=2020k time=0ms\n/1008/19.in:AC mem=2020k time=0ms\n/1008/20.in:AC mem=2020k time=0ms\n/1008/21.in:AC mem=2020k time=0ms\n\n'),(1052,'time_space_table:\n/1009/02.in:AC mem=2020k time=0ms\n/1009/03.in:AC mem=2020k time=0ms\n/1009/04.in:AC mem=2020k time=0ms\n/1009/05.in:AC mem=2020k time=0ms\n/1009/06.in:AC mem=2020k time=0ms\n/1009/07.in:AC mem=2020k time=0ms\n/1009/08.in:AC mem=2020k time=0ms\n/1009/09.in:AC mem=2020k time=0ms\n/1009/10.in:AC mem=2020k time=3ms\n/1009/11.in:AC mem=2020k time=11ms\n/1009/12.in:AC mem=2020k time=25ms\n/1009/13.in:AC mem=2020k time=11ms\n/1009/14.in:AC mem=2020k time=22ms\n/1009/15.in:AC mem=2020k time=22ms\n/1009/16.in:AC mem=2020k time=445ms\n/1009/17.in:AC mem=2020k time=83ms\n/1009/18.in:AC mem=2020k time=471ms\n/1009/19.in:AC mem=2020k time=463ms\n/1009/20.in:AC mem=2020k time=456ms\n/1009/21.in:AC mem=2020k time=460ms\n/1009/sample.in:AC mem=2020k time=0ms\n\n'),(1053,'time_space_table:\n/1010/03.in:AC mem=5084k time=18ms\n/1010/04.in:AC mem=5084k time=18ms\n/1010/05.in:AC mem=5084k time=17ms\n/1010/06.in:AC mem=27920k time=235ms\n/1010/07.in:AC mem=27920k time=220ms\n/1010/08.in:AC mem=27920k time=205ms\n/1010/09.in:AC mem=27920k time=202ms\n/1010/10.in:AC mem=27920k time=198ms\n/1010/11.in:AC mem=27920k time=231ms\n/1010/12.in:AC mem=27920k time=224ms\n\n'),(1054,'time_space_table:\n/1011/03.in:AC mem=2036k time=0ms\n/1011/04.in:AC mem=2036k time=0ms\n/1011/05.in:AC mem=2036k time=0ms\n/1011/06.in:AC mem=2036k time=0ms\n/1011/07.in:AC mem=2036k time=0ms\n/1011/08.in:AC mem=2036k time=0ms\n/1011/09.in:AC mem=2036k time=0ms\n/1011/10.in:AC mem=2036k time=0ms\n/1011/11.in:AC mem=2036k time=0ms\n/1011/12.in:AC mem=2036k time=0ms\n/1011/13.in:AC mem=2036k time=0ms\n/1011/14.in:AC mem=2036k time=0ms\n/1011/15.in:AC mem=2036k time=0ms\n/1011/16.in:AC mem=2036k time=0ms\n/1011/17.in:AC mem=2036k time=0ms\n/1011/18.in:AC mem=2036k time=0ms\n/1011/19.in:AC mem=2036k time=0ms\n/1011/20.in:AC mem=2036k time=0ms\n/1011/21.in:AC mem=2036k time=0ms\n/1011/22.in:AC mem=2036k time=0ms\n\n'),(1055,'time_space_table:\n/1011/03.in:AC mem=2036k time=0ms\n/1011/04.in:AC mem=2036k time=0ms\n/1011/05.in:AC mem=2036k time=0ms\n/1011/06.in:AC mem=2036k time=0ms\n/1011/07.in:AC mem=2036k time=0ms\n/1011/08.in:AC mem=2036k time=0ms\n/1011/09.in:AC mem=2036k time=0ms\n/1011/10.in:AC mem=2036k time=0ms\n/1011/11.in:AC mem=2036k time=0ms\n/1011/12.in:AC mem=2036k time=0ms\n/1011/13.in:AC mem=2036k time=0ms\n/1011/14.in:AC mem=2036k time=0ms\n/1011/15.in:AC mem=2036k time=0ms\n/1011/16.in:AC mem=2036k time=0ms\n/1011/17.in:AC mem=2036k time=0ms\n/1011/18.in:AC mem=2036k time=0ms\n/1011/19.in:AC mem=2036k time=0ms\n/1011/20.in:AC mem=2036k time=0ms\n/1011/21.in:AC mem=2036k time=0ms\n/1011/22.in:AC mem=2036k time=0ms\n\n'),(1061,'========[xor1.out]=========\nExpected						      |	Yours\n4294470503						      |	4294967295\n\n==============================\n========[xor2.out]=========\nExpected						      |	Yours\n4292954425						      |	4294967295\n\n==============================\n========[xor3.out]=========\nExpected						      |	Yours\n4294963361						      |	4294967295\n\n==============================\n========[xor4.out]=========\nExpected						      |	Yours\n4294962215						      |	4294967295\n\n==============================\ntime_space_table:\n/1015/xor1.in:WA mem=2016k time=0ms\n/1015/xor10.in:AC mem=2016k time=0ms\n/1015/xor2.in:WA mem=2016k time=0ms\n/1015/xor3.in:WA mem=2016k time=0ms\n/1015/xor4.in:WA mem=2016k time=0ms\n/1015/xor5.in:AC mem=2016k time=0ms\n/1015/xor6.in:AC mem=2016k time=0ms\n/1015/xor7.in:AC mem=2016k time=0ms\n/1015/xor8.in:AC mem=2016k time=0ms\n/1015/xor9.in:AC mem=2016k time=0ms\n\n'),(1062,'time_space_table:\n/1015/xor1.in:AC mem=158276k time=55ms\n/1015/xor10.in:AC mem=161972k time=618ms\n/1015/xor2.in:AC mem=161972k time=54ms\n/1015/xor3.in:AC mem=161972k time=58ms\n/1015/xor4.in:AC mem=161972k time=58ms\n/1015/xor5.in:AC mem=161972k time=565ms\n/1015/xor6.in:AC mem=161972k time=555ms\n/1015/xor7.in:AC mem=161972k time=580ms\n/1015/xor8.in:AC mem=161972k time=555ms\n/1015/xor9.in:AC mem=161972k time=543ms\n\n'),(1063,'2\n1\n1\n1\n0\n'),(1064,'0\n1\n1\n1\n0\n'),(1065,'time_space_table:\n/1014/map1.in:AC mem=6956k time=997ms\n/1014/map10.in:AC mem=6956k time=1217ms\n/1014/map11.in:AC mem=6956k time=956ms\n/1014/map2.in:AC mem=6956k time=1000ms\n/1014/map3.in:AC mem=6956k time=1036ms\n/1014/map4.in:AC mem=6956k time=1004ms\n/1014/map5.in:AC mem=6956k time=1269ms\n/1014/map6.in:AC mem=6956k time=1339ms\n/1014/map7.in:AC mem=6956k time=1283ms\n/1014/map8.in:AC mem=6956k time=1239ms\n/1014/map9.in:AC mem=6956k time=1298ms\n\n'),(1068,'0\n1\n1\n1\n0\n'),(1070,'0\n1\n1\n1\n0\n'),(1071,'time_space_table:\n/1014/map1.in:AC mem=6176k time=989ms\n/1014/map10.in:AC mem=6308k time=1302ms\n/1014/map11.in:AC mem=6308k time=1081ms\n/1014/map2.in:AC mem=6308k time=1151ms\n/1014/map3.in:AC mem=6308k time=1048ms\n/1014/map4.in:AC mem=6308k time=1044ms\n/1014/map5.in:AC mem=6308k time=1324ms\n/1014/map6.in:AC mem=6308k time=1317ms\n/1014/map7.in:AC mem=6308k time=1386ms\n/1014/map8.in:AC mem=6308k time=1394ms\n/1014/map9.in:AC mem=6308k time=1401ms\n\n'),(1056,'time_space_table:\n/1012/03.in:AC mem=2024k time=0ms\n/1012/04.in:AC mem=2024k time=0ms\n/1012/05.in:AC mem=2024k time=0ms\n/1012/06.in:AC mem=2024k time=0ms\n/1012/07.in:AC mem=2024k time=0ms\n/1012/08.in:AC mem=2024k time=0ms\n/1012/09.in:AC mem=2024k time=0ms\n/1012/10.in:AC mem=2024k time=0ms\n/1012/11.in:AC mem=2024k time=0ms\n/1012/12.in:AC mem=2024k time=0ms\n/1012/13.in:AC mem=2024k time=0ms\n/1012/14.in:AC mem=2024k time=0ms\n/1012/15.in:AC mem=2024k time=0ms\n/1012/16.in:AC mem=2024k time=0ms\n/1012/17.in:AC mem=2024k time=0ms\n/1012/18.in:AC mem=2024k time=0ms\n/1012/19.in:AC mem=2024k time=0ms\n/1012/20.in:AC mem=2024k time=0ms\n/1012/21.in:AC mem=2024k time=0ms\n/1012/22.in:AC mem=2024k time=0ms\n\n'),(1072,'0\n1\n1\n1\n0\n'),(1073,'time_space_table:\n/1014/map1.in:AC mem=5964k time=1025ms\n/1014/map10.in:AC mem=6360k time=1290ms\n/1014/map11.in:AC mem=6360k time=1045ms\n/1014/map2.in:AC mem=6360k time=963ms\n/1014/map3.in:AC mem=6360k time=960ms\n/1014/map4.in:AC mem=6360k time=985ms\n/1014/map5.in:AC mem=6360k time=1203ms\n/1014/map6.in:AC mem=6360k time=1206ms\n/1014/map7.in:AC mem=6360k time=1188ms\n/1014/map8.in:AC mem=6360k time=1224ms\n/1014/map9.in:AC mem=6360k time=1346ms\n\n'),(1074,'time_space_table:\n/1000/sample.in:AC mem=2016k time=0ms\n\n'),(1075,'/1006/souvenir13.in:Segmentation fault\n/1006/souvenir14.in:Segmentation fault\n/1006/souvenir15.in:Segmentation fault\n/1006/souvenir16.in:Segmentation fault\n/1006/souvenir17.in:Segmentation fault\n/1006/souvenir18.in:Segmentation fault\n/1006/souvenir19.in:Segmentation fault\n/1006/souvenir20.in:Segmentation fault\n/1006/souvenir8.in:Segmentation fault\n/1006/souvenir9.in:Segmentation fault\n----time_space_table:----\n/1006/souvenir1.in:AC mem=5104k time=0ms\n/1006/souvenir10.in:AC mem=5104k time=0ms\n/1006/souvenir11.in:AC mem=5104k time=0ms\n/1006/souvenir12.in:AC mem=5104k time=0ms\n/1006/souvenir13.in:RE mem=5104k time=0ms\n/1006/souvenir14.in:RE mem=5104k time=3ms\n/1006/souvenir15.in:RE mem=5104k time=0ms\n/1006/souvenir16.in:RE mem=5104k time=3ms\n/1006/souvenir17.in:RE mem=5104k time=0ms\n/1006/souvenir18.in:RE mem=5104k time=3ms\n/1006/souvenir19.in:RE mem=5104k time=0ms\n/1006/souvenir2.in:AC mem=5104k time=0ms\n/1006/souvenir20.in:RE mem=5104k time=0ms\n/1006/souvenir3.in:AC mem=5104k time=0ms\n/1006/souvenir4.in:AC mem=5104k time=0ms\n/1006/souvenir5.in:AC mem=5104k time=0ms\n/1006/souvenir6.in:AC mem=5104k time=0ms\n/1006/souvenir7.in:AC mem=5104k time=0ms\n/1006/souvenir8.in:RE mem=5104k time=0ms\n/1006/souvenir9.in:RE mem=5104k time=0ms\n\n'),(1076,'time_space_table:\n/1006/souvenir1.in:AC mem=2100k time=0ms\n/1006/souvenir10.in:AC mem=2100k time=0ms\n/1006/souvenir11.in:AC mem=2100k time=0ms\n/1006/souvenir12.in:AC mem=2100k time=0ms\n/1006/souvenir13.in:AC mem=2100k time=7ms\n/1006/souvenir14.in:AC mem=2100k time=11ms\n/1006/souvenir15.in:AC mem=2100k time=22ms\n/1006/souvenir16.in:AC mem=2100k time=29ms\n/1006/souvenir17.in:AC mem=2100k time=44ms\n/1006/souvenir18.in:AC mem=2100k time=40ms\n/1006/souvenir19.in:AC mem=2100k time=36ms\n/1006/souvenir2.in:AC mem=2100k time=0ms\n/1006/souvenir20.in:AC mem=2100k time=47ms\n/1006/souvenir3.in:AC mem=2100k time=0ms\n/1006/souvenir4.in:AC mem=2100k time=0ms\n/1006/souvenir5.in:AC mem=2100k time=0ms\n/1006/souvenir6.in:AC mem=2100k time=0ms\n/1006/souvenir7.in:AC mem=2100k time=0ms\n/1006/souvenir8.in:AC mem=2100k time=0ms\n/1006/souvenir9.in:AC mem=2100k time=0ms\n\n'),(1078,'time_space_table:\n/1006/souvenir1.in:AC mem=2100k time=0ms\n/1006/souvenir10.in:AC mem=2100k time=0ms\n/1006/souvenir11.in:AC mem=2100k time=0ms\n/1006/souvenir12.in:AC mem=2100k time=0ms\n/1006/souvenir13.in:AC mem=2100k time=7ms\n/1006/souvenir14.in:AC mem=2100k time=11ms\n/1006/souvenir15.in:AC mem=2100k time=33ms\n/1006/souvenir16.in:AC mem=2100k time=39ms\n/1006/souvenir17.in:AC mem=2100k time=51ms\n/1006/souvenir18.in:AC mem=2100k time=47ms\n/1006/souvenir19.in:AC mem=2100k time=40ms\n/1006/souvenir2.in:AC mem=2100k time=0ms\n/1006/souvenir20.in:AC mem=2100k time=36ms\n/1006/souvenir3.in:AC mem=2100k time=0ms\n/1006/souvenir4.in:AC mem=2100k time=0ms\n/1006/souvenir5.in:AC mem=2100k time=0ms\n/1006/souvenir6.in:AC mem=2100k time=0ms\n/1006/souvenir7.in:AC mem=2100k time=0ms\n/1006/souvenir8.in:AC mem=2100k time=0ms\n/1006/souvenir9.in:AC mem=2100k time=0ms\n\n'),(1079,'time_space_table:\n/1000/sample.in:AC mem=2172k time=0ms\n\n'),(1080,'0\n1\n1.414213562373095048801688724209698078569671875376948073176679737990732478462107038850387534327641572735013846230912297024\n1.732050807568877293527446341505872366942805253810380628055806979451933016908800037081146186757248575675626141415406703029\n2\n'),(1081,'time_space_table:\n/1013/sqrt1.in:AC mem=2052k time=246ms\n/1013/sqrt10.in:AC mem=2052k time=250ms\n/1013/sqrt2.in:AC mem=2052k time=250ms\n/1013/sqrt3.in:AC mem=2052k time=264ms\n/1013/sqrt4.in:AC mem=2052k time=245ms\n/1013/sqrt5.in:AC mem=2052k time=256ms\n/1013/sqrt6.in:AC mem=2052k time=249ms\n/1013/sqrt7.in:AC mem=2052k time=250ms\n/1013/sqrt8.in:AC mem=2052k time=276ms\n/1013/sqrt9.in:AC mem=2052k time=249ms\n\n'),(1082,'ok\nhome \nok\n/home/\nok\n*file \nok\nok\nerr\n/home/\nok\nc++ \nok\n/root/c++/\nerr\nEMPTY\nok\nEMPTY\nerr\nerr\nerr\nerr\nEMPTY\nerr\n'),(1083,'========[sample[0].out]=========\nExpected						      |	Yours\nok								ok\nhome							      |	home \nok								ok\n/home/								/home/\nok								ok\n*file							      |	*file \nok								ok\nok								ok\n							      >	err\n							      >	/home/\nok								ok\n/							      |	c++ \nok							      <\nc++							      <\nok								ok\n/root/c++/							/root/c++/\nok							      <\nhome root						      <\nok							      <\nhome							      <\nerr								err\n							      >	EMPTY\nok								ok\nok							      |	EMPTY\n							      >	err\n							      >	err\n							      >	err\nerr								err\nEMPTY								EMPTY\nok							      \\	err\n\n==============================\ntime_space_table:\n/1016/sample[0].in:WA mem=2184k time=0ms\n\n'),(1084,'time_space_table:\n/1016/sample[0].in:AC mem=2184k time=0ms\n\n');
/*!40000 ALTER TABLE `runtimeinfo` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `share_code`
--

DROP TABLE IF EXISTS `share_code`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `share_code` (
  `share_id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` varchar(48) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `title` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `share_code` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci,
  `language` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `share_time` datetime DEFAULT NULL,
  PRIMARY KEY (`share_id`)
) ENGINE=MyISAM AUTO_INCREMENT=1001 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `share_code`
--

LOCK TABLES `share_code` WRITE;
/*!40000 ALTER TABLE `share_code` DISABLE KEYS */;
INSERT INTO `share_code` VALUES (1000,'admin','TEST_CODE_SHARE','#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    cout << a + b << endl;\n    return 0;\n}','c_cpp','2022-10-12 21:22:47');
/*!40000 ALTER TABLE `share_code` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sim`
--

DROP TABLE IF EXISTS `sim`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sim` (
  `s_id` int(11) NOT NULL,
  `sim_s_id` int(11) DEFAULT NULL,
  `sim` int(11) DEFAULT NULL,
  PRIMARY KEY (`s_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sim`
--

LOCK TABLES `sim` WRITE;
/*!40000 ALTER TABLE `sim` DISABLE KEYS */;
/*!40000 ALTER TABLE `sim` ENABLE KEYS */;
UNLOCK TABLES;
/*!50003 SET @saved_cs_client      = @@character_set_client */ ;
/*!50003 SET @saved_cs_results     = @@character_set_results */ ;
/*!50003 SET @saved_col_connection = @@collation_connection */ ;
/*!50003 SET character_set_client  = utf8mb4 */ ;
/*!50003 SET character_set_results = utf8mb4 */ ;
/*!50003 SET collation_connection  = utf8mb4_general_ci */ ;
/*!50003 SET @saved_sql_mode       = @@sql_mode */ ;
/*!50003 SET sql_mode              = 'ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION' */ ;
DELIMITER ;;
/*!50003 CREATE*/ /*!50017 DEFINER=`debian-sys-maint`@`localhost`*/ /*!50003 TRIGGER `simfilter` BEFORE INSERT ON `sim` FOR EACH ROW begin
 declare new_user_id varchar(64);
 declare old_user_id varchar(64);
 select user_id from solution where solution_id=new.s_id into new_user_id;
 select user_id from solution where solution_id=new.sim_s_id into old_user_id;
 if old_user_id=new_user_id then
	set new.s_id=0;
 end if;
 
end */;;
DELIMITER ;
/*!50003 SET sql_mode              = @saved_sql_mode */ ;
/*!50003 SET character_set_client  = @saved_cs_client */ ;
/*!50003 SET character_set_results = @saved_cs_results */ ;
/*!50003 SET collation_connection  = @saved_col_connection */ ;

--
-- Table structure for table `solution`
--

DROP TABLE IF EXISTS `solution`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `solution` (
  `solution_id` int(11) NOT NULL AUTO_INCREMENT,
  `problem_id` int(11) NOT NULL DEFAULT '0',
  `user_id` char(48) NOT NULL,
  `nick` char(20) NOT NULL DEFAULT '',
  `time` int(11) NOT NULL DEFAULT '0',
  `memory` int(11) NOT NULL DEFAULT '0',
  `in_date` datetime NOT NULL DEFAULT '2016-05-13 19:24:00',
  `result` smallint(6) NOT NULL DEFAULT '0',
  `language` int(10) unsigned NOT NULL DEFAULT '0',
  `ip` char(46) NOT NULL,
  `contest_id` int(11) DEFAULT '0',
  `valid` tinyint(4) NOT NULL DEFAULT '1',
  `num` tinyint(4) NOT NULL DEFAULT '-1',
  `code_length` int(11) NOT NULL DEFAULT '0',
  `judgetime` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `pass_rate` decimal(3,2) unsigned NOT NULL DEFAULT '0.00',
  `lint_error` int(10) unsigned NOT NULL DEFAULT '0',
  `judger` char(16) NOT NULL DEFAULT 'LOCAL',
  PRIMARY KEY (`solution_id`),
  KEY `uid` (`user_id`),
  KEY `pid` (`problem_id`),
  KEY `res` (`result`),
  KEY `cid` (`contest_id`)
) ENGINE=MyISAM AUTO_INCREMENT=1096 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=FIXED;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `solution`
--

LOCK TABLES `solution` WRITE;
/*!40000 ALTER TABLE `solution` DISABLE KEYS */;
INSERT INTO `solution` VALUES (1001,1000,'yangzhibo123','yzb',29,33740,'2022-05-06 08:35:17',4,6,'180.111.215.58',0,1,-1,36,'2022-08-31 07:48:23',1.00,0,'admin'),(1002,1000,'yangzhibo123','yzb',7,4124,'2022-05-06 08:39:00',4,7,'180.111.215.58',0,1,-1,12,'2022-08-31 07:48:24',1.00,0,'admin'),(1003,1000,'DerekXu','xyy',0,2016,'2022-05-06 08:39:31',4,1,'180.111.51.240',0,1,-1,110,'2022-08-31 07:48:27',1.00,0,'admin'),(1004,1000,'yangzhibo123','yzb',29,33656,'2022-05-06 08:39:33',4,6,'180.111.215.58',0,1,-1,36,'2022-08-31 07:48:28',1.00,0,'admin'),(1005,1000,'yangzhibo123','yzb',7,4128,'2022-05-06 08:39:46',4,7,'180.111.215.58',0,1,-1,12,'2022-08-31 07:48:28',1.00,0,'admin'),(1006,1000,'DerekXu','xyy',32,33744,'2022-05-06 08:40:28',4,6,'180.111.51.240',0,1,-1,36,'2022-08-31 07:48:29',1.00,0,'admin'),(1007,1000,'DerekXu','xyy',7,4120,'2022-05-06 08:43:11',4,7,'180.111.51.240',0,1,-1,35,'2022-08-31 07:48:29',1.00,0,'admin'),(1008,1000,'DerekXu','xyy',7,4116,'2022-05-06 08:45:33',6,7,'180.111.51.240',0,1,-1,60,'2022-08-31 07:48:29',0.00,0,'admin'),(1009,1000,'admin','xcx',6,4120,'2022-05-06 08:47:16',4,7,'49.77.72.76',0,1,-1,31,'2022-08-31 07:48:30',1.00,0,'admin'),(1010,1001,'admin','xcx',0,1116,'2022-05-06 08:51:54',4,1,'127.0.0.1',0,1,-1,115,'2022-08-20 10:43:43',1.00,0,'admin'),(1011,1001,'admin','xcx',36,33656,'2022-05-06 08:51:54',4,6,'127.0.0.1',0,1,-1,60,'2022-08-20 10:43:44',1.00,0,'admin'),(1012,1002,'admin','xcx',2050,7096,'2022-05-06 08:51:54',4,1,'127.0.0.1',0,1,-1,1714,'2022-05-06 12:52:19',1.00,0,'admin'),(1013,1000,'admin','xcx',25,33656,'2022-05-06 08:53:06',4,6,'49.77.72.76',0,1,-1,36,'2022-08-31 07:48:30',1.00,0,'admin'),(1014,1001,'DerekXu','xyy',32,33656,'2022-05-06 08:57:42',10,6,'180.111.51.240',0,1,-1,66,'2022-08-20 10:43:44',0.00,0,'admin'),(1015,1001,'DerekXu','xyy',0,2020,'2022-05-06 08:58:57',4,1,'180.111.51.240',0,1,-1,142,'2022-08-20 10:43:47',1.00,0,'admin'),(1016,1002,'DerekXu','xyy',727,3464,'2022-05-06 09:00:05',4,1,'180.111.51.240',0,1,-1,1348,'2022-05-11 10:50:15',1.00,0,'admin'),(1017,1001,'yangzhibo123','yzb',0,2020,'2022-05-11 07:43:21',4,1,'180.111.215.58',0,1,-1,108,'2022-08-20 10:43:49',1.00,0,'admin'),(1018,1003,'admin','xcx',839,51004,'2022-05-11 07:48:57',4,1,'49.77.72.76',0,1,-1,2141,'2022-08-19 12:53:32',1.00,0,'admin'),(1019,1003,'yangzhibo123','yzb',2783,3660,'2022-05-11 07:57:51',10,1,'180.111.215.58',0,1,-1,2482,'2022-05-11 11:58:14',0.00,0,'admin'),(1020,1003,'yangzhibo123','yzb',2774,3636,'2022-05-11 08:00:00',10,1,'180.111.215.58',0,1,-1,2482,'2022-05-11 12:00:21',0.00,0,'admin'),(1021,1003,'DerekXu','xyy',2768,3168,'2022-05-11 08:02:27',10,1,'180.109.235.179',0,1,-1,2382,'2022-05-11 12:02:48',0.00,0,'admin'),(1022,1003,'yangzhibo123','yzb',2775,3632,'2022-05-11 08:05:18',10,1,'180.111.215.58',0,1,-1,2482,'2022-05-11 12:05:39',0.00,0,'admin'),(1023,1003,'DerekXu','xyy',2767,3164,'2022-05-11 08:09:56',10,1,'180.109.235.179',0,1,-1,2381,'2022-05-11 12:10:20',0.00,0,'admin'),(1024,1003,'adminxcx','xcx',0,0,'2022-05-11 08:16:34',11,1,'49.77.72.76',0,1,-1,2420,'2022-05-11 12:16:38',0.00,0,'admin'),(1025,1003,'adminxcx','xcx',0,0,'2022-05-11 08:17:46',11,1,'49.77.72.76',0,1,-1,2422,'2022-05-11 12:17:50',0.00,0,'admin'),(1026,1003,'yangzhibo123','yzb',660,5896,'2022-05-11 08:18:32',10,1,'180.111.215.58',0,1,-1,2479,'2022-05-11 12:18:42',0.50,0,'admin'),(1027,1003,'adminxcx','xcx',2764,4936,'2022-05-11 08:18:49',10,1,'49.77.72.76',0,1,-1,2424,'2022-05-11 12:19:12',0.00,0,'admin'),(1028,1003,'yangzhibo123','yzb',686,5940,'2022-05-11 08:20:09',10,1,'180.111.215.58',0,1,-1,2479,'2022-05-11 12:20:21',0.50,0,'admin'),(1029,1003,'adminxcx','xcx',2766,4944,'2022-05-11 08:22:04',10,1,'49.77.72.76',0,1,-1,2424,'2022-05-11 12:22:29',0.00,0,'admin'),(1030,1003,'yangzhibo123','yzb',67,12984,'2022-05-11 08:24:17',9,6,'180.111.215.58',0,1,-1,50,'2022-05-11 12:24:35',0.00,0,'admin'),(1031,1003,'adminxcx','xcx',866,27940,'2022-05-11 08:25:23',4,1,'49.77.72.76',0,1,-1,1985,'2022-05-11 12:25:41',1.00,0,'admin'),(1032,1000,'lihaoze','lhz',0,2016,'2022-05-11 08:26:04',4,1,'112.20.78.176',0,1,-1,105,'2022-08-31 07:48:32',1.00,0,'admin'),(1033,1003,'yangzhibo123','yzb',643,20628,'2022-05-11 08:26:37',10,1,'180.111.215.58',0,1,-1,2232,'2022-05-11 12:26:59',0.50,0,'admin'),(1034,1003,'yangzhibo123','yzb',667,20576,'2022-05-11 08:29:26',10,1,'180.111.215.58',0,1,-1,2282,'2022-05-11 12:30:25',0.50,0,'admin'),(1035,1003,'yangzhibo123','yzb',1021,38104,'2022-05-11 08:36:55',4,1,'180.111.215.58',0,1,-1,2279,'2022-05-11 12:37:18',1.00,0,'admin'),(1036,1003,'mhb2010','mhb',217,7956,'2022-05-11 08:42:23',10,1,'180.110.197.159',0,1,-1,1897,'2022-05-11 12:42:35',0.00,0,'admin'),(1037,1003,'mhb2010','mhb',223,7988,'2022-05-11 08:52:44',10,1,'180.110.197.159',0,1,-1,1895,'2022-05-11 12:53:01',0.00,0,'admin'),(1038,1003,'mhb2010','mhb',540,54496,'2022-05-11 08:55:46',9,1,'180.110.197.159',0,1,-1,1897,'2022-05-11 12:56:05',0.00,0,'admin'),(1039,1004,'admin','xcx',502,1864,'2022-05-11 09:10:45',4,1,'49.77.72.76',0,1,-1,667,'2022-05-11 13:11:11',1.00,0,'admin'),(1040,1004,'DerekXu','xyy',559,2628,'2022-05-13 20:02:35',4,1,'180.109.90.155',0,1,-1,670,'2022-05-13 12:12:01',1.00,0,'admin'),(1041,1005,'admin','xcx',0,0,'2022-05-18 21:52:28',4,0,'180.109.204.243',0,1,-1,10333,'2022-05-18 13:52:29',0.00,0,'admin'),(1042,1005,'admin','xcx',1247,6248,'2022-05-18 21:53:02',4,1,'180.109.204.243',0,1,-1,10333,'2022-05-25 13:44:35',1.00,0,'admin'),(1043,1006,'admin','xcx',0,952,'2022-05-25 21:25:41',10,1,'180.109.204.243',0,1,-1,628,'2022-08-27 11:47:36',0.00,0,'admin'),(1044,0,'admin','xcx',1,1032,'2022-05-25 21:28:36',13,1,'180.109.204.243',0,1,-1,502,'2022-05-25 13:28:37',0.00,0,'admin'),(1045,0,'admin','xcx',3,1032,'2022-05-25 21:30:58',13,1,'180.109.204.243',0,1,-1,502,'2022-05-25 13:30:59',0.00,0,'admin'),(1046,1006,'admin','xcx',0,952,'2022-05-25 21:33:44',10,1,'180.109.204.243',0,1,-1,502,'2022-08-27 11:47:31',0.00,0,'admin'),(1047,1007,'admin','xcx',136,2020,'2022-08-21 18:15:19',4,1,'180.109.29.36',0,1,-1,490,'2022-08-21 10:15:36',1.00,0,'admin'),(1048,1007,'xcx0902','xcx',109,2020,'2022-08-21 18:16:42',4,1,'180.109.29.36',0,1,-1,597,'2022-08-21 10:16:58',1.00,0,'admin'),(1049,1007,'xcx0902','xcx',121,2020,'2022-08-21 18:17:08',6,1,'180.109.29.36',0,1,-1,597,'2022-08-21 10:17:25',0.90,0,'admin'),(1050,1007,'xcx0902','xcx',117,2020,'2022-08-21 18:19:02',6,1,'180.109.29.36',0,1,-1,602,'2022-08-21 10:19:18',0.00,0,'admin'),(1051,1008,'admin','xcx',0,2020,'2022-08-21 18:34:26',4,1,'180.109.29.36',0,1,-1,378,'2022-08-21 10:34:28',1.00,0,'admin'),(1052,1009,'admin','xcx',471,2020,'2022-08-21 18:38:20',4,1,'180.109.29.36',0,1,-1,1243,'2022-08-21 10:38:25',1.00,0,'admin'),(1053,1010,'admin','xcx',235,27920,'2022-08-21 18:45:25',4,1,'180.109.29.36',0,1,-1,1348,'2022-08-21 10:45:30',1.00,0,'admin'),(1054,1011,'admin','xcx',0,2036,'2022-08-21 18:54:48',4,1,'180.109.29.36',0,1,-1,1838,'2022-08-21 10:55:36',1.00,0,'admin'),(1055,1011,'admin','xcx',0,2036,'2022-08-21 18:55:07',4,1,'180.109.29.36',0,1,-1,1844,'2022-08-21 10:55:38',1.00,0,'admin'),(1056,1012,'admin','xcx',0,2024,'2022-08-21 19:00:43',4,1,'180.109.29.36',0,1,-1,2949,'2022-08-21 11:01:55',1.00,0,'admin'),(1057,0,'xcx0902','xcx',0,2016,'2022-08-22 16:19:52',13,1,'180.109.29.36',0,1,-1,116,'2022-08-22 08:19:56',0.00,0,'admin'),(1058,0,'xcx0902','xcx',0,2020,'2022-08-22 16:21:10',13,1,'180.109.29.36',0,1,-1,142,'2022-08-22 08:21:13',0.00,0,'admin'),(1059,0,'xcx0902','xcx',0,2020,'2022-08-22 16:22:19',13,1,'180.109.29.36',0,1,-1,142,'2022-08-22 08:22:22',0.00,0,'admin'),(1060,1007,'xcx0902','xcx',180,2020,'2022-08-22 17:20:56',4,1,'180.109.29.36',0,1,-1,598,'2022-08-22 09:21:19',1.00,0,'admin'),(1062,1015,'admin','xcx',618,161972,'2022-08-25 21:00:50',4,1,'180.109.29.36',0,1,-1,1604,'2022-08-25 13:01:28',1.00,0,'admin'),(1063,0,'admin','xcx',0,6956,'2022-08-27 14:29:49',13,1,'49.77.74.68',0,1,-1,2838,'2022-08-27 06:29:52',0.00,0,'admin'),(1064,0,'admin','xcx',0,6956,'2022-08-27 14:45:08',13,1,'49.77.74.68',0,1,-1,2870,'2022-08-27 06:45:11',0.00,0,'admin'),(1065,1014,'admin','xcx',1339,6956,'2022-08-27 14:45:19',4,1,'49.77.74.68',0,1,-1,2870,'2022-08-27 06:46:44',1.00,0,'admin'),(1066,0,'adminxcx','xcx',0,0,'2022-08-27 14:48:33',11,1,'49.77.74.68',0,1,-1,3080,'2022-08-27 06:48:35',0.00,0,'admin'),(1067,0,'adminxcx','xcx',0,0,'2022-08-27 14:49:40',11,1,'49.77.74.68',0,1,-1,3080,'2022-08-27 06:49:42',0.00,0,'admin'),(1068,0,'adminxcx','xcx',0,6176,'2022-08-27 14:50:01',13,1,'49.77.74.68',0,1,-1,3083,'2022-08-27 06:50:03',0.00,0,'admin'),(1069,0,'adminxcx','xcx',0,0,'2022-08-27 14:51:07',11,1,'49.77.74.68',0,1,-1,3080,'2022-08-27 06:51:09',0.00,0,'admin'),(1070,0,'adminxcx','xcx',0,6176,'2022-08-27 14:51:19',13,1,'49.77.74.68',0,1,-1,3083,'2022-08-27 06:51:21',0.00,0,'admin'),(1071,1014,'adminxcx','xcx',1401,6308,'2022-08-27 14:51:49',4,1,'49.77.74.68',0,1,-1,3083,'2022-08-27 06:53:18',1.00,0,'admin'),(1072,0,'adminxcx','xcx',0,5964,'2022-08-27 14:55:39',13,1,'49.77.74.68',0,1,-1,1103,'2022-08-27 06:55:42',0.00,0,'admin'),(1073,1014,'adminxcx','xcx',1346,6360,'2022-08-27 14:55:56',4,1,'49.77.74.68',0,1,-1,1103,'2022-08-27 06:57:20',1.00,0,'admin'),(1074,1000,'admin','xcx',0,2016,'2022-08-27 19:40:01',4,1,'49.77.74.68',0,1,-1,117,'2022-08-31 07:48:35',1.00,0,'admin'),(1075,1006,'adminxcx','xcx',3,5104,'2022-08-27 19:49:40',10,1,'49.77.74.68',0,1,-1,504,'2022-08-27 11:49:40',0.50,0,'admin'),(1076,1006,'adminxcx','xcx',47,2100,'2022-08-27 19:50:25',4,1,'49.77.74.68',0,1,-1,1469,'2022-08-27 11:50:26',1.00,0,'admin'),(1077,1006,'admin','xcx',0,0,'2022-08-27 19:52:58',11,1,'49.77.74.68',0,1,-1,602,'2022-08-27 11:53:00',0.00,0,'admin'),(1078,1006,'admin','xcx',51,2100,'2022-08-27 19:53:11',4,1,'49.77.74.68',0,1,-1,602,'2022-08-27 11:53:14',1.00,0,'admin'),(1079,1000,'yangzd','yzd',0,2172,'2022-08-28 17:30:01',4,1,'114.222.131.88',0,1,-1,963,'2022-08-31 07:48:37',1.00,0,'admin'),(1080,0,'admin','xcx',7,2052,'2022-08-29 15:23:30',13,1,'49.77.74.68',0,1,-1,2065,'2022-08-29 07:23:33',0.00,0,'admin'),(1081,1013,'admin','xcx',276,2052,'2022-08-29 15:23:41',4,1,'49.77.74.68',0,1,-1,2065,'2022-08-29 07:23:46',1.00,0,'admin'),(1082,0,'admin','xcx',0,2184,'2022-08-30 17:36:41',13,1,'49.77.74.68',0,1,-1,4269,'2022-08-30 09:36:45',0.00,0,'admin'),(1083,1016,'admin','xcx',0,2184,'2022-08-30 17:36:54',6,1,'49.77.74.68',0,1,-1,4269,'2022-08-30 09:36:57',0.00,0,'admin'),(1084,1016,'admin','xcx',0,2184,'2022-08-30 18:25:37',4,1,'49.77.74.68',0,1,-1,4363,'2022-08-30 10:26:46',1.00,0,'admin'),(1085,0,'admin','xcx',94,9248,'2022-09-09 20:09:26',13,3,'180.109.90.20',0,1,-1,142,'2022-09-09 12:09:28',0.00,0,'admin'),(1086,0,'admin','xcx',7,4116,'2022-09-09 20:10:19',13,7,'180.109.90.20',0,1,-1,49,'2022-09-09 12:10:19',0.00,0,'admin'),(1087,0,'admin','xcx',6,4124,'2022-09-09 20:10:31',13,7,'180.109.90.20',0,1,-1,61,'2022-09-09 12:10:31',0.00,0,'admin'),(1088,0,'admin','xcx',0,0,'2022-09-09 20:17:56',11,9,'180.109.90.20',0,1,-1,159,'2022-09-09 12:17:57',0.00,0,'admin'),(1089,0,'admin','xcx',14,4740,'2022-09-09 20:18:11',13,9,'180.109.90.20',0,1,-1,165,'2022-09-09 12:18:12',0.00,0,'admin'),(1090,0,'admin','xcx',0,1516,'2022-09-09 20:20:37',13,16,'180.109.90.20',0,1,-1,77,'2022-09-09 12:20:37',0.00,0,'admin'),(1091,0,'admin','xcx',54,9992,'2022-09-09 20:21:24',13,16,'180.109.90.20',0,1,-1,77,'2022-09-09 12:21:25',0.00,0,'admin'),(1092,0,'admin','xcx',0,1524,'2022-09-09 20:22:57',13,17,'180.109.90.20',0,1,-1,111,'2022-09-09 12:22:57',0.00,0,'admin'),(1093,0,'admin','xcx',0,1752,'2022-09-09 20:25:08',13,17,'180.109.90.20',0,1,-1,111,'2022-09-09 12:25:09',0.00,0,'admin'),(1094,0,'admin','xcx',0,0,'2022-09-09 20:27:15',13,18,'180.109.90.20',0,1,-1,158,'2022-09-09 12:27:15',0.00,0,'admin'),(1095,1000,'yhq123','yhq',139,9984,'2022-09-15 10:37:57',4,16,'58.213.232.97',0,1,-1,77,'2022-09-15 02:37:58',1.00,0,'admin');
/*!40000 ALTER TABLE `solution` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `source_code`
--

DROP TABLE IF EXISTS `source_code`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `source_code` (
  `solution_id` int(11) NOT NULL,
  `source` text NOT NULL,
  PRIMARY KEY (`solution_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `source_code`
--

LOCK TABLES `source_code` WRITE;
/*!40000 ALTER TABLE `source_code` DISABLE KEYS */;
INSERT INTO `source_code` VALUES (1001,'# coding=utf-8\nprint(\"Hello World!\")'),(1002,'Hello World!'),(1003,'#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nsigned main()\r\n{\r\n    cout<<\"Hello World!\";\r\n    return 0;\r\n}'),(1004,'# coding=utf-8\nprint(\"Hello World!\")'),(1005,'Hello World!'),(1006,'# coding=utf-8\nprint(\"Hello World!\")'),(1007,'<?php\r\n    echo(\"Hello World!\")\r\n?>'),(1008,'<script languge=\"php\">\r\n    echo(\"Hello World!\");\r\n</script>'),(1009,'<?php\r\necho \"Hello World!\";\r\n?>'),(1010,'#include <cstdio>\nint main() {\n    int a, b;\n    return printf(\"%d\",(scanf(\"%d\",&a)&0|a)+(scanf(\"%d\",&b)&0|b))&0;\n}'),(1011,'# coding=utf-8\na, b = map(int, input().split())\nprint(a + b)'),(1012,'#include <bits/stdc++.h>\nusing namespace std;\nclass SegTree\n{\n	private:\n		struct Node\n		{\n			int Left,Right,Max,Delta;\n			Node *Lchild,*Rchild;\n		};\n	public:\n		Node *Tree=new Node;\n		void build(Node *cur,int L,int R)\n		{\n			cur->Left=L;\n			cur->Right=R;\n			if(L!=R)\n			{\n				cur->Lchild=new Node;\n				cur->Rchild=new Node;\n				cur->Max=cur->Delta=0;\n				build(cur->Lchild,L,L+R>>1);\n				build(cur->Rchild,(L+R>>1)+1,R);\n			}\n			else{cur->Lchild=cur->Rchild=NULL;cur->Max=cur->Delta=0;};\n		}\n		int query(Node *cur,int L,int R)\n		{\n			int ans=0;\n			if(L<=cur->Left&&cur->Right<=R)\n				ans=cur->Max+cur->Delta;\n			else\n			{\n				cur->Lchild->Delta+=cur->Delta;\n				cur->Rchild->Delta+=cur->Delta;\n				cur->Delta=0;\n				if(L<=cur->Left+cur->Right>>1)\n					ans=max(ans,query(cur->Lchild,L,R));\n				if(R> cur->Left+cur->Right>>1)\n					ans=max(ans,query(cur->Rchild,L,R));\n				cur->Max=max(cur->Lchild->Max+cur->Lchild->Delta,cur->Rchild->Max+cur->Rchild->Delta);\n			}\n			return ans;\n		}\n		void secupdate(Node *cur,int L,int R,int Change)\n		{\n			if(L<=cur->Left&&cur->Right<=R)\n				cur->Delta+=Change;\n			else\n			{\n				cur->Lchild->Delta+=cur->Delta;\n				cur->Rchild->Delta+=cur->Delta;\n				cur->Delta=0;\n				if(L<=cur->Left+cur->Right>>1)secupdate(cur->Lchild,L,R,Change);\n				if(R> cur->Left+cur->Right>>1)secupdate(cur->Rchild,L,R,Change);\n				cur->Max=max(cur->Lchild->Max+cur->Lchild->Delta,cur->Rchild->Max+cur->Rchild->Delta);\n			}\n		} \n};\nint c,s,r,o,d,n;\nSegTree S;\nint main()\n{\n	cin >> c >> s >> r;\n	S.build(S.Tree,1,c);\n	for(int i=1;i<=r;i++)\n	{\n		cin >> o >> d >> n;\n		if(S.query(S.Tree,o,d-1)+n<=s)\n		{\n			S.secupdate(S.Tree,o,d-1,n);\n			cout << \"YES\" << endl;\n		}\n		else cout << \"NO\" << endl;\n	}\n	return 0;\n}'),(1013,'# coding=utf-8\nprint(\"Hello World!\")'),(1014,'# coding=utf-8\na=int(input())\r\nb=int(input())\r\nsum=a+b\r\nprint(sum)'),(1015,'#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nsigned main()\r\n{\r\n	int a,b;\r\n	cin>>a>>b;\r\n	cout<<a+b;\r\n	return 0;\r\n}'),(1016,'#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ls (p*2)\r\n#define rs (p*2+1)\r\n#define mid (l+r>>1)\r\n#define lson ls,l,mid\r\n#define rson rs,mid+1,r\r\n#define maxn 60005\r\n#define int long long\r\n#define INF 0x3f3f3f3f\r\n\r\nint n,S,m;\r\nint sum[maxn<<2];\r\nint lazy_tag[maxn<<2];\r\n\r\nvoid Pushdown(int p,int l,int r)\r\n{\r\n    lazy_tag[ls]+=lazy_tag[p];\r\n    lazy_tag[rs]+=lazy_tag[p];\r\n    sum[ls]+=lazy_tag[p];\r\n    sum[rs]+=lazy_tag[p];\r\n    lazy_tag[p]=0;\r\n}\r\n\r\nvoid Add(int p,int l,int r,int s,int t,int z)\r\n{\r\n    if(s>r||t<l)\r\n        return ;\r\n    if(s<=l && r<=t)\r\n    {\r\n        sum[p]+=z;\r\n        lazy_tag[p]+=z; \r\n        return;\r\n    }\r\n    Pushdown(p,l,r);\r\n    Add(lson,s,t,z);\r\n    Add(rson,s,t,z);\r\n    sum[p]=max(sum[ls],sum[rs]);\r\n    return;\r\n}\r\n\r\nint Max(int p,int l,int r,int s,int t)\r\n{\r\n    if(s>r||t<l)\r\n        return -INF;\r\n    if(s<=l&&r<=t)\r\n        return sum[p];\r\n    Pushdown(p,l,r);\r\n    return max(Max(lson,s,t),Max(rson,s,t));\r\n}\r\n\r\nsigned main()\r\n{\r\n    cin>>n>>S>>m;\r\n    for(int i=1;i<=m;i++)\r\n    {\r\n        int x,y,z;\r\n        cin>>x>>y>>z;\r\n        y--;\r\n        if(x>y)\r\n            swap(x,y);\r\n        Add(1,1,n,x,y,z);\r\n        if(Max(1,1,n,x,y)>S)\r\n        {\r\n            cout<<\"NO\"<<endl;\r\n            Add(1,1,n,x,y,-z);\r\n        } \r\n        else\r\n            cout<<\"YES\"<<endl;\r\n    } \r\n    return 0;\r\n}'),(1017,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n    int a,b;\r\n    cin>>a>>b;\r\n    cout<<a+b;\r\n}'),(1018,'#include <bits/stdc++.h> \r\nusing namespace std;\r\n\r\nconst int N = 500001, INF = 0x3f3f3f3f;\r\n\r\nint n, m, a[N];\r\nstruct SegTree {\r\n	int l, r, s, lx, rx, ans;\r\n} t[N << 2];\r\n\r\nvoid build(int l, int r, int p = 1) {\r\n	t[p].l = l; t[p].r = r;\r\n	if (l == r) {\r\n		t[p].s = t[p].lx = t[p].rx = t[p].ans = a[l];\r\n		return;\r\n	}\r\n	int mid = (l + r) >> 1;\r\n	build(l      , mid, p << 1    );\r\n	build(mid + 1, r  , p << 1 | 1);\r\n	t[p].s   = t[p << 1].s + t[p << 1 | 1].s;\r\n	t[p].lx  = max(t[p << 1    ].lx, t[p << 1].s  + t[p << 1 | 1].lx);\r\n	t[p].rx  = max(t[p << 1 | 1].rx, t[p << 1].rx + t[p << 1 | 1].s );\r\n	t[p].ans = max(max(t[p << 1].ans, t[p << 1 | 1].ans), t[p << 1].rx + t[p << 1 | 1].lx);\r\n}\r\n\r\nvoid change(int x, int y, int p = 1) {\r\n	if (t[p].l == t[p].r) {\r\n		t[p].s = t[p].lx = t[p].rx = t[p].ans = y;\r\n		return;\r\n	}\r\n	int mid = (t[p].l + t[p].r) >> 1;\r\n	if (x <= mid) change(x, y, p << 1);\r\n	else          change(x, y, p << 1 | 1);\r\n	t[p].s   = t[p << 1].s + t[p << 1 | 1].s;\r\n	t[p].lx  = max(t[p << 1    ].lx, t[p << 1].s  + t[p << 1 | 1].lx);\r\n	t[p].rx  = max(t[p << 1 | 1].rx, t[p << 1].rx + t[p << 1 | 1].s );\r\n	t[p].ans = max(max(t[p << 1].ans, t[p << 1 | 1].ans), t[p << 1].rx + t[p << 1 | 1].lx);\r\n}\r\n\r\nSegTree ask(int l, int r, int p = 1) {\r\n	if (l <= t[p].l and r >= t[p].r) return t[p];\r\n	SegTree a, b, ans;\r\n	a.s = a.lx = a.rx = a.ans = -INF;\r\n	b.s = b.lx = b.rx = b.ans = -INF;\r\n	ans.s = 0;\r\n	int mid = (t[p].l + t[p].r) >> 1;\r\n	if (l <= mid) {\r\n		a = ask(l, r, p << 1);\r\n		ans.s += a.s;\r\n	}\r\n	if (r > mid) {\r\n		b = ask(l, r, p << 1 | 1);\r\n		ans.s += b.s;\r\n	}\r\n	ans.ans = max(max(a.ans, b.ans), a.rx + b.lx);\r\n	ans.lx  = max(a.lx, a.s + b.lx);\r\n	ans.rx  = max(b.rx, b.s + a.rx);\r\n	if (l > mid)  ans.lx = max(ans.lx, b.lx);\r\n	if (r <= mid) ans.rx = max(ans.rx, a.rx);\r\n	return ans;\r\n}\r\n\r\nint main() {\r\n	ios::sync_with_stdio(false);\r\n	cin.tie(nullptr); cout.tie(nullptr);\r\n	cin >> n >> m;\r\n	for (int i = 1; i <= n; i++)\r\n		cin >> a[i];\r\n	build(1, n);\r\n	while (m--) {\r\n		int t, x, y;\r\n		cin >> t >> x >> y;\r\n		if (t == 1) {\r\n			if (x > y) swap(x, y);\r\n			cout << ask(x, y).ans << endl;\r\n		}\r\n		else change(x, y);\r\n	}\r\n	return 0;\r\n}'),(1019,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ninline int read(){\r\n    int x=0,f=1;\r\n    char c=getchar();\r\n    while(c<\'0\'||c>\'9\'){\r\n        if(c==\'-\') f=-f;\r\n        c=getchar();\r\n    }\r\n    while(c>=\'0\'&&c<=\'9\'){\r\n        x=(x<<3)+(x<<1)+c-\'0\';\r\n        c=getchar();\r\n    }\r\n    return x*f;\r\n}\r\nconst int maxn=50010;\r\nint n,d[4*maxn],lmax[4*maxn],rmax[4*maxn],vmax[4*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build(n<<1|1,mid+1,r);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nint main(){\r\n    n=read();\r\n    for(int i=1;i<=n;i++) a[i]=read();\r\n	build(1,1,n);\r\n	q=read();\r\n    while(q--){\r\n        int op;\r\n        op=read();\r\n        if(op==0){\r\n            int id,x;\r\n            id=read();\r\n            x=read();\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n            ql=read();\r\n            qr=read();\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1020,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ninline int read(){\r\n    int x=0,f=1;\r\n    char c=getchar();\r\n    while(c<\'0\'||c>\'9\'){\r\n        if(c==\'-\') f=-f;\r\n        c=getchar();\r\n    }\r\n    while(c>=\'0\'&&c<=\'9\'){\r\n        x=(x<<3)+(x<<1)+c-\'0\';\r\n        c=getchar();\r\n    }\r\n    return x*f;\r\n}\r\nconst int maxn=50010;\r\nint n,d[4*maxn],lmax[4*maxn],rmax[4*maxn],vmax[4*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build(n<<1|1,mid+1,r);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nint main(){\r\n    n=read();\r\n    for(int i=1;i<=n;i++) a[i]=read();\r\n	build(1,1,n);\r\n	q=read();\r\n    while(q--){\r\n        int op;\r\n        op=read();\r\n        if(op==0){\r\n            int id,x;\r\n            id=read();\r\n            x=read();\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n            ql=read();\r\n            qr=read();\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1021,'#include<bits/stdc++.h> \r\nusing namespace std;\r\n\r\nint read()\r\n{\r\n    int f=1,x=0;\r\n    char ss=getchar();\r\n    while(ss<\'0\'||ss>\'9\'){if(ss==\'-\')f=-1;ss=getchar();}\r\n    while(ss>=\'0\'&&ss<=\'9\'){x=x*10+ss-\'0\';ss=getchar();}\r\n    return f*x;\r\n}\r\n\r\nconst int maxn=100010;\r\nint n,m;\r\nint rt;\r\nint val[maxn],sum[maxn];\r\nint ch[maxn][2],fa[maxn];\r\nint size[maxn];\r\nint lx[maxn],rx[maxn],mx[maxn];\r\n\r\nvoid update(int p)\r\n{\r\n    int lc=ch[p][0],rc=ch[p][1];\r\n    size[p]=size[lc]+size[rc]+1;\r\n    sum[p]=sum[lc]+sum[rc]+val[p];\r\n    lx[p]=max(lx[lc],sum[lc]+lx[rc]+val[p]);\r\n    rx[p]=max(rx[rc],sum[rc]+rx[lc]+val[p]);\r\n    mx[p]=max(max(mx[lc],mx[rc]),rx[lc]+lx[rc]+val[p]);\r\n}\r\n\r\nvoid build(int p,int ll,int rr)\r\n{\r\n    if(ll>rr) return;\r\n    int mid=ll+rr>>1;\r\n    fa[mid]=p; size[mid]=1;\r\n    ch[p][mid>p]=mid;\r\n    if(ll==rr) \r\n    { \r\n        lx[mid]=rx[mid]=max(val[mid],0);\r\n        sum[mid]=mx[mid]=val[mid];  return;\r\n    }\r\n    build(mid,ll,mid-1); build(mid,mid+1,rr);\r\n    update(mid);\r\n}\r\n\r\nvoid rotate(int &p,int x)\r\n{\r\n    int y=fa[x],z=fa[y];\r\n    int d=(ch[y][0]==x);\r\n    if(y==p) p=x;\r\n    else if(ch[z][0]==y) ch[z][0]=x;\r\n    else ch[z][1]=x;\r\n    fa[y]=x; fa[ch[x][d]]=y; fa[x]=z;\r\n    ch[y][d^1]=ch[x][d]; ch[x][d]=y;\r\n    update(y); update(x);\r\n}\r\n\r\n\r\nvoid splay(int &p,int x)\r\n{\r\n    while(x!=p)\r\n    {\r\n        int y=fa[x],z=fa[y];\r\n        if(y!=p)\r\n        {\r\n            if((ch[z][0]==y)^(ch[y][0]==x))rotate(p,x);\r\n            else rotate(p,y);\r\n        }\r\n        rotate(p,x);\r\n    }\r\n}\r\n\r\nint find(int p,int k) \r\n{ \r\n    int ss=size[ch[p][0]]; \r\n    if(k==ss+1) return p;    \r\n    else if(k<=ss) return find(ch[p][0],k);\r\n    else return find(ch[p][1],k-ss-1);  \r\n}\r\n\r\nvoid change(int k,int w)\r\n{\r\n    int x=find(rt,k); splay(rt,x);\r\n    int y=find(rt,k+2); splay(ch[rt][1],y);\r\n    int z=ch[y][0];\r\n    val[z]=mx[z]=sum[z]=w;\r\n    lx[z]=rx[z]=max(w,0);\r\n    update(y); update(x);\r\n}\r\n\r\nvoid query(int ll,int rr)\r\n{\r\n    int x=find(rt,ll); splay(rt,x);\r\n    int y=find(rt,rr+2); splay(ch[rt][1],y);\r\n    printf(\"%d\\n\",mx[ch[y][0]]);\r\n}\r\n\r\nint main()\r\n{\r\n    n=read();\r\n    mx[0]=val[1]=val[n+2]=-1e9;\r\n    for(int i=2;i<=n+1;++i)\r\n    val[i]=read();\r\n    rt=n+3>>1;\r\n    build(rt,1,n+2);\r\n    m=read();\r\n    while(m--)\r\n    {\r\n        int k=read(),x=read(),y=read();\r\n        if(k==0) change(x,y);\r\n        else if(k==1) query(x,y);\r\n    }\r\n    return 0;\r\n}'),(1022,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ninline int read(){\r\n    int x=0,f=1;\r\n    char c=getchar();\r\n    while(c<\'0\'||c>\'9\'){\r\n        if(c==\'-\') f=-f;\r\n        c=getchar();\r\n    }\r\n    while(c>=\'0\'&&c<=\'9\'){\r\n        x=(x<<3)+(x<<1)+c-\'0\';\r\n        c=getchar();\r\n    }\r\n    return x*f;\r\n}\r\nconst int maxn=50010;\r\nint n,d[4*maxn],lmax[4*maxn],rmax[4*maxn],vmax[4*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build(n<<1|1,mid+1,r);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nint main(){\r\n    n=read();\r\n    for(int i=1;i<=n;i++) a[i]=read();\r\n	build(1,1,n);\r\n	q=read();\r\n    while(q--){\r\n        int op;\r\n        op=read();\r\n        if(op==0){\r\n            int id,x;\r\n            id=read();\r\n            x=read();\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n            ql=read();\r\n            qr=read();\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1023,'#include<bits/stdc++.h> \r\nusing namespace std;\r\n\r\nint read()\r\n{\r\n    int f=1,x=0;\r\n    char ss=getchar();\r\n    while(ss<\'0\'||ss>\'9\'){if(ss==\'-\')f=-1;ss=getchar();}\r\n    while(ss>=\'0\'&&ss<=\'9\'){x=x*10+ss-\'0\';ss=getchar();}\r\n    return f*x;\r\n}\r\n\r\nconst int maxn=100010;\r\nint n,m;\r\nint rt;\r\nint val[maxn],sum[maxn];\r\nint ch[maxn][2],fa[maxn];\r\nint size[maxn];\r\nint lx[maxn],rx[maxn],mx[maxn];\r\n\r\nvoid update(int p)\r\n{\r\n    int lc=ch[p][0],rc=ch[p][1];\r\n    size[p]=size[lc]+size[rc]+1;\r\n    sum[p]=sum[lc]+sum[rc]+val[p];\r\n    lx[p]=max(lx[lc],sum[lc]+lx[rc]+val[p]);\r\n    rx[p]=max(rx[rc],sum[rc]+rx[lc]+val[p]);\r\n    mx[p]=max(max(mx[lc],mx[rc]),rx[lc]+lx[rc]+val[p]);\r\n}\r\n\r\nvoid build(int p,int ll,int rr)\r\n{\r\n    if(ll>rr) return;\r\n    int mid=ll+rr>>1;\r\n    fa[mid]=p; size[mid]=1;\r\n    ch[p][mid>p]=mid;\r\n    if(ll==rr) \r\n    { \r\n        lx[mid]=rx[mid]=max(val[mid],0);\r\n        sum[mid]=mx[mid]=val[mid];  return;\r\n    }\r\n    build(mid,ll,mid-1); build(mid,mid+1,rr);\r\n    update(mid);\r\n}\r\n\r\nvoid rotate(int &p,int x)\r\n{\r\n    int y=fa[x],z=fa[y];\r\n    int d=(ch[y][0]==x);\r\n    if(y==p) p=x;\r\n    else if(ch[z][0]==y) ch[z][0]=x;\r\n    else ch[z][1]=x;\r\n    fa[y]=x; fa[ch[x][d]]=y; fa[x]=z;\r\n    ch[y][d^1]=ch[x][d]; ch[x][d]=y;\r\n    update(y); update(x);\r\n}\r\n\r\nvoid splay(int &p,int x)\r\n{\r\n    while(x!=p)\r\n    {\r\n        int y=fa[x],z=fa[y];\r\n        if(y!=p)\r\n        {\r\n            if((ch[z][0]==y)^(ch[y][0]==x))rotate(p,x);\r\n            else rotate(p,y);\r\n        }\r\n        rotate(p,x);\r\n    }\r\n}\r\n\r\nint find(int p,int k) \r\n{ \r\n    int ss=size[ch[p][0]]; \r\n    if(k==ss+1) return p;    \r\n    else if(k<=ss) return find(ch[p][0],k);\r\n    else return find(ch[p][1],k-ss-1);  \r\n}\r\n\r\nvoid change(int k,int w)\r\n{\r\n    int x=find(rt,k); splay(rt,x);\r\n    int y=find(rt,k+2); splay(ch[rt][1],y);\r\n    int z=ch[y][0];\r\n    val[z]=mx[z]=sum[z]=w;\r\n    lx[z]=rx[z]=max(w,0);\r\n    update(y); update(x);\r\n}\r\n\r\nvoid query(int ll,int rr)\r\n{\r\n    int x=find(rt,ll); splay(rt,x);\r\n    int y=find(rt,rr+2); splay(ch[rt][1],y);\r\n    printf(\"%d\\n\",mx[ch[y][0]]);\r\n}\r\n\r\nint main()\r\n{\r\n    n=read();\r\n    mx[0]=val[1]=val[n+2]=-1e9;\r\n    for(int i=2;i<=n+1;i++)\r\n    	val[i]=read();\r\n    rt=n+3>>1;\r\n    build(rt,1,n+2);\r\n    m=read();\r\n    while(m--)\r\n    {\r\n        int k=read(),x=read(),y=read();\r\n        if(k==1) change(x,y);\r\n        else if(k==2) query(x,y);\r\n    }\r\n    return 0;\r\n}'),(1024,'#include<bits/stdc++.h> \r\n#define int long long\r\nusing namespace std;\r\n \r\nint read()\r\n{\r\n    int f=1,x=0;\r\n    char ss=getchar();\r\n    while(ss<\'0\'||ss>\'9\'){if(ss==\'-\')f=-1;ss=getchar();}\r\n    while(ss>=\'0\'&&ss<=\'9\'){x=x*10+ss-\'0\';ss=getchar();}\r\n    return f*x;\r\n}\r\n \r\nconst int maxn=100010;\r\nint n,m;\r\nint rt;\r\nint val[maxn],sum[maxn];\r\nint ch[maxn][2],fa[maxn];\r\nint size[maxn];\r\nint lx[maxn],rx[maxn],mx[maxn];\r\n \r\nvoid update(int p)\r\n{\r\n    int lc=ch[p][0],rc=ch[p][1];\r\n    size[p]=size[lc]+size[rc]+1;\r\n    sum[p]=sum[lc]+sum[rc]+val[p];\r\n    lx[p]=max(lx[lc],sum[lc]+lx[rc]+val[p]);\r\n    rx[p]=max(rx[rc],sum[rc]+rx[lc]+val[p]);\r\n    mx[p]=max(max(mx[lc],mx[rc]),rx[lc]+lx[rc]+val[p]);\r\n}\r\n \r\nvoid build(int p,int ll,int rr)\r\n{\r\n    if(ll>rr) return;\r\n    int mid=ll+rr>>1;\r\n    fa[mid]=p; size[mid]=1;\r\n    ch[p][mid>p]=mid;\r\n    if(ll==rr) \r\n    { \r\n        lx[mid]=rx[mid]=max(val[mid],0);\r\n        sum[mid]=mx[mid]=val[mid];  return;\r\n    }\r\n    build(mid,ll,mid-1); build(mid,mid+1,rr);\r\n    update(mid);\r\n}\r\n \r\nvoid rotate(int &p,int x)\r\n{\r\n    int y=fa[x],z=fa[y];\r\n    int d=(ch[y][0]==x);\r\n    if(y==p) p=x;\r\n    else if(ch[z][0]==y) ch[z][0]=x;\r\n    else ch[z][1]=x;\r\n    fa[y]=x; fa[ch[x][d]]=y; fa[x]=z;\r\n    ch[y][d^1]=ch[x][d]; ch[x][d]=y;\r\n    update(y); update(x);\r\n}\r\n \r\nvoid splay(int &p,int x)\r\n{\r\n    while(x!=p)\r\n    {\r\n        int y=fa[x],z=fa[y];\r\n        if(y!=p)\r\n        {\r\n            if((ch[z][0]==y)^(ch[y][0]==x))rotate(p,x);\r\n            else rotate(p,y);\r\n        }\r\n        rotate(p,x);\r\n    }\r\n}\r\n \r\nint find(int p,int k) \r\n{ \r\n    int ss=size[ch[p][0]]; \r\n    if(k==ss+1) return p;    \r\n    else if(k<=ss) return find(ch[p][0],k);\r\n    else return find(ch[p][1],k-ss-1);  \r\n}\r\n \r\nvoid change(int k,int w)\r\n{\r\n    int x=find(rt,k); splay(rt,x);\r\n    int y=find(rt,k+2); splay(ch[rt][1],y);\r\n    int z=ch[y][0];\r\n    val[z]=mx[z]=sum[z]=w;\r\n    lx[z]=rx[z]=max(w,0);\r\n    update(y); update(x);\r\n}\r\n \r\nvoid query(int ll,int rr)\r\n{\r\n    int x=find(rt,ll); splay(rt,x);\r\n    int y=find(rt,rr+2); splay(ch[rt][1],y);\r\n    printf(\"%d\\n\",mx[ch[y][0]]);\r\n}\r\n \r\nsigned main()\r\n{\r\n    n=read();\r\n    mx[0]=val[1]=val[n+2]=-1e9;\r\n    for(int i=2;i<=n+1;i++)\r\n        val[i]=read();\r\n    rt=n+3>>1;\r\n    build(rt,1,n+2);\r\n    m=read();\r\n    while(m--)\r\n    {\r\n        int k=read(),x=read(),y=read();\r\n        if(k==1) change(x,y);\r\n        else if(k==2) query(x,y);\r\n    }\r\n    return 0;\r\n}'),(1025,'#include<bits/stdc++.h> \r\n#define int long long\r\nusing namespace std;\r\n \r\nint read()\r\n{\r\n    int f=1,x=0;\r\n    char ss=getchar();\r\n    while(ss<\'0\'||ss>\'9\'){if(ss==\'-\')f=-1;ss=getchar();}\r\n    while(ss>=\'0\'&&ss<=\'9\'){x=x*10+ss-\'0\';ss=getchar();}\r\n    return f*x;\r\n}\r\n \r\nconst int maxn=100010;\r\nint n,m;\r\nint rt;\r\nint val[maxn],sum[maxn];\r\nint ch[maxn][2],fa[maxn];\r\nint size[maxn];\r\nint lx[maxn],rx[maxn],mx[maxn];\r\n \r\nvoid update(int p)\r\n{\r\n    int lc=ch[p][0],rc=ch[p][1];\r\n    size[p]=size[lc]+size[rc]+1;\r\n    sum[p]=sum[lc]+sum[rc]+val[p];\r\n    lx[p]=max(lx[lc],sum[lc]+lx[rc]+val[p]);\r\n    rx[p]=max(rx[rc],sum[rc]+rx[lc]+val[p]);\r\n    mx[p]=max(max(mx[lc],mx[rc]),rx[lc]+lx[rc]+val[p]);\r\n}\r\n \r\nvoid build(int p,int ll,int rr)\r\n{\r\n    if(ll>rr) return;\r\n    int mid=ll+rr>>1;\r\n    fa[mid]=p; size[mid]=1;\r\n    ch[p][mid>p]=mid;\r\n    if(ll==rr) \r\n    { \r\n        lx[mid]=rx[mid]=max(val[mid],0);\r\n        sum[mid]=mx[mid]=val[mid];  return;\r\n    }\r\n    build(mid,ll,mid-1); build(mid,mid+1,rr);\r\n    update(mid);\r\n}\r\n \r\nvoid rotate(int &p,int x)\r\n{\r\n    int y=fa[x],z=fa[y];\r\n    int d=(ch[y][0]==x);\r\n    if(y==p) p=x;\r\n    else if(ch[z][0]==y) ch[z][0]=x;\r\n    else ch[z][1]=x;\r\n    fa[y]=x; fa[ch[x][d]]=y; fa[x]=z;\r\n    ch[y][d^1]=ch[x][d]; ch[x][d]=y;\r\n    update(y); update(x);\r\n}\r\n \r\nvoid splay(int &p,int x)\r\n{\r\n    while(x!=p)\r\n    {\r\n        int y=fa[x],z=fa[y];\r\n        if(y!=p)\r\n        {\r\n            if((ch[z][0]==y)^(ch[y][0]==x))rotate(p,x);\r\n            else rotate(p,y);\r\n        }\r\n        rotate(p,x);\r\n    }\r\n}\r\n \r\nint find(int p,int k) \r\n{ \r\n    int ss=size[ch[p][0]]; \r\n    if(k==ss+1) return p;    \r\n    else if(k<=ss) return find(ch[p][0],k);\r\n    else return find(ch[p][1],k-ss-1);  \r\n}\r\n \r\nvoid change(int k,int w)\r\n{\r\n    int x=find(rt,k); splay(rt,x);\r\n    int y=find(rt,k+2); splay(ch[rt][1],y);\r\n    int z=ch[y][0];\r\n    val[z]=mx[z]=sum[z]=w;\r\n    lx[z]=rx[z]=max(w,0LL);\r\n    update(y); update(x);\r\n}\r\n \r\nvoid query(int ll,int rr)\r\n{\r\n    int x=find(rt,ll); splay(rt,x);\r\n    int y=find(rt,rr+2); splay(ch[rt][1],y);\r\n    printf(\"%d\\n\",mx[ch[y][0]]);\r\n}\r\n \r\nsigned main()\r\n{\r\n    n=read();\r\n    mx[0]=val[1]=val[n+2]=-1e9;\r\n    for(int i=2;i<=n+1;i++)\r\n        val[i]=read();\r\n    rt=n+3>>1;\r\n    build(rt,1,n+2);\r\n    m=read();\r\n    while(m--)\r\n    {\r\n        int k=read(),x=read(),y=read();\r\n        if(k==1) change(x,y);\r\n        else if(k==2) query(x,y);\r\n    }\r\n    return 0;\r\n}'),(1026,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\ninline int read(){\r\n    int x=0,f=1;\r\n    char c=getchar();\r\n    while(c<\'0\'||c>\'9\'){\r\n        if(c==\'-\') f=-f;\r\n        c=getchar();\r\n    }\r\n    while(c>=\'0\'&&c<=\'9\'){\r\n        x=(x<<3)+(x<<1)+c-\'0\';\r\n        c=getchar();\r\n    }\r\n    return x*f;\r\n}\r\nconst int maxn=50010;\r\nint n,d[4*maxn],lmax[4*maxn],rmax[4*maxn],vmax[4*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build(n<<1|1,mid+1,r);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nsigned main(){\r\n    cin>>n>>q;\r\n    for(int i=1;i<=n;i++) cin>>a[i];\r\n	build(1,1,n);\r\n    while(q--){\r\n        int op;\r\n        cin>>op;\r\n        if(op==2){\r\n            int id,x;\r\n            cin>>id>>x;\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n        	cin>>ql>>qr;\r\n        	if(ql>qr) swap(ql,qr);\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1027,'#include<bits/stdc++.h> \r\n#define int long long\r\nusing namespace std;\r\n \r\nint read()\r\n{\r\n    int f=1,x=0;\r\n    char ss=getchar();\r\n    while(ss<\'0\'||ss>\'9\'){if(ss==\'-\')f=-1;ss=getchar();}\r\n    while(ss>=\'0\'&&ss<=\'9\'){x=x*10+ss-\'0\';ss=getchar();}\r\n    return f*x;\r\n}\r\n \r\nconst int maxn=100010;\r\nint n,m;\r\nint rt;\r\nint val[maxn],sum[maxn];\r\nint ch[maxn][2],fa[maxn];\r\nint size[maxn];\r\nint lx[maxn],rx[maxn],mx[maxn];\r\n \r\nvoid update(int p)\r\n{\r\n    int lc=ch[p][0],rc=ch[p][1];\r\n    size[p]=size[lc]+size[rc]+1;\r\n    sum[p]=sum[lc]+sum[rc]+val[p];\r\n    lx[p]=max(lx[lc],sum[lc]+lx[rc]+val[p]);\r\n    rx[p]=max(rx[rc],sum[rc]+rx[lc]+val[p]);\r\n    mx[p]=max(max(mx[lc],mx[rc]),rx[lc]+lx[rc]+val[p]);\r\n}\r\n \r\nvoid build(int p,int ll,int rr)\r\n{\r\n    if(ll>rr) return;\r\n    int mid=ll+rr>>1;\r\n    fa[mid]=p; size[mid]=1;\r\n    ch[p][mid>p]=mid;\r\n    if(ll==rr) \r\n    { \r\n        lx[mid]=rx[mid]=max(val[mid],0LL);\r\n        sum[mid]=mx[mid]=val[mid];  return;\r\n    }\r\n    build(mid,ll,mid-1); build(mid,mid+1,rr);\r\n    update(mid);\r\n}\r\n \r\nvoid rotate(int &p,int x)\r\n{\r\n    int y=fa[x],z=fa[y];\r\n    int d=(ch[y][0]==x);\r\n    if(y==p) p=x;\r\n    else if(ch[z][0]==y) ch[z][0]=x;\r\n    else ch[z][1]=x;\r\n    fa[y]=x; fa[ch[x][d]]=y; fa[x]=z;\r\n    ch[y][d^1]=ch[x][d]; ch[x][d]=y;\r\n    update(y); update(x);\r\n}\r\n \r\nvoid splay(int &p,int x)\r\n{\r\n    while(x!=p)\r\n    {\r\n        int y=fa[x],z=fa[y];\r\n        if(y!=p)\r\n        {\r\n            if((ch[z][0]==y)^(ch[y][0]==x))rotate(p,x);\r\n            else rotate(p,y);\r\n        }\r\n        rotate(p,x);\r\n    }\r\n}\r\n \r\nint find(int p,int k) \r\n{ \r\n    int ss=size[ch[p][0]]; \r\n    if(k==ss+1) return p;    \r\n    else if(k<=ss) return find(ch[p][0],k);\r\n    else return find(ch[p][1],k-ss-1);  \r\n}\r\n \r\nvoid change(int k,int w)\r\n{\r\n    int x=find(rt,k); splay(rt,x);\r\n    int y=find(rt,k+2); splay(ch[rt][1],y);\r\n    int z=ch[y][0];\r\n    val[z]=mx[z]=sum[z]=w;\r\n    lx[z]=rx[z]=max(w,0LL);\r\n    update(y); update(x);\r\n}\r\n \r\nvoid query(int ll,int rr)\r\n{\r\n    int x=find(rt,ll); splay(rt,x);\r\n    int y=find(rt,rr+2); splay(ch[rt][1],y);\r\n    printf(\"%d\\n\",mx[ch[y][0]]);\r\n}\r\n \r\nsigned main()\r\n{\r\n    n=read();\r\n    mx[0]=val[1]=val[n+2]=-1e9;\r\n    for(int i=2;i<=n+1;i++)\r\n        val[i]=read();\r\n    rt=n+3>>1;\r\n    build(rt,1,n+2);\r\n    m=read();\r\n    while(m--)\r\n    {\r\n        int k=read(),x=read(),y=read();\r\n        if(k==1) change(x,y);\r\n        else if(k==2) query(x,y);\r\n    }\r\n    return 0;\r\n}'),(1028,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\ninline int read(){\r\n    int x=0,f=1;\r\n    char c=getchar();\r\n    while(c<\'0\'||c>\'9\'){\r\n        if(c==\'-\') f=-f;\r\n        c=getchar();\r\n    }\r\n    while(c>=\'0\'&&c<=\'9\'){\r\n        x=(x<<3)+(x<<1)+c-\'0\';\r\n        c=getchar();\r\n    }\r\n    return x*f;\r\n}\r\nconst int maxn=50010;\r\nint n,d[8*maxn],lmax[8*maxn],rmax[8*maxn],vmax[8*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build(n<<1|1,mid+1,r);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nsigned main(){\r\n    cin>>n>>q;\r\n    for(int i=1;i<=n;i++) cin>>a[i];\r\n	build(1,1,n);\r\n    while(q--){\r\n        int op;\r\n        cin>>op;\r\n        if(op==2){\r\n            int id,x;\r\n            cin>>id>>x;\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n        	cin>>ql>>qr;\r\n        	if(ql>qr) swap(ql,qr);\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1029,'#include<bits/stdc++.h> \r\n#define int long long\r\nusing namespace std;\r\n \r\nint read()\r\n{\r\n    int f=1,x=0;\r\n    char ss=getchar();\r\n    while(ss<\'0\'||ss>\'9\'){if(ss==\'-\')f=-1;ss=getchar();}\r\n    while(ss>=\'0\'&&ss<=\'9\'){x=x*10+ss-\'0\';ss=getchar();}\r\n    return f*x;\r\n}\r\n \r\nconst int maxn=100010;\r\nint n,m;\r\nint rt;\r\nint val[maxn],sum[maxn];\r\nint ch[maxn][2],fa[maxn];\r\nint size[maxn];\r\nint lx[maxn],rx[maxn],mx[maxn];\r\n \r\nvoid update(int p)\r\n{\r\n    int lc=ch[p][0],rc=ch[p][1];\r\n    size[p]=size[lc]+size[rc]+1;\r\n    sum[p]=sum[lc]+sum[rc]+val[p];\r\n    lx[p]=max(lx[lc],sum[lc]+lx[rc]+val[p]);\r\n    rx[p]=max(rx[rc],sum[rc]+rx[lc]+val[p]);\r\n    mx[p]=max(max(mx[lc],mx[rc]),rx[lc]+lx[rc]+val[p]);\r\n}\r\n \r\nvoid build(int p,int ll,int rr)\r\n{\r\n    if(ll>rr) return;\r\n    int mid=ll+rr>>1;\r\n    fa[mid]=p; size[mid]=1;\r\n    ch[p][mid>p]=mid;\r\n    if(ll==rr) \r\n    { \r\n        lx[mid]=rx[mid]=max(val[mid],0LL);\r\n        sum[mid]=mx[mid]=val[mid];  return;\r\n    }\r\n    build(mid,ll,mid-1); build(mid,mid+1,rr);\r\n    update(mid);\r\n}\r\n \r\nvoid rotate(int &p,int x)\r\n{\r\n    int y=fa[x],z=fa[y];\r\n    int d=(ch[y][0]==x);\r\n    if(y==p) p=x;\r\n    else if(ch[z][0]==y) ch[z][0]=x;\r\n    else ch[z][1]=x;\r\n    fa[y]=x; fa[ch[x][d]]=y; fa[x]=z;\r\n    ch[y][d^1]=ch[x][d]; ch[x][d]=y;\r\n    update(y); update(x);\r\n}\r\n \r\nvoid splay(int &p,int x)\r\n{\r\n    while(x!=p)\r\n    {\r\n        int y=fa[x],z=fa[y];\r\n        if(y!=p)\r\n        {\r\n            if((ch[z][0]==y)^(ch[y][0]==x))rotate(p,x);\r\n            else rotate(p,y);\r\n        }\r\n        rotate(p,x);\r\n    }\r\n}\r\n \r\nint find(int p,int k) \r\n{ \r\n    int ss=size[ch[p][0]]; \r\n    if(k==ss+1) return p;    \r\n    else if(k<=ss) return find(ch[p][0],k);\r\n    else return find(ch[p][1],k-ss-1);  \r\n}\r\n \r\nvoid change(int k,int w)\r\n{\r\n    int x=find(rt,k); splay(rt,x);\r\n    int y=find(rt,k+2); splay(ch[rt][1],y);\r\n    int z=ch[y][0];\r\n    val[z]=mx[z]=sum[z]=w;\r\n    lx[z]=rx[z]=max(w,0LL);\r\n    update(y); update(x);\r\n}\r\n \r\nvoid query(int ll,int rr)\r\n{\r\n    int x=find(rt,ll); splay(rt,x);\r\n    int y=find(rt,rr+2); splay(ch[rt][1],y);\r\n    printf(\"%d\\n\",mx[ch[y][0]]);\r\n}\r\n \r\nsigned main()\r\n{\r\n    n=read();\r\n    mx[0]=val[1]=val[n+2]=-1e9;\r\n    for(int i=2;i<=n+1;i++)\r\n        val[i]=read();\r\n    rt=n+3>>1;\r\n    build(rt,1,n+2);\r\n    m=read();\r\n    while(m--)\r\n    {\r\n        int k=read(),x=read(),y=read();\r\n        if(k==2) change(x,y);\r\n        else if(k==1) query(x,y);\r\n    }\r\n    return 0;\r\n}'),(1030,'# coding=utf-8\nwhile True:\r\n    print(\"Fuck GXOJ\")'),(1031,'//Author:XuHt\r\n#include <cstdio>\r\n#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst int N = 500006, INF = 0x3f3f3f3f;\r\nint n, m, a[N];\r\nstruct T {\r\n	int l, r, s, lx, rx, ans;\r\n} t[N*4];\r\n\r\nvoid build(int p, int l, int r) {\r\n	t[p].l = l;\r\n	t[p].r = r;\r\n	if (l == r) {\r\n		t[p].s = t[p].lx = t[p].rx = t[p].ans = a[l];\r\n		return;\r\n	}\r\n	int mid = (l + r) >> 1;\r\n	build(p << 1, l, mid);\r\n	build(p << 1 | 1, mid + 1, r);\r\n	t[p].s = t[p<<1].s + t[p<<1|1].s;\r\n	t[p].lx = max(t[p<<1].lx, t[p<<1].s + t[p<<1|1].lx);\r\n	t[p].rx = max(t[p<<1|1].rx, t[p<<1].rx + t[p<<1|1].s);\r\n	t[p].ans = max(max(t[p<<1].ans, t[p<<1|1].ans), t[p<<1].rx + t[p<<1|1].lx);\r\n}\r\n\r\nvoid change(int p, int x, int y) {\r\n	if (t[p].l == t[p].r) {\r\n		t[p].s = t[p].lx = t[p].rx = t[p].ans = y;\r\n		return;\r\n	}\r\n	int mid = (t[p].l + t[p].r) >> 1;\r\n	if (x <= mid) change(p << 1, x, y);\r\n	else change(p << 1 | 1, x, y);\r\n	t[p].s = t[p<<1].s + t[p<<1|1].s;\r\n	t[p].lx = max(t[p<<1].lx, t[p<<1].s + t[p<<1|1].lx);\r\n	t[p].rx = max(t[p<<1|1].rx, t[p<<1].rx + t[p<<1|1].s);\r\n	t[p].ans = max(max(t[p<<1].ans, t[p<<1|1].ans), t[p<<1].rx + t[p<<1|1].lx);\r\n}\r\n\r\nT ask(int p, int l, int r) {\r\n	if (l <= t[p].l && r >= t[p].r) return t[p];\r\n	T a, b, ans;\r\n	a.s = a.lx = a.rx = a.ans = b.s = b.lx = b.rx = b.ans = -INF;\r\n	ans.s = 0;\r\n	int mid = (t[p].l + t[p].r) >> 1;\r\n	if (l <= mid) {\r\n		a = ask(p << 1, l, r);\r\n		ans.s += a.s;\r\n	}\r\n	if (r > mid) {\r\n		b = ask(p << 1 | 1, l, r);\r\n		ans.s += b.s;\r\n	}\r\n	ans.ans = max(max(a.ans, b.ans), a.rx + b.lx);\r\n	ans.lx = max(a.lx, a.s + b.lx);\r\n	ans.rx = max(b.rx, b.s + a.rx);\r\n	if (l > mid) ans.lx = max(ans.lx, b.lx);\r\n	if (r <= mid) ans.rx = max(ans.rx, a.rx);\r\n	return ans;\r\n}\r\n\r\nint main() {\r\n	cin >> n >> m;\r\n	for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\r\n	build(1, 1, n);\r\n	while (m--) {\r\n		int t, x, y;\r\n		scanf(\"%d %d %d\", &t, &x, &y);\r\n		if (t == 1) {\r\n			if (x > y) swap(x, y);\r\n			cout << ask(1, x, y).ans << endl;\r\n		}\r\n		else change(1, x, y);\r\n	}\r\n	return 0;\r\n}'),(1032,'#include<bits/stdc++.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n    cout<<\"Hello World!\";\r\n    return 0;\r\n}'),(1033,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nconst int maxn=50010;\r\nint n,d[16*maxn],lmax[16*maxn],rmax[16*maxn],vmax[16*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build(n<<1|1,mid+1,r);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nsigned main(){\r\n    cin>>n>>q;\r\n    for(int i=1;i<=n;i++) cin>>a[i];\r\n	build(1,1,n);\r\n    while(q--){\r\n        int op;\r\n        cin>>op;\r\n        if(op==2){\r\n            int id,x;\r\n            cin>>id>>x;\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n        	cin>>ql>>qr;\r\n        	if(ql>qr) swap(ql,qr);\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1034,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nconst int maxn=50010;\r\nint n,d[16*maxn],lmax[16*maxn],rmax[16*maxn],vmax[16*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build((n<<1)|1,mid+1,r);\r\n    d[n]=d[(n<<1)]+d[(n<<1)|1];\r\n    lmax[n]=max(lmax[(n<<1)],d[(n<<1)]+lmax[(n<<1)|1]);\r\n    rmax[n]=max(rmax[(n<<1)|1],d[(n<<1)|1]+rmax[(n<<1)]);\r\n    vmax[n]=max(vmax[(n<<1)],max(vmax[(n<<1)|1],rmax[(n<<1)]+lmax[(n<<1)|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[(n<<1)]+d[(n<<1)|1];\r\n    lmax[n]=max(lmax[(n<<1)],d[(n<<1)]+lmax[(n<<1)|1]);\r\n    rmax[n]=max(rmax[(n<<1)|1],d[(n<<1)|1]+rmax[(n<<1)]);\r\n    vmax[n]=max(vmax[(n<<1)],max(vmax[(n<<1)|1],rmax[(n<<1)]+lmax[(n<<1)|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nsigned main(){\r\n    cin>>n>>q;\r\n    for(int i=1;i<=n;i++) cin>>a[i];\r\n	build(1,1,n);\r\n    while(q--){\r\n        int op;\r\n        cin>>op;\r\n        if(op==2){\r\n            int id,x;\r\n            cin>>id>>x;\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n        	cin>>ql>>qr;\r\n        	if(ql>qr) swap(ql,qr);\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1035,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nconst int maxn=500010;\r\nint n,d[4*maxn],lmax[4*maxn],rmax[4*maxn],vmax[4*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build((n<<1)|1,mid+1,r);\r\n    d[n]=d[(n<<1)]+d[(n<<1)|1];\r\n    lmax[n]=max(lmax[(n<<1)],d[(n<<1)]+lmax[(n<<1)|1]);\r\n    rmax[n]=max(rmax[(n<<1)|1],d[(n<<1)|1]+rmax[(n<<1)]);\r\n    vmax[n]=max(vmax[(n<<1)],max(vmax[(n<<1)|1],rmax[(n<<1)]+lmax[(n<<1)|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[(n<<1)]+d[(n<<1)|1];\r\n    lmax[n]=max(lmax[(n<<1)],d[(n<<1)]+lmax[(n<<1)|1]);\r\n    rmax[n]=max(rmax[(n<<1)|1],d[(n<<1)|1]+rmax[(n<<1)]);\r\n    vmax[n]=max(vmax[(n<<1)],max(vmax[(n<<1)|1],rmax[(n<<1)]+lmax[(n<<1)|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nsigned main(){\r\n    cin>>n>>q;\r\n    for(int i=1;i<=n;i++) cin>>a[i];\r\n	build(1,1,n);\r\n    while(q--){\r\n        int op;\r\n        cin>>op;\r\n        if(op==2){\r\n            int id,x;\r\n            cin>>id>>x;\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n        	cin>>ql>>qr;\r\n        	if(ql>qr) swap(ql,qr);\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1036,'#include<bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nint n, m, aa[50005];\r\nstruct segtree{\r\n	int l, r, lsum, rsum, sum, asum;\r\n}a[200005];\r\nvoid build(int i, int l, int r){\r\n	a[i].l=l, a[i].r=r;\r\n	if(l==r){\r\n		a[i].lsum=a[i].rsum=a[i].sum=a[i].asum=aa[l];\r\n		return;\r\n	}\r\n	int mid=(l+r)>>1;\r\n	build(i*2, l, mid);\r\n	build(i*2+1, mid+1, r);\r\n	a[i].asum=a[i*2].asum+a[i*2+1].asum;\r\n	a[i].lsum=max(a[i*2].lsum,a[i*2].asum+a[i*2+1].lsum);\r\n	a[i].rsum=max(a[i*2+1].rsum,a[i*2+1].asum+a[i*2].rsum);\r\n	a[i].sum=max(a[i*2].sum,max(a[i*2+1].sum,a[i*2].rsum+a[i*2+1].lsum));\r\n} \r\nsegtree ask(int i,int l, int r){\r\n	if(l<=a[i].l&&r>=a[i].r)return a[i];\r\n	segtree aa, b, ans;\r\n	aa.asum=aa.lsum=aa.rsum=aa.sum=-1e18;\r\n	b.asum=b.lsum=b.rsum=b.sum=-1e18;\r\n	ans.sum=0;\r\n	int x=a[i].l+a[i].r;\r\n	int mid=x>>1;\r\n	if(l<=mid){aa=ask(i*2, l, r);ans.sum+=aa.sum;}\r\n	if(r>mid){b=ask(i*2+1, l, r);ans.sum+=b.sum;}\r\n    ans.sum=max(max(aa.sum, b.sum), aa.rsum+b.lsum);\r\n    ans.lsum=max(aa.lsum,aa.sum+b.lsum);\r\n    ans.rsum=max(b.rsum,b.sum+aa.rsum);\r\n    if(l>mid)ans.lsum=max(ans.lsum, b.lsum);\r\n    if(r<=mid)ans.rsum=max(ans.rsum, aa.rsum);\r\n    return ans;\r\n}\r\nvoid update(int i, int x, int y){\r\n	if(a[i].l==a[i].r&&a[i].r==x){\r\n		a[i].asum=a[i].lsum=a[i].rsum=a[i].sum=y;\r\n		return;\r\n	}\r\n	if(a[i].l>x||a[i].r<x)return;\r\n	update(i*2, x, y);\r\n	update(i*2+1, x, y);\r\n	a[i].asum=a[i*2].asum+a[i*2+1].asum;\r\n	a[i].lsum=max(a[i*2].lsum, a[i*2].asum+a[i*2+1].lsum);\r\n	a[i].rsum=max(a[i*2+1].rsum, a[i*2+1].asum+a[i*2].rsum);\r\n	a[i].sum=max(a[i*2].sum,max(a[i*2+1].sum,a[i*2].rsum+a[i*2+1].lsum));\r\n}\r\nsigned main()\r\n{\r\n	ios::sync_with_stdio(0);\r\n	cin.tie(0);\r\n	cout.tie(0);\r\n	cin>>n;\r\n	for(int i=1; i<=n; i++)cin>>aa[i];\r\n	cin>>m;\r\n	build(1, 1, n);\r\n	while(m--){\r\n		int op, x, y;\r\n		cin>>op>>x>>y;\r\n		if(op)cout<<ask(1, x, y).sum<<endl;\r\n		else{\r\n			aa[x]=y;\r\n			update(1, x, y);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\n'),(1037,'#include<bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nint n, m, aa[50005];\r\nstruct segtree{\r\n	int l, r, lsum, rsum, sum, asum;\r\n}a[200005];\r\nvoid build(int i, int l, int r){\r\n	a[i].l=l, a[i].r=r;\r\n	if(l==r){\r\n		a[i].lsum=a[i].rsum=a[i].sum=a[i].asum=aa[l];\r\n		return;\r\n	}\r\n	int mid=(l+r)>>1;\r\n	build(i*2, l, mid);\r\n	build(i*2+1, mid+1, r);\r\n	a[i].asum=a[i*2].asum+a[i*2+1].asum;\r\n	a[i].lsum=max(a[i*2].lsum,a[i*2].asum+a[i*2+1].lsum);\r\n	a[i].rsum=max(a[i*2+1].rsum,a[i*2+1].asum+a[i*2].rsum);\r\n	a[i].sum=max(a[i*2].sum,max(a[i*2+1].sum,a[i*2].rsum+a[i*2+1].lsum));\r\n} \r\nsegtree ask(int i,int l, int r){\r\n	if(l<=a[i].l&&r>=a[i].r)return a[i];\r\n	segtree aa, b, ans;\r\n	aa.asum=aa.lsum=aa.rsum=aa.sum=-1e18;\r\n	b.asum=b.lsum=b.rsum=b.sum=-1e18;\r\n	ans.asum=0;\r\n	int mid=(a[i].l+a[i].r)>>1;\r\n	if(l<=mid){aa=ask(i*2, l, r);ans.asum+=aa.asum;}\r\n	if(r>mid){b=ask(i*2+1, l, r);ans.asum+=b.asum;}\r\n    ans.sum=max(max(aa.sum, b.sum), aa.rsum+b.lsum);\r\n    ans.lsum=max(aa.lsum,aa.asum+b.lsum);\r\n    ans.rsum=max(b.rsum,b.asum+aa.rsum);\r\n    if(l>mid)ans.lsum=max(ans.lsum, b.lsum);\r\n    if(r<=mid)ans.rsum=max(ans.rsum, aa.rsum);\r\n    return ans;\r\n}\r\nvoid update(int i, int x, int y){\r\n	if(a[i].l==a[i].r&&a[i].r==x){\r\n		a[i].asum=a[i].lsum=a[i].rsum=a[i].sum=y;\r\n		return;\r\n	}\r\n	if(a[i].l>x||a[i].r<x)return;\r\n	update(i*2, x, y);\r\n	update(i*2+1, x, y);\r\n	a[i].asum=a[i*2].asum+a[i*2+1].asum;\r\n	a[i].lsum=max(a[i*2].lsum, a[i*2].asum+a[i*2+1].lsum);\r\n	a[i].rsum=max(a[i*2+1].rsum, a[i*2+1].asum+a[i*2].rsum);\r\n	a[i].sum=max(a[i*2].sum,max(a[i*2+1].sum,a[i*2].rsum+a[i*2+1].lsum));\r\n}\r\nsigned main()\r\n{\r\n	ios::sync_with_stdio(0);\r\n	cin.tie(0);\r\n	cout.tie(0);\r\n	cin>>n;\r\n	for(int i=1; i<=n; i++)cin>>aa[i];\r\n	cin>>m;\r\n	build(1, 1, n);\r\n	while(m--){\r\n		int op, x, y;\r\n		cin>>op>>x>>y;\r\n		if(op)cout<<ask(1, x, y).sum<<endl;\r\n		else{\r\n			aa[x]=y;\r\n			update(1, x, y);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\n'),(1038,'#include<bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nint n, m, aa[500005];\r\nstruct segtree{\r\n	int l, r, lsum, rsum, sum, asum;\r\n}a[2000005];\r\nvoid build(int i, int l, int r){\r\n	a[i].l=l, a[i].r=r;\r\n	if(l==r){\r\n		a[i].lsum=a[i].rsum=a[i].sum=a[i].asum=aa[l];\r\n		return;\r\n	}\r\n	int mid=(l+r)>>1;\r\n	build(i*2, l, mid);\r\n	build(i*2+1, mid+1, r);\r\n	a[i].asum=a[i*2].asum+a[i*2+1].asum;\r\n	a[i].lsum=max(a[i*2].lsum,a[i*2].asum+a[i*2+1].lsum);\r\n	a[i].rsum=max(a[i*2+1].rsum,a[i*2+1].asum+a[i*2].rsum);\r\n	a[i].sum=max(a[i*2].sum,max(a[i*2+1].sum,a[i*2].rsum+a[i*2+1].lsum));\r\n} \r\nsegtree ask(int i,int l, int r){\r\n	if(l<=a[i].l&&r>=a[i].r)return a[i];\r\n	segtree aa, b, ans;\r\n	aa.asum=aa.lsum=aa.rsum=aa.sum=-1e18;\r\n	b.asum=b.lsum=b.rsum=b.sum=-1e18;\r\n	ans.asum=0;\r\n	int mid=(a[i].l+a[i].r)>>1;\r\n	if(l<=mid){aa=ask(i*2, l, r);ans.asum+=aa.asum;}\r\n	if(r>mid){b=ask(i*2+1, l, r);ans.asum+=b.asum;}\r\n    ans.sum=max(max(aa.sum, b.sum), aa.rsum+b.lsum);\r\n    ans.lsum=max(aa.lsum,aa.asum+b.lsum);\r\n    ans.rsum=max(b.rsum,b.asum+aa.rsum);\r\n    if(l>mid)ans.lsum=max(ans.lsum, b.lsum);\r\n    if(r<=mid)ans.rsum=max(ans.rsum, aa.rsum);\r\n    return ans;\r\n}\r\nvoid update(int i, int x, int y){\r\n	if(a[i].l==a[i].r&&a[i].r==x){\r\n		a[i].asum=a[i].lsum=a[i].rsum=a[i].sum=y;\r\n		return;\r\n	}\r\n	if(a[i].l>x||a[i].r<x)return;\r\n	update(i*2, x, y);\r\n	update(i*2+1, x, y);\r\n	a[i].asum=a[i*2].asum+a[i*2+1].asum;\r\n	a[i].lsum=max(a[i*2].lsum, a[i*2].asum+a[i*2+1].lsum);\r\n	a[i].rsum=max(a[i*2+1].rsum, a[i*2+1].asum+a[i*2].rsum);\r\n	a[i].sum=max(a[i*2].sum,max(a[i*2+1].sum,a[i*2].rsum+a[i*2+1].lsum));\r\n}\r\nsigned main()\r\n{\r\n	ios::sync_with_stdio(0);\r\n	cin.tie(0);\r\n	cout.tie(0);\r\n	cin>>n;\r\n	for(int i=1; i<=n; i++)cin>>aa[i];\r\n	cin>>m;\r\n	build(1, 1, n);\r\n	while(m--){\r\n		int op, x, y;\r\n		cin>>op>>x>>y;\r\n		if(op)cout<<ask(1, x, y).sum<<endl;\r\n		else{\r\n			aa[x]=y;\r\n			update(1, x, y);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\n'),(1039,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nconst int N=15004,M=40004;\r\nint m,n,book[N],x[M],A[N],B[N],C[N],D[N];\r\nint main()\r\n{\r\n	cin >> m >> n;\r\n	for(int i=1;i<=n;i++)\r\n		cin >> x[i],book[x[i]]++;\r\n	for(int t=1;t*9<m;t++)\r\n	{\r\n		int sum=0;\r\n		for(int d=9*t+2;d<=m;d++)\r\n		{\r\n			int c=d-t,b=d-7*t-1,a=b-2*t;\r\n			sum+=book[a]*book[b];\r\n			D[d]+=book[c]*sum;\r\n			C[c]+=book[d]*sum;\r\n		}\r\n		sum=0;\r\n		for(int a=m-9*t-1;a;a--)\r\n		{\r\n			int b=a+2*t,c=b+6*t+1,d=c+t;\r\n			sum+=book[c]*book[d];\r\n			A[a]+=book[b]*sum;\r\n			B[b]+=book[a]*sum;\r\n		}\r\n	}\r\n	for(int i=1;i<=n;i++)\r\n		cout << A[x[i]] << \' \' << B[x[i]] << \' \' << C[x[i]] << \' \' << D[x[i]] << endl;\r\n	return 0;\r\n}'),(1040,'#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint a[15005],b[15005],c[15005],d[15005],w[15005],h[40005],n,m,x,y;\r\n\r\nint main()\r\n{\r\n	cin>>n>>m;\r\n	if(n<11)\r\n	{\r\n		for(int i=1;i<=m;i++)\r\n		    printf(\"0 0 0 0\\n\");\r\n		return 0;\r\n	}\r\n	for(int i=1;i<=m;i++)\r\n	{\r\n	    cin>>h[i];\r\n		w[h[i]]++;\r\n	}\r\n	for(int i=1;i<=n/9;i++)\r\n	{\r\n		x=1+9*i,y=0;\r\n		for(int j=2+9*i;j<=n;j++)\r\n		{\r\n		\r\n			y+=w[j-x]*w[j-x+i+i];\r\n			d[j]+=y*w[j-i];\r\n			c[j-i]+=y*w[j];\r\n		}\r\n		x=8*i+1,y=0;\r\n		for(int j=n-9*i-1;j>=1;j--)\r\n		{\r\n			y+=w[j+x]*w[j+x+i];\r\n			a[j]+=y*w[j+i+i];\r\n			b[j+i+i]+=y*w[j];\r\n		}\r\n	}\r\n	for(int i=1;i<=m;i++)\r\n		cout<<a[h[i]]<<\' \'<<b[h[i]]<<\' \'<<c[h[i]]<<\' \'<<d[h[i]]<<endl;\r\n}'),(1041,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// Template by xcx0902\r\n// Copyright 2022\r\n\r\n#define int long long\r\n\r\nbool ismulti = false;\r\n\r\n// Pair cin & cout\r\n\r\ntemplate <typename tp1, typename tp2>\r\nistream& operator >> (istream &in, pair<tp1, tp2> &p) {\r\n	in >> p.first >> p.second;\r\n	return in;\r\n}\r\n\r\ntemplate <typename tp1, typename tp2>\r\nostream& operator << (ostream &out, const pair<tp1, tp2> &p) {\r\n	out << p.first << \" \" << p.second;\r\n	out.flush();\r\n	return out;\r\n}\r\n\r\n// Read & Write\r\n\r\ntemplate <typename type>\r\nvoid read(type a[], int ed, int st = 1) {\r\n	for (int i = st; i <= ed; i++)\r\n		cin >> a[i];\r\n}\r\n\r\ntemplate <typename type>\r\nvoid read(vector<type> &v, int sz = 0) {\r\n	if(sz) v.resize(sz);\r\n	for (auto &p: v)\r\n		cin >> p;\r\n}\r\n\r\ntemplate <typename type>\r\nistream& operator >> (istream &in, vector<type> &v) {\r\n	for (auto &p: v)\r\n		in >> p;\r\n	return in;\r\n}\r\n\r\ntemplate <typename type>\r\nvoid write(type a[], int ed, int st = 1, string sep = \" \", string last = \"\\n\") {\r\n	for (int i = st; i <= ed; i++)\r\n		cout << a[i] << (i != ed? sep: last);\r\n	cout.flush();\r\n}\r\n\r\ntemplate <typename type>\r\nvoid write(vector<type> v, string sep = \" \", string last = \"\\n\") {\r\n	for (int i = 0; i < v.size(); i++)\r\n		cout << v[i] << (i != v.size() - 1? sep: last);\r\n	cout.flush();\r\n}\r\n\r\ntemplate <typename type>\r\nostream& operator << (ostream &out, const vector<type> &v) {\r\n	for (auto p: v)\r\n		out << p << \" \";\r\n	out.flush();\r\n	return out;\r\n}\r\n\r\n// Some Functions\r\n\r\nint gcd(int a, int b) {\r\n	return !b? a: gcd(b, a % b);\r\n}\r\n\r\nint lcm(int a, int b) {\r\n	return a * b / gcd(a, b);\r\n}\r\n\r\nint popcount(int x, int p = 2) {\r\n	int count = 0;\r\n	while(x) {\r\n		count++;\r\n		x /= p;\r\n	}\r\n	return count;\r\n}\r\n\r\nint lowbit(int x) {\r\n	return x & (-x);\r\n}\r\n\r\nint isqrt(int x) {\r\n	int l = 0, r = 3e9, ans = 0, mid;\r\n	while (l <= r) {\r\n		mid = (l + r) >> 1;\r\n		if (mid * mid <= x) l = mid + 1, ans = mid;\r\n		else r = mid - 1;\r\n	}\r\n	return ans;\r\n}\r\n\r\nint ilog2(int x) {\r\n	return popcount(x) - 1;\r\n}\r\n\r\nint ilog10(int x) {\r\n	return popcount(x, 10) - 1;\r\n}\r\n\r\nint ilogk(int x, int k) {\r\n	return popcount(x, k) - 1;\r\n}\r\n\r\nint qpow(int a, int b, int p) {\r\n	if (b == 0) return 1 % p;\r\n	if (b == 1) return a % p;\r\n	int tmp = qpow(a, b / 2, p) % p;\r\n	if (b % 2) return tmp * tmp % p * a % p;\r\n	else       return tmp * tmp % p;\r\n}\r\n\r\nint binarySearch(int l, int r, bool (*check)(int), int ans = 0) {\r\n	int mid = 0;\r\n	while (l <= r) {\r\n		mid = (l + r) >> 1;\r\n		if (check(mid)) l = mid + 1, ans = mid;\r\n		else r = mid - 1;\r\n	}\r\n	return ans;\r\n}\r\n\r\ndouble binarySearch(double l, double r, bool (*check)(double), double eps = 1e-6, double ans = 0) {\r\n	double mid = 0;\r\n	while(abs(l - r) > eps) {\r\n		mid = (l + r) / 2;\r\n		if (check(mid)) l = mid, ans = mid;\r\n		else r = mid;\r\n	}\r\n	return ans;\r\n}\r\n\r\nint getDivisor(int a[], int n, int cnt = 1) {\r\n	int tmp = cnt;\r\n	for (int i = 1; i * i <= n; i++)\r\n		if (n % i == 0) {\r\n			a[cnt++] = i;\r\n			if (i * i != n)\r\n				a[cnt++] = n / i;\r\n		}\r\n	cnt--;\r\n	sort(a + tmp, a + cnt + 1);\r\n	return cnt;\r\n}\r\n\r\nint getDivisor(vector<int> &v, int n) {\r\n	for (int i = 1; i * i <= n; i++)\r\n		if (n % i == 0) {\r\n			v.push_back(i);\r\n			if (i * i != n)\r\n				v.push_back(n / i);\r\n		}\r\n	sort(v.begin(), v.end());\r\n	return v.size();\r\n}\r\n\r\n// Yes & No, Possible & Impossible, ...\r\n\r\nvoid yes(bool ex = (!ismulti)) {\r\n	cout << \"yes\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid Yes(bool ex = (!ismulti)) {\r\n	cout << \"Yes\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid YES(bool ex = (!ismulti)) {\r\n	cout << \"YES\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid no(bool ex = (!ismulti)) {\r\n	cout << \"no\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid No(bool ex = (!ismulti)) {\r\n	cout << \"No\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid NO(bool ex = (!ismulti)) {\r\n	cout << \"NO\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid yesno(bool flag, bool ex = (!ismulti)) {\r\n	if (flag) cout << \"yes\" << endl;\r\n	else cout << \"no\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid YesNo(bool flag, bool ex = (!ismulti)) {\r\n	if (flag) cout << \"Yes\" << endl;\r\n	else cout << \"No\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid YESNO(bool flag, bool ex = (!ismulti)) {\r\n	if (flag) cout << \"YES\" << endl;\r\n	else cout << \"NO\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\n// Some data structures\r\n\r\nclass DJU {\r\n	private :\r\n		std::vector<unsigned> f, sz;\r\n	public :\r\n		DJU() {\r\n		}\r\n		DJU(unsigned _sz) {\r\n			f = sz = std::vector<unsigned> (_sz + 1);\r\n			for (unsigned i = 1; i <= _sz; i++)\r\n				f[i] = i, sz[i] = 1;\r\n		}\r\n		unsigned find(unsigned x) {\r\n			if (f[x] == x) return x;\r\n			return f[x] = find(f[x]);\r\n		}\r\n		bool same(unsigned x, unsigned y) {\r\n			if (find(x) == find(y)) return true;\r\n			else return false;\r\n		}\r\n		void merge(unsigned x, unsigned y) {\r\n			unsigned fx = find(x);\r\n			unsigned fy = find(y);\r\n			f[fx] = fy;\r\n			sz[fy] += sz[fx];\r\n		}\r\n		unsigned size(unsigned x) {\r\n			return sz[find(x)];\r\n		}\r\n};\r\n\r\ntemplate <typename tp>\r\nclass BIT {\r\n	private :\r\n		vector<tp> c; // from 1 to N\r\n		unsigned sz;\r\n		unsigned lowbit(unsigned x) {\r\n			return x & (-x);\r\n		}\r\n\r\n	public :\r\n		BIT() {\r\n		}\r\n		BIT(unsigned _sz) {\r\n			c = vector<tp> (_sz + 1);\r\n			sz= _sz;\r\n		}\r\n		tp getsum(unsigned dx) { // return sum of [1..dx]\r\n			tp ret = 0;\r\n			while(dx) {\r\n				ret += c[dx];\r\n				dx -= lowbit(dx);\r\n			}\r\n			return ret;\r\n		}\r\n		tp sum(unsigned l,unsigned r) { // return sum of [l..r]\r\n			return getsum(r) - getsum(l - 1);\r\n		}\r\n		tp get(unsigned dx) { // return value[dx]\r\n			return sum(dx,dx);\r\n		}\r\n		tp add(unsigned dx,tp val) { // return after add\r\n			unsigned tmp = dx;\r\n			while(dx <= sz) {\r\n				c[dx] += val;\r\n				dx += lowbit(dx);\r\n			}\r\n			return c[tmp];\r\n		}\r\n		tp change(unsigned dx,tp val) { // return after change\r\n			return add(dx,val - get(dx));\r\n		}\r\n};\r\n\r\ntemplate <typename tp>\r\nclass unauthorizedGraph {\r\n	private :\r\n		unsigned sz;\r\n	public :\r\n		vector<vector<tp> > gv;\r\n		vector<tp>& operator [] (unsigned x) {\r\n			return gv[x];\r\n		}\r\n		unauthorizedGraph() {\r\n		}\r\n		~unauthorizedGraph() {\r\n			sz = 0;\r\n			gv.resize(0);\r\n		}\r\n		unauthorizedGraph(unsigned _sz) {\r\n			sz = _sz;\r\n			gv.resize(_sz + 1);\r\n		}\r\n		void readGraph(unsigned n, unsigned m, bool directed = false) {\r\n			sz = n;\r\n			gv.resize(n + 1);\r\n			for (int i = 1; i <= m; i++) {\r\n				tp u, v;\r\n				cin >> u >> v;\r\n				gv[u].push_back(v);\r\n				if (directed == false)\r\n					gv[v].push_back(u);\r\n			}\r\n		}\r\n};\r\n\r\ntemplate <typename tp, typename tpw>\r\nclass authorizedGraph {\r\n	private :\r\n		unsigned sz;\r\n	public :\r\n		vector<vector<pair<tp, tpw> > > gv;\r\n		vector<pair<tp, tpw> >& operator [] (unsigned x) {\r\n			return gv[x];\r\n		}\r\n		authorizedGraph() {\r\n		}\r\n		~authorizedGraph() {\r\n			sz = 0;\r\n			gv.resize(0);\r\n		}\r\n		authorizedGraph(unsigned _sz) {\r\n			sz = _sz;\r\n			gv.resize(_sz + 1);\r\n		}\r\n		void readGraph(unsigned n, unsigned m, bool directed = false) {\r\n			sz = n;\r\n			gv.resize(n + 1);\r\n			for (int i = 1; i <= m; i++) {\r\n				tp u, v; tpw w;\r\n				cin >> u >> v >> w;\r\n				gv[u].push_back(make_pair(v, w));\r\n				if (directed == false)\r\n					gv[v].push_back(make_pair(u, w));\r\n			}\r\n		}\r\n};\r\n\r\nclass inverseElement {\r\n	private :\r\n		unsigned n;\r\n		int p;\r\n		vector<int> fac;\r\n		void getFactorial(unsigned L, unsigned R, int P) {\r\n			if (n >= R) return;\r\n			n = R;\r\n			fac.resize(n + 1);\r\n			fac[0] = 1;\r\n			for (unsigned i = L; i <= R; i++)\r\n				fac[i] = fac[i - 1] * i % P;\r\n		}\r\n	public :\r\n		inverseElement() {\r\n		}\r\n		inverseElement(int P) {\r\n			p = P;\r\n		}\r\n		int C(unsigned N, unsigned M, int P = 0) {\r\n			if (P == 0) P = p;\r\n			if (M > N) throw \"M cannot be greater than N!\";\r\n			if (n < N) getFactorial(n + 1, N, P);\r\n			return fac[N] * qpow(fac[M], P - 2 , P) % P * qpow(fac[N - M], P - 2, P) % P;\r\n		}\r\n		int A(unsigned N, unsigned M, int P = 0) {\r\n			if (P == 0) P = p;\r\n			if (M > N) throw \"M cannot be greater than N!\";\r\n			if (n < N) getFactorial(n + 1, N, P);\r\n			return C(N, M, P) * fac[M] % P;\r\n		}\r\n};\r\n\r\n// Some Consts\r\n\r\nconst int INF = 0x3f3f3f3f;\r\nconst int LONGINF = 0x3f3f3f3f3f3f3f3f;\r\nconst int MOD1 = 1e9 + 7;\r\nconst int MOD2 = 998244353;\r\nconst double PI = acos(-1.0);\r\nconst double E = 2.718281828;\r\nconst double PHI = (sqrt(5.0) - 1) / 2.0;\r\n\r\n// Some defines\r\n\r\ntypedef unsigned uint;\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef pair<int, int> pii;\r\ntypedef pair<pii, int> ppiii;\r\ntypedef pair<int, pii> pipii;\r\ntypedef vector<int> vi;\r\ntypedef vector<pii> vpii;\r\ntypedef vector<ppiii> vppiii;\r\ntypedef vector<pipii> vpipii;\r\ntypedef map<int, int> mii;\r\ntypedef map<int, vi> mivi;\r\ntypedef map<int, pii> mipii;\r\ntypedef map<pii, int> mpiii;\r\ntypedef map<char, int> mci;\r\ntypedef set<int> si;\r\ntypedef set<string> ss;\r\ntypedef set<pii> spii;\r\ntypedef set<ppiii> sppiii;\r\ntypedef set<pipii> spipii;\r\n\r\n#define forn(_i_, _a_, _b_) for (int _i_ = _a_; _i_ <= _b_; _i_++)\r\n#define nrof(_i_, _a_, _b_) for (int _i_ = _a_; _i_ >= _b_; _i_--)\r\n#define ncinn int n; cin >> n\r\n#define intcin(_name_) int _name_; cin >> _name_\r\n#define nmcin int n, m; cin >> n >> m\r\n#define acina int a[n+5]; read(a, n, 1)\r\n#define bcinb int b[n+5]; read(b, n, 1)\r\n#define intarrcin(_name_, _size_) int _name_[_size_+5]; read(_name_, _size_, 1)\r\n#define vcinv vector<int> v; read(v, n)\r\n#define vicin(_name_, _size_) vector<int> _name_; read(_name_, _size_)\r\n#define lrcin int l, r; cin >> l >> r\r\n#define xycin int x, y; cin >> x >> y\r\n#define int2cin(_name1_, _name2_) int _name1_, _name2_; cin >> _name1_ >> _name2_\r\n#define couta write(a, n, 1)\r\n#define coutarr(_name_, _size_) write(_name_, _size_, 1)\r\n#define coutv write(v)\r\n#define coutvec(_name_) write(_name_)\r\n#define setmulti ismulti = true\r\n#define multi setmulti; int _; cin >> _; while(_--)\r\n/*\r\nUse multi as:\r\nmulti {\r\n	// ...\r\n}\r\n*/\r\n\r\n// End of Template\r\n\r\n#define a(__x__) arr[__x__].a\r\n#define s(__x__) arr[__x__].s\r\nconst int N = 100001;\r\nint n, sum[N], premax[N], sufmax[N]; \r\nstruct node {\r\n	int a, s;\r\n	bool operator < (node b) const {\r\n		return a > b.a;\r\n	}\r\n};\r\nnode arr[N]; \r\nsigned main() {\r\n	ios::sync_with_stdio(false);\r\n	cin.tie(nullptr); cout.tie(nullptr);\r\n	cin >> n;\r\n	forn (i, 1, n) cin >> s(i);\r\n	forn (i, 1, n) cin >> a(i);\r\n	sort(arr + 1, arr + n + 1);\r\n	forn (i, 1, n) sum[i] = sum[i - 1] + a(i);\r\n	forn (i, 1, n) premax[i] = max(premax[i - 1], s(i) * 2);\r\n	nrof (i, n, 1) sufmax[i] = max(sufmax[i + 1], 2 * s(i) + a(i));\r\n	forn (i, 1, n) cout << max(sum[i] + premax[i], sum[i - 1] + sufmax[i]) << endl;\r\n	return 0;\r\n}\r\n'),(1042,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// Template by xcx0902\r\n// Copyright 2022\r\n\r\n#define int long long\r\n\r\nbool ismulti = false;\r\n\r\n// Pair cin & cout\r\n\r\ntemplate <typename tp1, typename tp2>\r\nistream& operator >> (istream &in, pair<tp1, tp2> &p) {\r\n	in >> p.first >> p.second;\r\n	return in;\r\n}\r\n\r\ntemplate <typename tp1, typename tp2>\r\nostream& operator << (ostream &out, const pair<tp1, tp2> &p) {\r\n	out << p.first << \" \" << p.second;\r\n	out.flush();\r\n	return out;\r\n}\r\n\r\n// Read & Write\r\n\r\ntemplate <typename type>\r\nvoid read(type a[], int ed, int st = 1) {\r\n	for (int i = st; i <= ed; i++)\r\n		cin >> a[i];\r\n}\r\n\r\ntemplate <typename type>\r\nvoid read(vector<type> &v, int sz = 0) {\r\n	if(sz) v.resize(sz);\r\n	for (auto &p: v)\r\n		cin >> p;\r\n}\r\n\r\ntemplate <typename type>\r\nistream& operator >> (istream &in, vector<type> &v) {\r\n	for (auto &p: v)\r\n		in >> p;\r\n	return in;\r\n}\r\n\r\ntemplate <typename type>\r\nvoid write(type a[], int ed, int st = 1, string sep = \" \", string last = \"\\n\") {\r\n	for (int i = st; i <= ed; i++)\r\n		cout << a[i] << (i != ed? sep: last);\r\n	cout.flush();\r\n}\r\n\r\ntemplate <typename type>\r\nvoid write(vector<type> v, string sep = \" \", string last = \"\\n\") {\r\n	for (int i = 0; i < v.size(); i++)\r\n		cout << v[i] << (i != v.size() - 1? sep: last);\r\n	cout.flush();\r\n}\r\n\r\ntemplate <typename type>\r\nostream& operator << (ostream &out, const vector<type> &v) {\r\n	for (auto p: v)\r\n		out << p << \" \";\r\n	out.flush();\r\n	return out;\r\n}\r\n\r\n// Some Functions\r\n\r\nint gcd(int a, int b) {\r\n	return !b? a: gcd(b, a % b);\r\n}\r\n\r\nint lcm(int a, int b) {\r\n	return a * b / gcd(a, b);\r\n}\r\n\r\nint popcount(int x, int p = 2) {\r\n	int count = 0;\r\n	while(x) {\r\n		count++;\r\n		x /= p;\r\n	}\r\n	return count;\r\n}\r\n\r\nint lowbit(int x) {\r\n	return x & (-x);\r\n}\r\n\r\nint isqrt(int x) {\r\n	int l = 0, r = 3e9, ans = 0, mid;\r\n	while (l <= r) {\r\n		mid = (l + r) >> 1;\r\n		if (mid * mid <= x) l = mid + 1, ans = mid;\r\n		else r = mid - 1;\r\n	}\r\n	return ans;\r\n}\r\n\r\nint ilog2(int x) {\r\n	return popcount(x) - 1;\r\n}\r\n\r\nint ilog10(int x) {\r\n	return popcount(x, 10) - 1;\r\n}\r\n\r\nint ilogk(int x, int k) {\r\n	return popcount(x, k) - 1;\r\n}\r\n\r\nint qpow(int a, int b, int p) {\r\n	if (b == 0) return 1 % p;\r\n	if (b == 1) return a % p;\r\n	int tmp = qpow(a, b / 2, p) % p;\r\n	if (b % 2) return tmp * tmp % p * a % p;\r\n	else       return tmp * tmp % p;\r\n}\r\n\r\nint binarySearch(int l, int r, bool (*check)(int), int ans = 0) {\r\n	int mid = 0;\r\n	while (l <= r) {\r\n		mid = (l + r) >> 1;\r\n		if (check(mid)) l = mid + 1, ans = mid;\r\n		else r = mid - 1;\r\n	}\r\n	return ans;\r\n}\r\n\r\ndouble binarySearch(double l, double r, bool (*check)(double), double eps = 1e-6, double ans = 0) {\r\n	double mid = 0;\r\n	while(abs(l - r) > eps) {\r\n		mid = (l + r) / 2;\r\n		if (check(mid)) l = mid, ans = mid;\r\n		else r = mid;\r\n	}\r\n	return ans;\r\n}\r\n\r\nint getDivisor(int a[], int n, int cnt = 1) {\r\n	int tmp = cnt;\r\n	for (int i = 1; i * i <= n; i++)\r\n		if (n % i == 0) {\r\n			a[cnt++] = i;\r\n			if (i * i != n)\r\n				a[cnt++] = n / i;\r\n		}\r\n	cnt--;\r\n	sort(a + tmp, a + cnt + 1);\r\n	return cnt;\r\n}\r\n\r\nint getDivisor(vector<int> &v, int n) {\r\n	for (int i = 1; i * i <= n; i++)\r\n		if (n % i == 0) {\r\n			v.push_back(i);\r\n			if (i * i != n)\r\n				v.push_back(n / i);\r\n		}\r\n	sort(v.begin(), v.end());\r\n	return v.size();\r\n}\r\n\r\n// Yes & No, Possible & Impossible, ...\r\n\r\nvoid yes(bool ex = (!ismulti)) {\r\n	cout << \"yes\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid Yes(bool ex = (!ismulti)) {\r\n	cout << \"Yes\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid YES(bool ex = (!ismulti)) {\r\n	cout << \"YES\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid no(bool ex = (!ismulti)) {\r\n	cout << \"no\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid No(bool ex = (!ismulti)) {\r\n	cout << \"No\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid NO(bool ex = (!ismulti)) {\r\n	cout << \"NO\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid yesno(bool flag, bool ex = (!ismulti)) {\r\n	if (flag) cout << \"yes\" << endl;\r\n	else cout << \"no\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid YesNo(bool flag, bool ex = (!ismulti)) {\r\n	if (flag) cout << \"Yes\" << endl;\r\n	else cout << \"No\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid YESNO(bool flag, bool ex = (!ismulti)) {\r\n	if (flag) cout << \"YES\" << endl;\r\n	else cout << \"NO\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\n// Some data structures\r\n\r\nclass DJU {\r\n	private :\r\n		std::vector<unsigned> f, sz;\r\n	public :\r\n		DJU() {\r\n		}\r\n		DJU(unsigned _sz) {\r\n			f = sz = std::vector<unsigned> (_sz + 1);\r\n			for (unsigned i = 1; i <= _sz; i++)\r\n				f[i] = i, sz[i] = 1;\r\n		}\r\n		unsigned find(unsigned x) {\r\n			if (f[x] == x) return x;\r\n			return f[x] = find(f[x]);\r\n		}\r\n		bool same(unsigned x, unsigned y) {\r\n			if (find(x) == find(y)) return true;\r\n			else return false;\r\n		}\r\n		void merge(unsigned x, unsigned y) {\r\n			unsigned fx = find(x);\r\n			unsigned fy = find(y);\r\n			f[fx] = fy;\r\n			sz[fy] += sz[fx];\r\n		}\r\n		unsigned size(unsigned x) {\r\n			return sz[find(x)];\r\n		}\r\n};\r\n\r\ntemplate <typename tp>\r\nclass BIT {\r\n	private :\r\n		vector<tp> c; // from 1 to N\r\n		unsigned sz;\r\n		unsigned lowbit(unsigned x) {\r\n			return x & (-x);\r\n		}\r\n\r\n	public :\r\n		BIT() {\r\n		}\r\n		BIT(unsigned _sz) {\r\n			c = vector<tp> (_sz + 1);\r\n			sz= _sz;\r\n		}\r\n		tp getsum(unsigned dx) { // return sum of [1..dx]\r\n			tp ret = 0;\r\n			while(dx) {\r\n				ret += c[dx];\r\n				dx -= lowbit(dx);\r\n			}\r\n			return ret;\r\n		}\r\n		tp sum(unsigned l,unsigned r) { // return sum of [l..r]\r\n			return getsum(r) - getsum(l - 1);\r\n		}\r\n		tp get(unsigned dx) { // return value[dx]\r\n			return sum(dx,dx);\r\n		}\r\n		tp add(unsigned dx,tp val) { // return after add\r\n			unsigned tmp = dx;\r\n			while(dx <= sz) {\r\n				c[dx] += val;\r\n				dx += lowbit(dx);\r\n			}\r\n			return c[tmp];\r\n		}\r\n		tp change(unsigned dx,tp val) { // return after change\r\n			return add(dx,val - get(dx));\r\n		}\r\n};\r\n\r\ntemplate <typename tp>\r\nclass unauthorizedGraph {\r\n	private :\r\n		unsigned sz;\r\n	public :\r\n		vector<vector<tp> > gv;\r\n		vector<tp>& operator [] (unsigned x) {\r\n			return gv[x];\r\n		}\r\n		unauthorizedGraph() {\r\n		}\r\n		~unauthorizedGraph() {\r\n			sz = 0;\r\n			gv.resize(0);\r\n		}\r\n		unauthorizedGraph(unsigned _sz) {\r\n			sz = _sz;\r\n			gv.resize(_sz + 1);\r\n		}\r\n		void readGraph(unsigned n, unsigned m, bool directed = false) {\r\n			sz = n;\r\n			gv.resize(n + 1);\r\n			for (int i = 1; i <= m; i++) {\r\n				tp u, v;\r\n				cin >> u >> v;\r\n				gv[u].push_back(v);\r\n				if (directed == false)\r\n					gv[v].push_back(u);\r\n			}\r\n		}\r\n};\r\n\r\ntemplate <typename tp, typename tpw>\r\nclass authorizedGraph {\r\n	private :\r\n		unsigned sz;\r\n	public :\r\n		vector<vector<pair<tp, tpw> > > gv;\r\n		vector<pair<tp, tpw> >& operator [] (unsigned x) {\r\n			return gv[x];\r\n		}\r\n		authorizedGraph() {\r\n		}\r\n		~authorizedGraph() {\r\n			sz = 0;\r\n			gv.resize(0);\r\n		}\r\n		authorizedGraph(unsigned _sz) {\r\n			sz = _sz;\r\n			gv.resize(_sz + 1);\r\n		}\r\n		void readGraph(unsigned n, unsigned m, bool directed = false) {\r\n			sz = n;\r\n			gv.resize(n + 1);\r\n			for (int i = 1; i <= m; i++) {\r\n				tp u, v; tpw w;\r\n				cin >> u >> v >> w;\r\n				gv[u].push_back(make_pair(v, w));\r\n				if (directed == false)\r\n					gv[v].push_back(make_pair(u, w));\r\n			}\r\n		}\r\n};\r\n\r\nclass inverseElement {\r\n	private :\r\n		unsigned n;\r\n		int p;\r\n		vector<int> fac;\r\n		void getFactorial(unsigned L, unsigned R, int P) {\r\n			if (n >= R) return;\r\n			n = R;\r\n			fac.resize(n + 1);\r\n			fac[0] = 1;\r\n			for (unsigned i = L; i <= R; i++)\r\n				fac[i] = fac[i - 1] * i % P;\r\n		}\r\n	public :\r\n		inverseElement() {\r\n		}\r\n		inverseElement(int P) {\r\n			p = P;\r\n		}\r\n		int C(unsigned N, unsigned M, int P = 0) {\r\n			if (P == 0) P = p;\r\n			if (M > N) throw \"M cannot be greater than N!\";\r\n			if (n < N) getFactorial(n + 1, N, P);\r\n			return fac[N] * qpow(fac[M], P - 2 , P) % P * qpow(fac[N - M], P - 2, P) % P;\r\n		}\r\n		int A(unsigned N, unsigned M, int P = 0) {\r\n			if (P == 0) P = p;\r\n			if (M > N) throw \"M cannot be greater than N!\";\r\n			if (n < N) getFactorial(n + 1, N, P);\r\n			return C(N, M, P) * fac[M] % P;\r\n		}\r\n};\r\n\r\n// Some Consts\r\n\r\nconst int INF = 0x3f3f3f3f;\r\nconst int LONGINF = 0x3f3f3f3f3f3f3f3f;\r\nconst int MOD1 = 1e9 + 7;\r\nconst int MOD2 = 998244353;\r\nconst double PI = acos(-1.0);\r\nconst double E = 2.718281828;\r\nconst double PHI = (sqrt(5.0) - 1) / 2.0;\r\n\r\n// Some defines\r\n\r\ntypedef unsigned uint;\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef pair<int, int> pii;\r\ntypedef pair<pii, int> ppiii;\r\ntypedef pair<int, pii> pipii;\r\ntypedef vector<int> vi;\r\ntypedef vector<pii> vpii;\r\ntypedef vector<ppiii> vppiii;\r\ntypedef vector<pipii> vpipii;\r\ntypedef map<int, int> mii;\r\ntypedef map<int, vi> mivi;\r\ntypedef map<int, pii> mipii;\r\ntypedef map<pii, int> mpiii;\r\ntypedef map<char, int> mci;\r\ntypedef set<int> si;\r\ntypedef set<string> ss;\r\ntypedef set<pii> spii;\r\ntypedef set<ppiii> sppiii;\r\ntypedef set<pipii> spipii;\r\n\r\n#define forn(_i_, _a_, _b_) for (int _i_ = _a_; _i_ <= _b_; _i_++)\r\n#define nrof(_i_, _a_, _b_) for (int _i_ = _a_; _i_ >= _b_; _i_--)\r\n#define ncinn int n; cin >> n\r\n#define intcin(_name_) int _name_; cin >> _name_\r\n#define nmcin int n, m; cin >> n >> m\r\n#define acina int a[n+5]; read(a, n, 1)\r\n#define bcinb int b[n+5]; read(b, n, 1)\r\n#define intarrcin(_name_, _size_) int _name_[_size_+5]; read(_name_, _size_, 1)\r\n#define vcinv vector<int> v; read(v, n)\r\n#define vicin(_name_, _size_) vector<int> _name_; read(_name_, _size_)\r\n#define lrcin int l, r; cin >> l >> r\r\n#define xycin int x, y; cin >> x >> y\r\n#define int2cin(_name1_, _name2_) int _name1_, _name2_; cin >> _name1_ >> _name2_\r\n#define couta write(a, n, 1)\r\n#define coutarr(_name_, _size_) write(_name_, _size_, 1)\r\n#define coutv write(v)\r\n#define coutvec(_name_) write(_name_)\r\n#define setmulti ismulti = true\r\n#define multi setmulti; int _; cin >> _; while(_--)\r\n/*\r\nUse multi as:\r\nmulti {\r\n	// ...\r\n}\r\n*/\r\n\r\n// End of Template\r\n\r\n#define a(__x__) arr[__x__].a\r\n#define s(__x__) arr[__x__].s\r\nconst int N = 100001;\r\nint n, sum[N], premax[N], sufmax[N]; \r\nstruct node {\r\n	int a, s;\r\n	bool operator < (node b) const {\r\n		return a > b.a;\r\n	}\r\n};\r\nnode arr[N]; \r\nsigned main() {\r\n	ios::sync_with_stdio(false);\r\n	cin.tie(nullptr); cout.tie(nullptr);\r\n	cin >> n;\r\n	forn (i, 1, n) cin >> s(i);\r\n	forn (i, 1, n) cin >> a(i);\r\n	sort(arr + 1, arr + n + 1);\r\n	forn (i, 1, n) sum[i] = sum[i - 1] + a(i);\r\n	forn (i, 1, n) premax[i] = max(premax[i - 1], s(i) * 2);\r\n	nrof (i, n, 1) sufmax[i] = max(sufmax[i + 1], 2 * s(i) + a(i));\r\n	forn (i, 1, n) cout << max(sum[i] + premax[i], sum[i - 1] + sufmax[i]) << endl;\r\n	return 0;\r\n}\r\n'),(1043,'#include <stdio.h>\r\n#include <string.h>\r\n#define max(a,b) ((a)>(b)?(a):(b))\r\nconst int N = 1e4 + 10; //qwq\r\nconst int M = 1e3 + 10;\r\nint /*w[N],v[N],*/f[N];\r\nint p[N][N];\r\nint t, n, m;\r\nint main() {\r\n	scanf(\"%d%d%d\", &t, &n, &m);\r\n	for (int i = 1; i <= t; i++)\r\n		for (int j = 1; j <= n; j++)\r\n			scanf(\"%d\", &p[i][j]);\r\n	for (int k = 1; k < t; k++) {\r\n		memset(f, 0, sizeof f);\r\n		for (int i = 1; i <= n; i++)\r\n			for (int j = p[k][i]; j <= m; j++)\r\n				f[j] = max(f[j], f[j - p[k][i]] + p[k + 1][i] - p[k][i]);\r\n		m += f[m];\r\n		// p[2][i] - p[1][i] + p[3][i] - p[2][i] = p[3][i] - p[1][i]\r\n	}\r\n	printf(\"%d\", m);\r\n	return 0;\r\n}'),(1044,'#include <stdio.h>\r\n#include <string.h>\r\n#define max(a,b) ((a)>(b)?(a):(b))\r\nconst int N=1e4+10;//qwq\r\nconst int M=1e3+10;\r\nint /*w[N],v[N],*/f[N];\r\nint p[N][N];\r\nint t,n,m;\r\nint main()\r\n{\r\n	scanf(\"%d%d%d\",&t,&n,&m);\r\n	for(int i=1;i<=t;i++)\r\n		for(int j=1;j<=n;j++)\r\n			scanf(\"%d\",&p[i][j]);\r\n	for(int k=1;k<t;k++)\r\n	{\r\n		memset(f,0,sizeof f); \r\n		for(int i=1;i<=n;i++)\r\n			for(int j=p[k][i];j<=m;j++)\r\n				f[j]=max(f[j],f[j-p[k][i]]+p[k+1][i]-p[k][i]);\r\n		m+=f[m];\r\n	}\r\n	printf(\"%d\",m);\r\n	return 0;\r\n}'),(1045,'#include <stdio.h>\r\n#include <string.h>\r\n#define max(a,b) ((a)>(b)?(a):(b))\r\nconst int N=1e4+10;//qwq\r\nconst int M=1e3+10;\r\nint /*w[N],v[N],*/f[N];\r\nint p[N][N];\r\nint t,n,m;\r\nint main()\r\n{\r\n	scanf(\"%d%d%d\",&t,&n,&m);\r\n	for(int i=1;i<=t;i++)\r\n		for(int j=1;j<=n;j++)\r\n			scanf(\"%d\",&p[i][j]);\r\n	for(int k=1;k<t;k++)\r\n	{\r\n		memset(f,0,sizeof f); \r\n		for(int i=1;i<=n;i++)\r\n			for(int j=p[k][i];j<=m;j++)\r\n				f[j]=max(f[j],f[j-p[k][i]]+p[k+1][i]-p[k][i]);\r\n		m+=f[m];\r\n	}\r\n	printf(\"%d\",m);\r\n	return 0;\r\n}'),(1046,'#include <stdio.h>\r\n#include <string.h>\r\n#define max(a,b) ((a)>(b)?(a):(b))\r\nconst int N=1e4+10;//qwq\r\nconst int M=1e3+10;\r\nint /*w[N],v[N],*/f[N];\r\nint p[N][N];\r\nint t,n,m;\r\nint main()\r\n{\r\n	scanf(\"%d%d%d\",&t,&n,&m);\r\n	for(int i=1;i<=t;i++)\r\n		for(int j=1;j<=n;j++)\r\n			scanf(\"%d\",&p[i][j]);\r\n	for(int k=1;k<t;k++)\r\n	{\r\n		memset(f,0,sizeof f); \r\n		for(int i=1;i<=n;i++)\r\n			for(int j=p[k][i];j<=m;j++)\r\n				f[j]=max(f[j],f[j-p[k][i]]+p[k+1][i]-p[k][i]);\r\n		m+=f[m];\r\n	}\r\n	printf(\"%d\",m);\r\n	return 0;\r\n}'),(1047,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n	int t;\r\n	cin >> t;\r\n	while (t--) {\r\n		string op; int n;\r\n		cin >> op >> n;\r\n		if (op == \"diff\") {\r\n			if (n & 1) cout << -1 << endl;\r\n			else cout << 0 << \" \" << 0 << \" \" << n / 2 << endl;\r\n		}\r\n		else if (op == \"gcd\") {\r\n			cout << 1 << \" \" << n - 2 << \" \" << n - 2 << endl;\r\n		}\r\n		else if (op == \"xor\") {\r\n			if (n & 1) cout << -1 << endl;\r\n			else cout << 0 << \" \" << 0 << \" \" << n / 2 << endl;\r\n		}\r\n	} \r\n	return 0;\r\n}\r\n'),(1048,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n \r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        string op; int n;\r\n        cin >> op >> n;\r\n        if (op == \"diff\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << 0 << \" \" << n / 2 << \" \" << 0 << endl;\r\n        }\r\n        else if (op == \"gcd\") {\r\n            cout << n - 2 << \" \" << 1 << \" \" << n - 2 << endl;\r\n        }\r\n        else if (op == \"xor\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << n / 2 << \" \" << 0 << \" \" << 0 << endl;\r\n        }\r\n    } \r\n    return 0;\r\n}'),(1049,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n \r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        string op; int n;\r\n        cin >> op >> n;\r\n        if (op == \"diff\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << 1 << \" \" << n / 2 << \" \" << 0 << endl;\r\n        }\r\n        else if (op == \"gcd\") {\r\n            cout << n - 2 << \" \" << 1 << \" \" << n - 2 << endl;\r\n        }\r\n        else if (op == \"xor\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << n / 2 << \" \" << 0 << \" \" << 0 << endl;\r\n        }\r\n    } \r\n    return 0;\r\n}'),(1050,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n \r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        string op; int n;\r\n        cin >> op >> n;\r\n        if (op == \"diff\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << 114514 << \" \" << n / 2 << \" \" << 0 << endl;\r\n        }\r\n        else if (op == \"gcd\") {\r\n            cout << n - 2 << \" \" << 1 << \" \" << n - 2 << endl;\r\n        }\r\n        else if (op == \"xor\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << n / 2 << \" \" << 0 << \" \" << 0 << endl;\r\n        }\r\n    } \r\n    return 0;\r\n}'),(1051,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n\r\nconst int mod = 988244533;\r\n\r\nint qpow(int a, int b) {\r\n	if (b == 0) return 1;\r\n	if (b == 1) return a % mod;\r\n	int tmp = qpow(a, b / 2);\r\n	if (b & 1) return tmp * tmp % mod * a % mod;\r\n	else return tmp * tmp % mod; \r\n}\r\n\r\nsigned main() {\r\n	int n;\r\n	cin >> n;\r\n	cout << qpow(3, n) << endl;\r\n	return 0;\r\n}\r\n'),(1052,'#include <bits/stdc++.h>\r\n#define l(_x) (((_x) + 5) % 6)\r\n#define r(_x) (((_x) + 1) % 6)\r\nusing namespace std;\r\n\r\nconst int mod = 988244533;\r\nchar pos1, pos2; \r\nint a, b, n, ans, f[2][6][6];\r\n\r\nvoid testlr() {\r\n	cout << \"l(0): \" << l(0) << endl;\r\n	cout << \"l(1): \" << l(1) << endl;\r\n	cout << \"r(5): \" << r(5) << endl;\r\n	cout << \"r(4): \" << r(4) << endl;	\r\n}\r\n\r\nvoid debugf(int x) {\r\n	for (int i = 0; i < 6; i++)\r\n		for (int j = 0; j < 6; j++)\r\n			cout << f[x & 1][i][j] << endl;\r\n}\r\n\r\nint main() {\r\n//	testlr();\r\n	cin >> pos1 >> pos2 >> n;\r\n	a = pos1 - \'A\', b = pos2 - \'A\';\r\n	f[0][a][b] = 1;\r\n//	debugf(0);\r\n	for (int i = 1; i <= n; i++) {\r\n		memset(f[i & 1], 0, sizeof f[i & 1]);\r\n		for (int j = 0; j < 6; j++)\r\n			for (int k = 0; k < 6; k++)\r\n				if (j != k) {\r\n					if (l(j) != l(k)) (f[i & 1][j][k] += f[(i - 1) & 1][l(j)][l(k)]) %= mod;\r\n					if (l(j) != r(k)) (f[i & 1][j][k] += f[(i - 1) & 1][l(j)][r(k)]) %= mod;\r\n					if (r(j) != l(k)) (f[i & 1][j][k] += f[(i - 1) & 1][r(j)][l(k)]) %= mod;\r\n					if (r(j) != r(k)) (f[i & 1][j][k] += f[(i - 1) & 1][r(j)][r(k)]) %= mod; \r\n				}\r\n//		debugf(i);\r\n	}\r\n	for (int i = 0; i < 6; i++)\r\n		for (int j = 0; j < 6; j++)\r\n			(ans += f[n & 1][i][j]) %= mod;\r\n	cout << ans << endl;\r\n	return 0;\r\n}\r\n'),(1053,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct node {\r\n	bool deleted = 0;\r\n	int coefficient;\r\n	map<char, int> mp;\r\n} a[10001];\r\nmap<char, int> tmp;\r\nmap<map<char, int>, int> vis;\r\nnode commonFactor;\r\n\r\nvoid print(node x) {\r\n	if (x.coefficient != 1) cout << x.coefficient;\r\n	int cnt = 0;\r\n	for (char c = \'a\'; c <= \'z\'; c++)\r\n		if (x.mp[c] != 0)\r\n			cnt++;\r\n	for (char c = \'a\'; c <= \'z\'; c++)\r\n		if (x.mp[c] != 0)\r\n			cout << (cnt == 1 && x.coefficient == 1? \"\" : \"*\") << c << (x.mp[c] == 1? \"\" : \"^\" + to_string(x.mp[c]));\r\n}\r\n\r\nint main() {\r\n	int n;\r\n	cin >> n;\r\n	for (int i = 1; i <= n; i++) {\r\n		int m, t;\r\n		cin >> m >> t;\r\n		a[i].coefficient = t;\r\n		tmp.clear();\r\n		for (int j = 1; j <= m; j++) {\r\n			char c; int num;\r\n			cin >> c >> num;\r\n			tmp[c] = num;\r\n		}\r\n		a[i].mp = tmp;\r\n	}\r\n	for (int i = 1; i <= n; i++) {\r\n		if (vis[a[i].mp]) {\r\n			a[i].deleted = 1;\r\n			a[vis[a[i].mp]].coefficient += a[i].coefficient;\r\n		}\r\n		else vis[a[i].mp] = i;\r\n	}\r\n	int g = a[1].coefficient;\r\n	for (int i = 2; i <= n; i++)\r\n		if (!a[i].deleted)\r\n			g = __gcd(g, a[i].coefficient);\r\n	commonFactor.coefficient = g;\r\n	for (char c = \'a\'; c <= \'z\'; c++) {\r\n		int mn = 0x3f3f3f3f;\r\n		for (int i = 1; i <= n; i++)\r\n			if (!a[i].deleted)\r\n				mn = min(mn, a[i].mp[c]);\r\n		commonFactor.mp[c] = mn;\r\n	}\r\n	print(commonFactor);\r\n	cout << endl;\r\n	return 0;\r\n}\r\n'),(1054,'// factorization.cpp\r\n// author: xcx\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint a, b, c, d, e, f, g;\r\nvector<int> da, dc, df;\r\n\r\nint gcd(int x, int y) {\r\n	x = abs(x); y = abs(y);\r\n	return !y? x : gcd(y, x % y);\r\n}\r\n\r\nvector<int> div(int x) {\r\n	vector<int> tmp, ret;\r\n	int up = sqrt(abs(x));\r\n	for (int i = 1; i <= up; i++)\r\n		if (x % i == 0) {\r\n			tmp.push_back(i);\r\n			if (i * i != x) tmp.push_back(x / i);\r\n		}\r\n	sort(tmp.begin(), tmp.end());\r\n	ret = tmp;\r\n	for (int num: tmp)\r\n		ret.push_back(-num);\r\n	return ret;\r\n}\r\n\r\nstring pr(int num) {\r\n	if (num == 1) return \"\";\r\n	else if (num == -1) return \"-\";\r\n	else return to_string(num);\r\n}\r\n\r\nvoid print(int a, int b, int c) { // ax + by + c\r\n	if (a == 0) cout << pr(b) << \"y\" << (c >= 0 ? \"+\" : \"\") << c;\r\n	else if (b == 0) cout << pr(a) << \"x\" << (c >= 0 ? \"+\" : \"\") << c;\r\n	else if (c == 0) cout << pr(a) << \"x\" << (b >= 0 ? \"+\" : \"\") << pr(b) << \"y\";\r\n	else cout << pr(a) << \"x\" << (b >= 0 ? \"+\" : \"\") << pr(b) << \"y\" << (c >= 0 ? \"+\" : \"\") << c; \r\n}\r\n\r\nvoid printAns(int k, int l, int m, int n, int p, int q) {\r\n	if (g != 1) cout << g;\r\n	cout << \"(\";\r\n	print(k, l, m);\r\n	cout << \")(\";\r\n	print(n, p, q);\r\n	cout << \")\" << endl; \r\n}\r\n\r\nint main() {\r\n	cin >> a >> b >> c >> d >> e >> f;\r\n	g = gcd(a, gcd(b, gcd(c, gcd(d, gcd(e, f)))));\r\n	a /= g, b /= g, c /= g, d /= g, e /= g, f /= g;\r\n//	cout << \"#\" << g << endl;\r\n	da = div(a); dc = div(c); df = div(f);\r\n//	cout << \'#\' << endl;\r\n//	cerr << da.size() << \" \" << dc.size() << \" \" << df.size() << endl;\r\n	// ax^2 + bxy + cy^2 + dx + ey + f\r\n	// (kx + ly + m)(nx + py + q)\r\n	for (int k: da)\r\n		for (int l: dc)\r\n			for (int m: df) {\r\n				int n = a / k, p = c / l, q = f / m;\r\n				if (k * p + l * n == b && l * q + m * p == e && k * q + n * m == d) {\r\n					printAns(k, l, m, n, p, q);\r\n					return 0;\r\n				}\r\n			}\r\n	return 0;\r\n}\r\n'),(1055,'// factorization.cpp\r\n// author: xcx\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint a, b, c, d, e, f, g;\r\nvector<int> da, dc, df;\r\n\r\nint gcd(int x, int y) {\r\n	x = abs(x); y = abs(y);\r\n	return !y? x : gcd(y, x % y);\r\n}\r\n\r\nvector<int> div(int x) {\r\n	vector<int> tmp, ret;\r\n	int up = sqrt(abs(x));\r\n	for (int i = 1; i <= up; i++)\r\n		if (x % i == 0) {\r\n			tmp.push_back(i);\r\n			if (i * i != x) tmp.push_back(x / i);\r\n		}\r\n	sort(tmp.begin(), tmp.end());\r\n	ret = tmp;\r\n	for (int num: tmp)\r\n		ret.push_back(-num);\r\n	return ret;\r\n}\r\n\r\nstring pr(int num) {\r\n	if (num == 1) return \"\";\r\n	else if (num == -1) return \"-\";\r\n	else return to_string(num);\r\n}\r\n\r\nvoid print(int a, int b, int c) { // ax + by + c\r\n	if (a == 0) cout << pr(b) << \"y\" << (c >= 0 ? \"+\" : \"\") << c;\r\n	else if (b == 0) cout << pr(a) << \"x\" << (c >= 0 ? \"+\" : \"\") << c;\r\n	else if (c == 0) cout << pr(a) << \"x\" << (b >= 0 ? \"+\" : \"\") << pr(b) << \"y\";\r\n	else cout << pr(a) << \"x\" << (b >= 0 ? \"+\" : \"\") << pr(b) << \"y\" << (c >= 0 ? \"+\" : \"\") << c; \r\n}\r\n\r\nvoid printAns(int k, int l, int m, int n, int p, int q) {\r\n	if (g != 1) cout << g;\r\n	cout << \"(\";\r\n	print(k, l, m);\r\n	cout << \")(\";\r\n	print(n, p, q);\r\n	cout << \")\" << endl; \r\n}\r\n\r\nint main() {\r\n	cin >> a >> b >> c >> d >> e >> f;\r\n	g = gcd(a, gcd(b, gcd(c, gcd(d, gcd(e, f)))));\r\n	a /= g, b /= g, c /= g, d /= g, e /= g, f /= g;\r\n//	cout << \"#\" << g << endl;\r\n	da = div(a); dc = div(c); df = div(f);\r\n//	cout << \'#\' << endl;\r\n//	cerr << da.size() << \" \" << dc.size() << \" \" << df.size() << endl;\r\n	// ax^2 + bxy + cy^2 + dx + ey + f\r\n	// (kx + ly + m)(nx + py + q)\r\n	for (int k: da)\r\n		for (int l: dc)\r\n			for (int m: df) {\r\n				int n = a / k, p = c / l, q = f / m;\r\n				if (k * p + l * n == b && l * q + m * p == e && k * q + n * m == d) {\r\n					printAns(-k, -l, -m, -n, -p, -q);\r\n					return 0;\r\n				}\r\n			}\r\n	return 0;\r\n}\r\n'),(1056,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n\r\nconst int mod = 988244533;\r\nint n, len, ans;\r\nstring s;\r\nvector<string> a;\r\nvector<int> c;\r\n\r\nint qpow(int a, int b) {\r\n	if (b == 0) return 1;\r\n	if (b == 1) return a % mod;\r\n	int tmp = qpow(a, b / 2) % mod;\r\n	if (b & 1) return tmp * tmp % mod * a % mod;\r\n	else return tmp * tmp % mod;\r\n}\r\n\r\nvoid init() {\r\n	cin >> s;\r\n	len = s.length();\r\n	s = \" \" + s;\r\n}\r\n\r\nbool checkStar() {\r\n	for (int i = 1; i <= len; i++)\r\n		if (s[i] == \'*\')\r\n			return true;\r\n	return false;\r\n}\r\n\r\nvoid division() {\r\n	int last = 1;\r\n	a.push_back(\"\");\r\n	for (int i = 1; i <= len; i++)\r\n		if (s[i] == \'|\') {\r\n			a.push_back(s.substr(last, i - last));\r\n			last = i + 1;\r\n		}\r\n	a.push_back(s.substr(last, len - last + 1));\r\n	n = a.size() - 1;\r\n}\r\n\r\npair<string, int> merge(string x, string y) {\r\n	if (x.size() != y.size()) return {\"\", 0};\r\n	int clen = x.size();\r\n	string ans;\r\n	for (int i = 0; i < clen; i++) {\r\n		if (x[i] != \'?\' && y[i] != \'?\' && x[i] != y[i]) return {\"\", 0};\r\n		if (x[i] != \'?\' && y[i] != \'?\' && x[i] == y[i]) ans += x[i];\r\n		if (x[i] == \'?\' && y[i] != \'?\') ans += y[i];\r\n		if (x[i] != \'?\' && y[i] == \'?\') ans += x[i];\r\n		if (x[i] == \'?\' && y[i] == \'?\') ans += \'?\';\r\n	}\r\n	return {ans, 1};\r\n}\r\n\r\nint calc() {\r\n	if (c.size() == 0) return -1;\r\n	for (auto i: c)\r\n		if (a[i].size() != a[c[0]].size())\r\n			return -1;\r\n	string t;\r\n	int clen = a[c[0]].size();\r\n	for (int i = 1; i <= clen; i++)\r\n		t += \'?\';\r\n//	cout << clen << \" \" << t << endl;\r\n	for (auto i: c) {\r\n		pair<string, int> tmp = merge(t, a[i]);\r\n		if (tmp.second == 0) return -1;\r\n		else t = tmp.first;\r\n	}\r\n	if (c.size() == 1) t = a[c[0]];\r\n	int ret = 0;\r\n	for (auto ch: t)\r\n		if (ch == \'?\')\r\n			ret++;\r\n//	cout << \"------------\" << endl;\r\n//	cout << \"chose: \";\r\n//	for (auto i: c) cout << a[i] << \" \";\r\n//	cout << endl;\r\n//	cout << \"t: \" << t << endl; \r\n//	cout << \"ret: \" << ret << endl;\r\n//	cout << \"------------\" << endl;\r\n	return ret;\r\n}\r\n\r\nvoid work() {\r\n//	cout << s << endl << \"*\" << s.substr(1) << \"*\" << endl;\r\n	if (checkStar()) {\r\n		cout << \"INF\" << endl;\r\n		return;\r\n	}\r\n//	cout << \"Before Divison\" << endl; \r\n	division();\r\n//	cout << \"After Divison\" << endl;\r\n//	for (auto x: a) cout << x << endl;\r\n//	cout << \"After Debug1\" << endl;\r\n//	cout << n << \" \" << (1 << n) << endl; \r\n	for (int i = 0; i < (1 << n); i++) {\r\n//		cout << \"for started\" << endl;\r\n		int tmp = i;\r\n//		cout << tmp << \":\";\r\n		c.clear();\r\n		for (int j = 1; j <= n; j++) {\r\n			if (tmp & 1) c.push_back(j);\r\n			tmp >>= 1;\r\n		}\r\n//		for (auto x: c) cout << x << \" \"; cout << endl;\r\n		int num = calc();\r\n		if (num != -1) num = qpow(26, num);\r\n		else num = 0;\r\n//		cout << num << endl;\r\n		if (c.size() & 1) ans = (ans + num) % mod;\r\n		else ans = (ans - num + mod) % mod;\r\n//		cout << \"for ended\" << endl;\r\n	}\r\n	cout << ans << endl;\r\n}\r\n\r\nsigned main() {\r\n//	for (int i = 1; i <= 100; i++)\r\n//		cout << qpow(26, i) << endl;\r\n	init();\r\n	work();\r\n	return 0;\r\n}'),(1057,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    cout << \"Hello World!\" << endl;\r\n	return 0;\r\n}\r\n'),(1058,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    int a, b;\r\n    cin >> a >> b;\r\n    cout << a + b << endl;\r\n	return 0;\r\n}\r\n'),(1059,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    int a, b;\r\n    cin >> a >> b;\r\n    cout << a + b << endl;\r\n	return 0;\r\n}\r\n'),(1060,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n  \r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        string op; int n;\r\n        cin >> op >> n;\r\n        if (op == \"diff\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << n / 2 << \" \" << 0 << \" \" << 0 << endl;\r\n        }\r\n        else if (op == \"gcd\") {\r\n            cout << n - 2 << \" \" << n - 2 << \" \" << 1 << endl;\r\n        }\r\n        else if (op == \"xor\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << 0 << \" \" << 0 << \" \" << n / 2 << endl;\r\n        }\r\n    } \r\n    return 0;\r\n}'),(1061,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    cout << \"4294967295\" << endl;\r\n    return 0;\r\n}'),(1062,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n \r\nnamespace trie {\r\n	const int N = 100005 * 65;\r\n	int cnt = 0;\r\n	struct trieNode {\r\n		int num, lc, rc;\r\n		trieNode() {\r\n			num = lc = rc = -1;\r\n		}\r\n	} trie[N]; // root = 0\r\n	#define son(_x, _y) ((_y)? trie[_x].rc : trie[_x].lc)\r\n	#define num(_x) trie[_x].num\r\n	vector<int> div(int x) {\r\n		vector<int> ret;\r\n		for (int i = 1; i <= 60; i++) {\r\n			ret.push_back(x & 1);\r\n			x >>= 1;\r\n		}\r\n		reverse(ret.begin(), ret.end());\r\n		return ret;\r\n	}\r\n	void insert(int x) {\r\n		vector<int> bits = div(x);\r\n		int p = 0;\r\n		for (int i: bits) {\r\n			if (son(p, i) == -1)\r\n				son(p, i) = ++cnt;\r\n			num(son(p, i)) = i;\r\n			p = son(p, i);\r\n		}\r\n	}\r\n	int calc(int x) {\r\n		vector<int> bits = div(x);\r\n		int p = 0, ans = 0;\r\n		for (int i: bits) {\r\n			if (son(p, i ^ 1) != -1) {\r\n				ans = ans << 1 | 1;\r\n				p = son(p, i ^ 1);\r\n			} else {\r\n				ans <<= 1;\r\n				p = son(p, i);\r\n			}\r\n//			cout << ans << endl;\r\n		}\r\n		return ans;\r\n	}\r\n}\r\n\r\nconst int N = 100005;\r\nint n, ans, a[N], d[N];\r\nvector<int> g[N];\r\n\r\nvoid dfs(int u, int fa) {\r\n	d[u] ^= a[u];\r\n	for (int v: g[u])\r\n		if (v != fa)\r\n			d[v] ^= d[u], dfs(v, u);\r\n}\r\n\r\nsigned main() {\r\n	cin >> n;\r\n	for (int i = 1; i <= n; i++)\r\n		cin >> a[i];\r\n	for (int i = 1, u, v; i < n; i++) {\r\n		cin >> u >> v;\r\n		g[u].push_back(v);\r\n		g[v].push_back(u); \r\n	}\r\n	dfs(1, -1);\r\n//	for (int i = 1; i <= n; i++)\r\n//		cout << d[i] << \" \";\r\n//	cout << endl;\r\n	for (int i = 1; i <= n; i++)\r\n		trie::insert(d[i]);\r\n	for (int i = 1; i <= n; i++)\r\n		ans = max(ans, trie::calc(d[i]));\r\n	cout << ans << endl;\r\n	return 0;\r\n}'),(1063,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\nnamespace deQueue {\r\n	const int NUM = 100001;\r\n	typedef pii Elemtype; \r\n	typedef struct deQueue {\r\n		Elemtype base[NUM];\r\n		int front, back;\r\n	} myDeque;\r\n	void init(deQueue &Q) {\r\n		Q.back = Q.front = 1;\r\n	}\r\n	int push_front(deQueue &Q, Elemtype x) {\r\n		if (Q.front < Q.back) {\r\n			if (Q.front == 1)\r\n				if (Q.back == NUM - 1) return 1;\r\n				else Q.base[Q.front = NUM - 1] = x;\r\n		}\r\n		else if (Q.front == Q.back)\r\n			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n			else Q.base[--Q.front] = x;\r\n		else if (Q.front == Q.back + 1) return 1;\r\n		else Q.base[--Q.front] = x;\r\n		return 0;\r\n	}\r\n	int push_back(deQueue &Q, Elemtype x) {\r\n		if (Q.front == Q.back)\r\n			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n			else Q.base[Q.back++] = x;\r\n		else if (Q.front < Q.back)\r\n			if (Q.back == NUM - 1)\r\n				if (Q.front == 1) return 1;\r\n				else Q.base[Q.back = 1] = x;\r\n			else Q.base[Q.back++] = x;\r\n		else if (Q.back + 1 == Q.front) return 1;\r\n		else Q.base[Q.back++] = x;\r\n		return 0;\r\n	}\r\n	int pop_front(deQueue &Q) {\r\n		if (Q.front == Q.back) return 1;\r\n		else if (Q.front < Q.back) ++Q.front;\r\n		else if (Q.front == NUM - 1) Q.front = 1;\r\n		else ++Q.front;\r\n		return 0;\r\n	}\r\n	int pop_back(deQueue &Q) {\r\n		if (Q.back > Q.front) --Q.back;\r\n		else if (Q.back == Q.front) return 1;\r\n		else if (Q.back == 1) Q.back = NUM - 1;\r\n		else --Q.back;\r\n		return 0;\r\n	}\r\n	int size(deQueue &Q) {\r\n		if (Q.back >= Q.front) return Q.back - Q.front;\r\n		else return Q.back + NUM - Q.front; \r\n	}\r\n	Elemtype front(deQueue &Q) {\r\n		return Q.base[Q.front];\r\n	}\r\n	Elemtype back(deQueue &Q) {\r\n		return Q.base[Q.back];\r\n	}\r\n}\r\nusing namespace deQueue;\r\nmyDeque q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	init(q);\r\n	push_back(q, {x, 0});\r\n	while (size(q)) {\r\n		pii t = front(q); pop_front(q);\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) push_front(q, {e[i].to, dis});\r\n			else push_back(q, {e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1064,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\nnamespace deQueue {\r\n	const int NUM = 100001;\r\n	typedef pii Elemtype; \r\n	typedef struct deQueue {\r\n		Elemtype base[NUM];\r\n		int front, back;\r\n	} myDeque;\r\n	void init(deQueue &Q) {\r\n		Q.back = Q.front = 1;\r\n	}\r\n	int push_front(deQueue &Q, Elemtype x) {\r\n		if (Q.front < Q.back) {\r\n			if (Q.front == 1)\r\n				if (Q.back == NUM - 1) return 1;\r\n				else Q.base[Q.front = NUM - 1] = x;\r\n			else Q.base[--Q.front] = x;\r\n		}\r\n		else if (Q.front == Q.back)\r\n			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n			else Q.base[--Q.front] = x;\r\n		else if (Q.front == Q.back + 1) return 1;\r\n		else Q.base[--Q.front] = x;\r\n		return 0;\r\n	}\r\n	int push_back(deQueue &Q, Elemtype x) {\r\n		if (Q.front == Q.back)\r\n			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n			else Q.base[Q.back++] = x;\r\n		else if (Q.front < Q.back)\r\n			if (Q.back == NUM - 1)\r\n				if (Q.front == 1) return 1;\r\n				else Q.base[Q.back = 1] = x;\r\n			else Q.base[Q.back++] = x;\r\n		else if (Q.back + 1 == Q.front) return 1;\r\n		else Q.base[Q.back++] = x;\r\n		return 0;\r\n	}\r\n	int pop_front(deQueue &Q) {\r\n		if (Q.front == Q.back) return 1;\r\n		else if (Q.front < Q.back) ++Q.front;\r\n		else if (Q.front == NUM - 1) Q.front = 1;\r\n		else ++Q.front;\r\n		return 0;\r\n	}\r\n	int pop_back(deQueue &Q) {\r\n		if (Q.back > Q.front) --Q.back;\r\n		else if (Q.back == Q.front) return 1;\r\n		else if (Q.back == 1) Q.back = NUM - 1;\r\n		else --Q.back;\r\n		return 0;\r\n	}\r\n	int size(deQueue &Q) {\r\n		if (Q.back >= Q.front) return Q.back - Q.front;\r\n		else return Q.back + NUM - Q.front; \r\n	}\r\n	Elemtype front(deQueue &Q) {\r\n		return Q.base[Q.front];\r\n	}\r\n	Elemtype back(deQueue &Q) {\r\n		return Q.base[Q.back];\r\n	}\r\n}\r\nusing namespace deQueue;\r\nmyDeque q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	init(q);\r\n	push_back(q, {x, 0});\r\n	while (size(q)) {\r\n		pii t = front(q); pop_front(q);\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) push_front(q, {e[i].to, dis});\r\n			else push_back(q, {e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1065,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\nnamespace deQueue {\r\n	const int NUM = 100001;\r\n	typedef pii Elemtype; \r\n	typedef struct deQueue {\r\n		Elemtype base[NUM];\r\n		int front, back;\r\n	} myDeque;\r\n	void init(deQueue &Q) {\r\n		Q.back = Q.front = 1;\r\n	}\r\n	int push_front(deQueue &Q, Elemtype x) {\r\n		if (Q.front < Q.back) {\r\n			if (Q.front == 1)\r\n				if (Q.back == NUM - 1) return 1;\r\n				else Q.base[Q.front = NUM - 1] = x;\r\n			else Q.base[--Q.front] = x;\r\n		}\r\n		else if (Q.front == Q.back)\r\n			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n			else Q.base[--Q.front] = x;\r\n		else if (Q.front == Q.back + 1) return 1;\r\n		else Q.base[--Q.front] = x;\r\n		return 0;\r\n	}\r\n	int push_back(deQueue &Q, Elemtype x) {\r\n		if (Q.front == Q.back)\r\n			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n			else Q.base[Q.back++] = x;\r\n		else if (Q.front < Q.back)\r\n			if (Q.back == NUM - 1)\r\n				if (Q.front == 1) return 1;\r\n				else Q.base[Q.back = 1] = x;\r\n			else Q.base[Q.back++] = x;\r\n		else if (Q.back + 1 == Q.front) return 1;\r\n		else Q.base[Q.back++] = x;\r\n		return 0;\r\n	}\r\n	int pop_front(deQueue &Q) {\r\n		if (Q.front == Q.back) return 1;\r\n		else if (Q.front < Q.back) ++Q.front;\r\n		else if (Q.front == NUM - 1) Q.front = 1;\r\n		else ++Q.front;\r\n		return 0;\r\n	}\r\n	int pop_back(deQueue &Q) {\r\n		if (Q.back > Q.front) --Q.back;\r\n		else if (Q.back == Q.front) return 1;\r\n		else if (Q.back == 1) Q.back = NUM - 1;\r\n		else --Q.back;\r\n		return 0;\r\n	}\r\n	int size(deQueue &Q) {\r\n		if (Q.back >= Q.front) return Q.back - Q.front;\r\n		else return Q.back + NUM - Q.front; \r\n	}\r\n	Elemtype front(deQueue &Q) {\r\n		return Q.base[Q.front];\r\n	}\r\n	Elemtype back(deQueue &Q) {\r\n		return Q.base[Q.back];\r\n	}\r\n}\r\nusing namespace deQueue;\r\nmyDeque q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	init(q);\r\n	push_back(q, {x, 0});\r\n	while (size(q)) {\r\n		pii t = front(q); pop_front(q);\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) push_front(q, {e[i].to, dis});\r\n			else push_back(q, {e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1066,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\n// namespace deQueue {\r\n// 	const int NUM = 100001;\r\n// 	typedef pii Elemtype; \r\n// 	typedef struct deQueue {\r\n// 		Elemtype base[NUM];\r\n// 		int front, back;\r\n// 	} myDeque;\r\n// 	void init(deQueue &Q) {\r\n// 		Q.back = Q.front = 1;\r\n// 	}\r\n// 	int push_front(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front < Q.back) {\r\n// 			if (Q.front == 1)\r\n// 				if (Q.back == NUM - 1) return 1;\r\n// 				else Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		}\r\n// 		else if (Q.front == Q.back)\r\n// 			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		else if (Q.front == Q.back + 1) return 1;\r\n// 		else Q.base[--Q.front] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int push_back(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front == Q.back)\r\n// 			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.front < Q.back)\r\n// 			if (Q.back == NUM - 1)\r\n// 				if (Q.front == 1) return 1;\r\n// 				else Q.base[Q.back = 1] = x;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.back + 1 == Q.front) return 1;\r\n// 		else Q.base[Q.back++] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_front(deQueue &Q) {\r\n// 		if (Q.front == Q.back) return 1;\r\n// 		else if (Q.front < Q.back) ++Q.front;\r\n// 		else if (Q.front == NUM - 1) Q.front = 1;\r\n// 		else ++Q.front;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_back(deQueue &Q) {\r\n// 		if (Q.back > Q.front) --Q.back;\r\n// 		else if (Q.back == Q.front) return 1;\r\n// 		else if (Q.back == 1) Q.back = NUM - 1;\r\n// 		else --Q.back;\r\n// 		return 0;\r\n// 	}\r\n// 	int size(deQueue &Q) {\r\n// 		if (Q.back >= Q.front) return Q.back - Q.front;\r\n// 		else return Q.back + NUM - Q.front; \r\n// 	}\r\n// 	Elemtype front(deQueue &Q) {\r\n// 		return Q.base[Q.front];\r\n// 	}\r\n// 	Elemtype back(deQueue &Q) {\r\n// 		return Q.base[Q.back];\r\n// 	}\r\n// }\r\n// using namespace deQueue;\r\n// myDeque q;\r\n\r\ndeque<int> q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	q.clear();\r\n	q.push_back({x, 0});\r\n	while (size(q)) {\r\n		pii t = q.front(); q.pop_front();\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) q.push_front({e[i].to, dis});\r\n			else q.push_back({e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1067,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\n// namespace deQueue {\r\n// 	const int NUM = 100001;\r\n// 	typedef pii Elemtype; \r\n// 	typedef struct deQueue {\r\n// 		Elemtype base[NUM];\r\n// 		int front, back;\r\n// 	} myDeque;\r\n// 	void init(deQueue &Q) {\r\n// 		Q.back = Q.front = 1;\r\n// 	}\r\n// 	int push_front(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front < Q.back) {\r\n// 			if (Q.front == 1)\r\n// 				if (Q.back == NUM - 1) return 1;\r\n// 				else Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		}\r\n// 		else if (Q.front == Q.back)\r\n// 			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		else if (Q.front == Q.back + 1) return 1;\r\n// 		else Q.base[--Q.front] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int push_back(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front == Q.back)\r\n// 			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.front < Q.back)\r\n// 			if (Q.back == NUM - 1)\r\n// 				if (Q.front == 1) return 1;\r\n// 				else Q.base[Q.back = 1] = x;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.back + 1 == Q.front) return 1;\r\n// 		else Q.base[Q.back++] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_front(deQueue &Q) {\r\n// 		if (Q.front == Q.back) return 1;\r\n// 		else if (Q.front < Q.back) ++Q.front;\r\n// 		else if (Q.front == NUM - 1) Q.front = 1;\r\n// 		else ++Q.front;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_back(deQueue &Q) {\r\n// 		if (Q.back > Q.front) --Q.back;\r\n// 		else if (Q.back == Q.front) return 1;\r\n// 		else if (Q.back == 1) Q.back = NUM - 1;\r\n// 		else --Q.back;\r\n// 		return 0;\r\n// 	}\r\n// 	int size(deQueue &Q) {\r\n// 		if (Q.back >= Q.front) return Q.back - Q.front;\r\n// 		else return Q.back + NUM - Q.front; \r\n// 	}\r\n// 	Elemtype front(deQueue &Q) {\r\n// 		return Q.base[Q.front];\r\n// 	}\r\n// 	Elemtype back(deQueue &Q) {\r\n// 		return Q.base[Q.back];\r\n// 	}\r\n// }\r\n// using namespace deQueue;\r\n// myDeque q;\r\n\r\ndeque<pii> q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	q.clear();\r\n	q.push_back({x, 0});\r\n	while (size(q)) {\r\n		pii t = q.front(); q.pop_front();\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) q.push_front({e[i].to, dis});\r\n			else q.push_back({e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1068,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\n// namespace deQueue {\r\n// 	const int NUM = 100001;\r\n// 	typedef pii Elemtype; \r\n// 	typedef struct deQueue {\r\n// 		Elemtype base[NUM];\r\n// 		int front, back;\r\n// 	} myDeque;\r\n// 	void init(deQueue &Q) {\r\n// 		Q.back = Q.front = 1;\r\n// 	}\r\n// 	int push_front(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front < Q.back) {\r\n// 			if (Q.front == 1)\r\n// 				if (Q.back == NUM - 1) return 1;\r\n// 				else Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		}\r\n// 		else if (Q.front == Q.back)\r\n// 			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		else if (Q.front == Q.back + 1) return 1;\r\n// 		else Q.base[--Q.front] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int push_back(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front == Q.back)\r\n// 			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.front < Q.back)\r\n// 			if (Q.back == NUM - 1)\r\n// 				if (Q.front == 1) return 1;\r\n// 				else Q.base[Q.back = 1] = x;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.back + 1 == Q.front) return 1;\r\n// 		else Q.base[Q.back++] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_front(deQueue &Q) {\r\n// 		if (Q.front == Q.back) return 1;\r\n// 		else if (Q.front < Q.back) ++Q.front;\r\n// 		else if (Q.front == NUM - 1) Q.front = 1;\r\n// 		else ++Q.front;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_back(deQueue &Q) {\r\n// 		if (Q.back > Q.front) --Q.back;\r\n// 		else if (Q.back == Q.front) return 1;\r\n// 		else if (Q.back == 1) Q.back = NUM - 1;\r\n// 		else --Q.back;\r\n// 		return 0;\r\n// 	}\r\n// 	int size(deQueue &Q) {\r\n// 		if (Q.back >= Q.front) return Q.back - Q.front;\r\n// 		else return Q.back + NUM - Q.front; \r\n// 	}\r\n// 	Elemtype front(deQueue &Q) {\r\n// 		return Q.base[Q.front];\r\n// 	}\r\n// 	Elemtype back(deQueue &Q) {\r\n// 		return Q.base[Q.back];\r\n// 	}\r\n// }\r\n// using namespace deQueue;\r\n// myDeque q;\r\n\r\ndeque<pii> q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	q.clear();\r\n	q.push_back({x, 0});\r\n	while (!q.empty()) {\r\n		pii t = q.front(); q.pop_front();\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) q.push_front({e[i].to, dis});\r\n			else q.push_back({e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1069,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\n// namespace deQueue {\r\n// 	const int NUM = 100001;\r\n// 	typedef pii Elemtype; \r\n// 	typedef struct deQueue {\r\n// 		Elemtype base[NUM];\r\n// 		int front, back;\r\n// 	} myDeque;\r\n// 	void init(deQueue &Q) {\r\n// 		Q.back = Q.front = 1;\r\n// 	}\r\n// 	int push_front(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front < Q.back) {\r\n// 			if (Q.front == 1)\r\n// 				if (Q.back == NUM - 1) return 1;\r\n// 				else Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		}\r\n// 		else if (Q.front == Q.back)\r\n// 			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		else if (Q.front == Q.back + 1) return 1;\r\n// 		else Q.base[--Q.front] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int push_back(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front == Q.back)\r\n// 			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.front < Q.back)\r\n// 			if (Q.back == NUM - 1)\r\n// 				if (Q.front == 1) return 1;\r\n// 				else Q.base[Q.back = 1] = x;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.back + 1 == Q.front) return 1;\r\n// 		else Q.base[Q.back++] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_front(deQueue &Q) {\r\n// 		if (Q.front == Q.back) return 1;\r\n// 		else if (Q.front < Q.back) ++Q.front;\r\n// 		else if (Q.front == NUM - 1) Q.front = 1;\r\n// 		else ++Q.front;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_back(deQueue &Q) {\r\n// 		if (Q.back > Q.front) --Q.back;\r\n// 		else if (Q.back == Q.front) return 1;\r\n// 		else if (Q.back == 1) Q.back = NUM - 1;\r\n// 		else --Q.back;\r\n// 		return 0;\r\n// 	}\r\n// 	int size(deQueue &Q) {\r\n// 		if (Q.back >= Q.front) return Q.back - Q.front;\r\n// 		else return Q.back + NUM - Q.front; \r\n// 	}\r\n// 	Elemtype front(deQueue &Q) {\r\n// 		return Q.base[Q.front];\r\n// 	}\r\n// 	Elemtype back(deQueue &Q) {\r\n// 		return Q.base[Q.back];\r\n// 	}\r\n// }\r\n// using namespace deQueue;\r\n// myDeque q;\r\n\r\ndeque<pii> q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	q.clear();\r\n	q.push_back({x, 0});\r\n	while (size(q)) {\r\n		pii t = q.front(); q.pop_front();\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) q.push_front({e[i].to, dis});\r\n			else q.push_back({e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1070,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\n// namespace deQueue {\r\n// 	const int NUM = 100001;\r\n// 	typedef pii Elemtype; \r\n// 	typedef struct deQueue {\r\n// 		Elemtype base[NUM];\r\n// 		int front, back;\r\n// 	} myDeque;\r\n// 	void init(deQueue &Q) {\r\n// 		Q.back = Q.front = 1;\r\n// 	}\r\n// 	int push_front(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front < Q.back) {\r\n// 			if (Q.front == 1)\r\n// 				if (Q.back == NUM - 1) return 1;\r\n// 				else Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		}\r\n// 		else if (Q.front == Q.back)\r\n// 			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		else if (Q.front == Q.back + 1) return 1;\r\n// 		else Q.base[--Q.front] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int push_back(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front == Q.back)\r\n// 			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.front < Q.back)\r\n// 			if (Q.back == NUM - 1)\r\n// 				if (Q.front == 1) return 1;\r\n// 				else Q.base[Q.back = 1] = x;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.back + 1 == Q.front) return 1;\r\n// 		else Q.base[Q.back++] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_front(deQueue &Q) {\r\n// 		if (Q.front == Q.back) return 1;\r\n// 		else if (Q.front < Q.back) ++Q.front;\r\n// 		else if (Q.front == NUM - 1) Q.front = 1;\r\n// 		else ++Q.front;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_back(deQueue &Q) {\r\n// 		if (Q.back > Q.front) --Q.back;\r\n// 		else if (Q.back == Q.front) return 1;\r\n// 		else if (Q.back == 1) Q.back = NUM - 1;\r\n// 		else --Q.back;\r\n// 		return 0;\r\n// 	}\r\n// 	int size(deQueue &Q) {\r\n// 		if (Q.back >= Q.front) return Q.back - Q.front;\r\n// 		else return Q.back + NUM - Q.front; \r\n// 	}\r\n// 	Elemtype front(deQueue &Q) {\r\n// 		return Q.base[Q.front];\r\n// 	}\r\n// 	Elemtype back(deQueue &Q) {\r\n// 		return Q.base[Q.back];\r\n// 	}\r\n// }\r\n// using namespace deQueue;\r\n// myDeque q;\r\n\r\ndeque<pii> q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	q.clear();\r\n	q.push_back({x, 0});\r\n	while (!q.empty()) {\r\n		pii t = q.front(); q.pop_front();\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) q.push_front({e[i].to, dis});\r\n			else q.push_back({e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1071,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\n// namespace deQueue {\r\n// 	const int NUM = 100001;\r\n// 	typedef pii Elemtype; \r\n// 	typedef struct deQueue {\r\n// 		Elemtype base[NUM];\r\n// 		int front, back;\r\n// 	} myDeque;\r\n// 	void init(deQueue &Q) {\r\n// 		Q.back = Q.front = 1;\r\n// 	}\r\n// 	int push_front(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front < Q.back) {\r\n// 			if (Q.front == 1)\r\n// 				if (Q.back == NUM - 1) return 1;\r\n// 				else Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		}\r\n// 		else if (Q.front == Q.back)\r\n// 			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		else if (Q.front == Q.back + 1) return 1;\r\n// 		else Q.base[--Q.front] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int push_back(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front == Q.back)\r\n// 			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.front < Q.back)\r\n// 			if (Q.back == NUM - 1)\r\n// 				if (Q.front == 1) return 1;\r\n// 				else Q.base[Q.back = 1] = x;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.back + 1 == Q.front) return 1;\r\n// 		else Q.base[Q.back++] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_front(deQueue &Q) {\r\n// 		if (Q.front == Q.back) return 1;\r\n// 		else if (Q.front < Q.back) ++Q.front;\r\n// 		else if (Q.front == NUM - 1) Q.front = 1;\r\n// 		else ++Q.front;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_back(deQueue &Q) {\r\n// 		if (Q.back > Q.front) --Q.back;\r\n// 		else if (Q.back == Q.front) return 1;\r\n// 		else if (Q.back == 1) Q.back = NUM - 1;\r\n// 		else --Q.back;\r\n// 		return 0;\r\n// 	}\r\n// 	int size(deQueue &Q) {\r\n// 		if (Q.back >= Q.front) return Q.back - Q.front;\r\n// 		else return Q.back + NUM - Q.front; \r\n// 	}\r\n// 	Elemtype front(deQueue &Q) {\r\n// 		return Q.base[Q.front];\r\n// 	}\r\n// 	Elemtype back(deQueue &Q) {\r\n// 		return Q.base[Q.back];\r\n// 	}\r\n// }\r\n// using namespace deQueue;\r\n// myDeque q;\r\n\r\ndeque<pii> q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	q.clear();\r\n	q.push_back({x, 0});\r\n	while (!q.empty()) {\r\n		pii t = q.front(); q.pop_front();\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) q.push_front({e[i].to, dis});\r\n			else q.push_back({e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1072,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n \r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\nvector<pii> g[N];\r\ndeque<pii> q;\r\n \r\nvoid bfs(int x) {\r\n    memset(vis, 0, sizeof vis);\r\n    q.clear();\r\n    q.push_back({x, 0});\r\n    while (!q.empty()) {\r\n        pii t = q.front(); q.pop_front();\r\n        int u = t.first, dis = t.second;\r\n        if (vis[u]) continue;\r\n        d[x][u] = min(d[x][u], dis);\r\n        vis[u] = 1;\r\n        for (pii v: g[u])\r\n            if (v.second == 0) q.push_front({v.first, dis});\r\n            else q.push_back({v.first, dis + 1});\r\n    }\r\n}\r\n \r\nint main() {\r\n    memset(d, 0x3f, sizeof d);\r\n    scanf(\"%d%d\", &n, &m);\r\n    for (int i = 1, u, v, w; i <= m; i++) {\r\n        scanf(\"%d%d%d\", &u, &v, &w);\r\n        g[u].push_back({v, w});\r\n        g[v].push_back({u, w});\r\n    }\r\n    for (int i = 1; i <= n; i++)\r\n        bfs(i);\r\n    scanf(\"%d\", &qNum);\r\n    for (int u, v; qNum--;) {\r\n        cin >> u >> v;\r\n        if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n        else printf(\"%d\\n\", d[u][v]);\r\n    }\r\n    return 0;\r\n}'),(1073,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n \r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\nvector<pii> g[N];\r\ndeque<pii> q;\r\n \r\nvoid bfs(int x) {\r\n    memset(vis, 0, sizeof vis);\r\n    q.clear();\r\n    q.push_back({x, 0});\r\n    while (!q.empty()) {\r\n        pii t = q.front(); q.pop_front();\r\n        int u = t.first, dis = t.second;\r\n        if (vis[u]) continue;\r\n        d[x][u] = min(d[x][u], dis);\r\n        vis[u] = 1;\r\n        for (pii v: g[u])\r\n            if (v.second == 0) q.push_front({v.first, dis});\r\n            else q.push_back({v.first, dis + 1});\r\n    }\r\n}\r\n \r\nint main() {\r\n    memset(d, 0x3f, sizeof d);\r\n    scanf(\"%d%d\", &n, &m);\r\n    for (int i = 1, u, v, w; i <= m; i++) {\r\n        scanf(\"%d%d%d\", &u, &v, &w);\r\n        g[u].push_back({v, w});\r\n        g[v].push_back({u, w});\r\n    }\r\n    for (int i = 1; i <= n; i++)\r\n        bfs(i);\r\n    scanf(\"%d\", &qNum);\r\n    for (int u, v; qNum--;) {\r\n        cin >> u >> v;\r\n        if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n        else printf(\"%d\\n\", d[u][v]);\r\n    }\r\n    return 0;\r\n}'),(1074,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    cout << \"Hello World!\" << endl;\r\n    return 0;\r\n}'),(1075,'#include <stdio.h>\r\n#include <string.h>\r\n#define max(a,b) ((a)>(b)?(a):(b))\r\nconst int N=1e3+10;//qwq\r\nconst int M=1e3+10;\r\nint /*w[N],v[N],*/f[N];\r\nint p[N][N];\r\nint t,n,m;\r\nint main()\r\n{\r\n	scanf(\"%d%d%d\",&t,&n,&m);\r\n	for(int i=1;i<=t;i++)\r\n		for(int j=1;j<=n;j++)\r\n			scanf(\"%d\",&p[i][j]);\r\n	for(int k=1;k<t;k++)\r\n	{\r\n		memset(f,0,sizeof f); \r\n		for(int i=1;i<=n;i++)\r\n			for(int j=p[k][i];j<=m;j++)\r\n				f[j]=max(f[j],f[j-p[k][i]]+p[k+1][i]-p[k][i]);\r\n		m+=f[m];\r\n	}\r\n	printf(\"%d\\n\",m);\r\n	return 0;\r\n}'),(1076,'#include <iostream>\r\n#include <cstring>\r\n#include <cstdio>\r\n\r\nusing namespace std;\r\nconst int MAXN = 105;\r\n\r\n//dp[k]表示手里剩k元现金的时候，明天早上都卖了以后的钱数\r\n//price[i][j]表示第i天第j件物品的价格\r\nint dp[10005], price[MAXN][MAXN];\r\n\r\nint main() {\r\n    int t, n, m, ans;\r\n    scanf(\"%d%d%d\", &t, &n, &m);\r\n    //先输入\r\n    for (int i = 1; i <= t; ++i) {\r\n        for (int j = 1; j <= n; ++j) {\r\n            scanf(\"%d\", &price[i][j]);\r\n        }\r\n    }\r\n    //第一天早上手里有m元\r\n    ans = m;\r\n    for (int i = 1; i < t; ++i) {\r\n        //先把数组赋值为负无穷\r\n        memset(dp, ~0x3f, sizeof(dp));\r\n        //什么都不买，今天早上有ans元，明天早上也是ans元\r\n        dp[ans] = ans;\r\n        //枚举第j个物品\r\n        for (int j = 1; j <= n; ++j) {\r\n            //手里有k元的时候，去推明天早上的钱\r\n            for (int k = ans; k >= price[i][j]; --k) {\r\n                //买一件物品，现金减少，赚一份差价，完全背包倒着循环\r\n                dp[k - price[i][j]] = max(dp[k - price[i][j]], dp[k] + price[i + 1][j] - price[i][j]);\r\n            }\r\n        }\r\n        //找一下明天早上收益最大\r\n        int ma = 0;\r\n        for (int j = 0; j <= ans; ++j) {\r\n            ma = max(ma, dp[j]);\r\n        }\r\n        //明天早上就有这么多钱了，继续赚钱\r\n        ans = ma;\r\n    }\r\n    cout << ans << endl;\r\n    return 0;\r\n}\r\n'),(1077,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int N = 105, M = 10005;\r\nint t, n, m, ans, mx, f[M], p[N][N];\r\n\r\nint main() {\r\n	cin >> t >> n >> m;\r\n	for (int i = 1; i <= t; i++)\r\n		for (int j = 1; j <= n; j++) \r\n			cin >> p[i][j];\r\n	ans = m;\r\n	for (int i = 1; i < t; i++) {\r\n		memset(f, ~0x3f, sizeof f);\r\n		f[ans] = ans;\r\n		for (int j = 1; j <= n; j++)\r\n			for (int k = ans; k >= p[i][j]; k--)\r\n				f[k - p[i][j]] = max(f[k - p[i][j]], f[k] + p[i + 1][j] - p[i][j]);\r\n		mx = 0;\r\n		for (int j = 0; j <= ans; j++)\r\n			mx = max(ma, f[j]);\r\n		ans = mx;\r\n	}\r\n	cout << ans << endl;\r\n	return 0;\r\n}\r\n'),(1078,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int N = 105, M = 10005;\r\nint t, n, m, ans, mx, f[M], p[N][N];\r\n\r\nint main() {\r\n	cin >> t >> n >> m;\r\n	for (int i = 1; i <= t; i++)\r\n		for (int j = 1; j <= n; j++) \r\n			cin >> p[i][j];\r\n	ans = m;\r\n	for (int i = 1; i < t; i++) {\r\n		memset(f, ~0x3f, sizeof f);\r\n		f[ans] = ans;\r\n		for (int j = 1; j <= n; j++)\r\n			for (int k = ans; k >= p[i][j]; k--)\r\n				f[k - p[i][j]] = max(f[k - p[i][j]], f[k] + p[i + 1][j] - p[i][j]);\r\n		mx = 0;\r\n		for (int j = 0; j <= ans; j++)\r\n			mx = max(mx, f[j]);\r\n		ans = mx;\r\n	}\r\n	cout << ans << endl;\r\n	return 0;\r\n}\r\n'),(1079,'#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nsigned main()\r\n{\r\n	ios::sync_with_stdio(0);\r\n\r\n	cout << \"Hello World!\";\r\n}\r\n/*\r\n██╗   ██╗ █████╗ ███╗   ██╗ ██████╗ ███████╗██████╗\r\n╚██╗ ██╔╝██╔══██╗████╗  ██║██╔════╝ ╚══███╔╝██╔══██╗\r\n ╚████╔╝ ███████║██╔██╗ ██║██║  ███╗  ███╔╝ ██║  ██║\r\n  ╚██╔╝  ██╔══██║██║╚██╗██║██║   ██║ ███╔╝  ██║  ██║\r\n   ██║   ██║  ██║██║ ╚████║╚██████╔╝███████╗██████╔╝\r\n   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚══════╝╚═════╝\r\n*/\r\n\r\n'),(1080,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n\r\nconst int N = 1001;\r\nint l, r, ans, mid, tmp1, tmp2, flag;\r\nint t, n, nlen, a[N], b[N], c[N], d[N];\r\n\r\nint isok(int len) {\r\n	memset(a, 0, sizeof a);\r\n	memset(b, 0, sizeof b);\r\n	tmp2 = (len - 1) << 1;\r\n	for (int i = len - 1, j = 0; i >= 0; i--)\r\n		a[j++] = c[i];\r\n	for (int i = 0; i < len; i++)\r\n		for (int j = 0; j < len; j++)\r\n			b[i + j] += a[i] * a[j];\r\n	len = (len << 1) - 1;\r\n	for (int i = 0; i < len; i++)\r\n		b[i + 1] += b[i] / 10, b[i] %= 10;\r\n	while (b[len])\r\n		b[len + 1] += b[len] / 10, b[len++] %= 10;\r\n	if (len - tmp2 < nlen) return -1;\r\n	if (len - tmp2 > nlen) return 1;\r\n	tmp2 = len - 1;\r\n	for (int i = len - 1, j = nlen - 1; i >= 0 && j >= 0; i--, j--) {\r\n		if (d[j] > b[i]) return -1;\r\n		if (d[j] < b[i]) return 1;\r\n		tmp2 = i - 1;\r\n	}\r\n	while (tmp2 >= 0)\r\n		if (b[tmp2--])\r\n			return 1;\r\n	return 0;\r\n}\r\n\r\nsigned main() {\r\n	scanf(\"%lld\", &t);\r\n	while (t--) {\r\n		memset(c, 0, sizeof c);\r\n		flag = nlen = 0;\r\n		scanf(\"%lld\", &n);\r\n		tmp1 = n;\r\n		while (tmp1) {\r\n			d[nlen++] = tmp1 % 10;\r\n			tmp1 /= 10;\r\n		}\r\n//		cerr << \"inited\" << endl;\r\n		l = 1, r = n;\r\n		while (l <= r) {\r\n			mid = (l + r) >> 1;\r\n			c[0] = mid;\r\n			tmp1 = isok(1);\r\n			if (tmp1 > 0) r = mid - 1;\r\n			else if (tmp1 < 0) ans = mid, l = mid + 1;\r\n			else if (tmp1 == 0) {\r\n				ans = mid, flag = 1;\r\n				break;\r\n			}\r\n		}\r\n		c[0] = ans;\r\n//		cerr << \"calced c[0]\" << endl;\r\n		for (int i = 1; i <= 120; i++) {\r\n			if (flag) continue;\r\n			l = 0, r = 9;\r\n			while (l <= r) {\r\n				mid = (l + r) / 2;\r\n				c[i] = mid;\r\n				tmp1 = isok(i + 1);\r\n				if (tmp1 > 0) r = mid - 1;\r\n				else if (tmp1 < 0) ans = mid, l = mid + 1;\r\n				else if (tmp1 == 0) {\r\n					ans = mid, flag = 1;\r\n					break;\r\n				}\r\n			}\r\n			c[i] = ans;\r\n//			cerr << \"calced c[\" << i << \"]\" << endl;\r\n		}\r\n		tmp1 = -1;\r\n		for (int i = 120; i >= 1; i--)\r\n			if (c[i]) {\r\n				tmp1 = i;\r\n				break;\r\n			}\r\n		printf(\"%lld%s\", c[0], (tmp1 != -1? \".\" : \"\"));\r\n		for (int i = 1; i <= tmp1; i++)\r\n			printf(\"%lld\", c[i]);\r\n		printf(\"\\n\");\r\n	}\r\n	return 0;\r\n}'),(1081,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n\r\nconst int N = 1001;\r\nint l, r, ans, mid, tmp1, tmp2, flag;\r\nint t, n, nlen, a[N], b[N], c[N], d[N];\r\n\r\nint isok(int len) {\r\n	memset(a, 0, sizeof a);\r\n	memset(b, 0, sizeof b);\r\n	tmp2 = (len - 1) << 1;\r\n	for (int i = len - 1, j = 0; i >= 0; i--)\r\n		a[j++] = c[i];\r\n	for (int i = 0; i < len; i++)\r\n		for (int j = 0; j < len; j++)\r\n			b[i + j] += a[i] * a[j];\r\n	len = (len << 1) - 1;\r\n	for (int i = 0; i < len; i++)\r\n		b[i + 1] += b[i] / 10, b[i] %= 10;\r\n	while (b[len])\r\n		b[len + 1] += b[len] / 10, b[len++] %= 10;\r\n	if (len - tmp2 < nlen) return -1;\r\n	if (len - tmp2 > nlen) return 1;\r\n	tmp2 = len - 1;\r\n	for (int i = len - 1, j = nlen - 1; i >= 0 && j >= 0; i--, j--) {\r\n		if (d[j] > b[i]) return -1;\r\n		if (d[j] < b[i]) return 1;\r\n		tmp2 = i - 1;\r\n	}\r\n	while (tmp2 >= 0)\r\n		if (b[tmp2--])\r\n			return 1;\r\n	return 0;\r\n}\r\n\r\nsigned main() {\r\n	scanf(\"%lld\", &t);\r\n	while (t--) {\r\n		memset(c, 0, sizeof c);\r\n		flag = nlen = 0;\r\n		scanf(\"%lld\", &n);\r\n		tmp1 = n;\r\n		while (tmp1) {\r\n			d[nlen++] = tmp1 % 10;\r\n			tmp1 /= 10;\r\n		}\r\n//		cerr << \"inited\" << endl;\r\n		l = 1, r = n;\r\n		while (l <= r) {\r\n			mid = (l + r) >> 1;\r\n			c[0] = mid;\r\n			tmp1 = isok(1);\r\n			if (tmp1 > 0) r = mid - 1;\r\n			else if (tmp1 < 0) ans = mid, l = mid + 1;\r\n			else if (tmp1 == 0) {\r\n				ans = mid, flag = 1;\r\n				break;\r\n			}\r\n		}\r\n		c[0] = ans;\r\n//		cerr << \"calced c[0]\" << endl;\r\n		for (int i = 1; i <= 120; i++) {\r\n			if (flag) continue;\r\n			l = 0, r = 9;\r\n			while (l <= r) {\r\n				mid = (l + r) / 2;\r\n				c[i] = mid;\r\n				tmp1 = isok(i + 1);\r\n				if (tmp1 > 0) r = mid - 1;\r\n				else if (tmp1 < 0) ans = mid, l = mid + 1;\r\n				else if (tmp1 == 0) {\r\n					ans = mid, flag = 1;\r\n					break;\r\n				}\r\n			}\r\n			c[i] = ans;\r\n//			cerr << \"calced c[\" << i << \"]\" << endl;\r\n		}\r\n		tmp1 = -1;\r\n		for (int i = 120; i >= 1; i--)\r\n			if (c[i]) {\r\n				tmp1 = i;\r\n				break;\r\n			}\r\n		printf(\"%lld%s\", c[0], (tmp1 != -1? \".\" : \"\"));\r\n		for (int i = 1; i <= tmp1; i++)\r\n			printf(\"%lld\", c[i]);\r\n		printf(\"\\n\");\r\n	}\r\n	return 0;\r\n}'),(1082,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct folder {\r\n	bool type; // 1: folder, 0: file\r\n	string name, full;\r\n	map<string, bool> has;\r\n	map<string, folder*> child;\r\n	folder* father;\r\n} *root, *now, *p;\r\n\r\n/*\r\n * @brief Init File System\r\n * @example initFS()\r\n */\r\nvoid initFS() {\r\n	root = new folder;\r\n	root->name = \"\";\r\n	root->full = \"/\";\r\n	root->father = NULL;\r\n	now = root;\r\n	p = NULL;\r\n}\r\n\r\n/*\r\n * @brief Cut a string with \"/\"\r\n * @example cut(\"/root/c++\") -> [\"root\", \"c++\"]\r\n */\r\nvector<string> cut(string s) {\r\n	unsigned last = -1U;\r\n	vector<string> ret;\r\n	for (unsigned i = 0; i < s.size(); i++)\r\n		if (s[i] == \'/\') {\r\n//			cerr << \"Found s[\" << i << \"] is \'/\'\" << endl;\r\n			if (last == -1U) goto setLast;\r\n			ret.push_back(s.substr(last, i - last));\r\n			setLast: last = i + 1;\r\n		}\r\n	// avoid string like \"/root/c++/\"\r\n	if (last < s.size())\r\n		ret.push_back(s.substr(last));\r\n	return ret;\r\n}\r\n\r\n/*\r\n * @brief MaKe DIRectory\r\n * @example mkdir(\"/home/c++\") or mkdir(\"c++\")\r\n */\r\nvoid mkdir(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	for (string x: sep) {\r\n		if (p->has[x]) { \r\n			if (p->child[x]->type) p = p->child[x];\r\n			else {\r\n				cout << \"err\" << endl;\r\n				return;\r\n			}\r\n		} else {\r\n			p->has[x] = 1;\r\n			p->child[x] = new folder;\r\n			p->child[x]->type = 1;\r\n			p->child[x]->name = x;\r\n			p->child[x]->full = p->full + x + \"/\";\r\n			p->child[x]->father = p;\r\n			p = p->child[x];\r\n		}\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief See all the file and directory below now folder\r\n * @example ls()\r\n */\r\nvoid ls() {\r\n	bool flag = 0;\r\n	for (auto x: now->child) {\r\n		flag = 1;\r\n		if (x.second->type == 0) cout << \"*\";\r\n		cout << x.first << \" \";\r\n	}\r\n	if (!flag) cout << \"EMPTY\";\r\n	cout << endl;\r\n}\r\n\r\n/*\r\n * @brief Choose Directory\r\n * @example cd(\"c++\") or cd(\"../..\") etc\r\n */\r\nvoid cd(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	try { \r\n		for (string x: sep) {\r\n			if (x == \".\") continue;\r\n			else if (x == \"..\") p = p->father;\r\n			else if (!p->has[x]) throw \"err\";\r\n			else p = p->child[x];\r\n			if (p == NULL) throw \"err\";\r\n			if (p->type == 0) throw \"err\"; \r\n		}\r\n		now = p;\r\n	} catch (...) {\r\n		cout << \"err\" << endl;\r\n		return;\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief ReMove directory or file\r\n * @exapmle rm(\"c++\") or rm(\"/home\")\r\n */\r\nvoid rm(string s) {\r\n	string ori = (s[0] == \'/\'? \"\" : \"/\") + s;\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	try {\r\n		vector<string> tmp = cut(ori);\r\n		while (tmp.size() && *(--tmp.end()) == \".\")\r\n			tmp.pop_back();\r\n		if (tmp.empty()) throw \"err\";\r\n		for (string x: sep) {\r\n			if (x == \".\") continue;\r\n			else if (x == \"..\") p = p->father;\r\n			else if (!p->has[x]) throw \"err\";\r\n			else p = p->child[x];\r\n			if (p == NULL) throw \"err\"; \r\n		}\r\n		folder *temp = p;\r\n		p = p->father;\r\n		p->has.erase(*(--sep.end()));\r\n		p->child.erase(*(--sep.end()));\r\n		delete temp;\r\n	} catch (...) {\r\n		cout << \"err\" << endl;\r\n		return;\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief Create a file\r\n * @example touch(\"/etc/passwd\")\r\n */\r\nvoid touch(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	for (string x: sep) {\r\n		if (p->has[x]) { \r\n			if (p->child[x]->type) p = p->child[x];\r\n			else {\r\n				cout << \"err\" << endl;\r\n				return;\r\n			}\r\n		} else {\r\n			p->has[x] = 1;\r\n			p->child[x] = new folder;\r\n			p->child[x]->type = 1;\r\n			p->child[x]->name = x;\r\n			p->child[x]->full = p->full + x + \"/\";\r\n			p->child[x]->father = p;\r\n			p = p->child[x];\r\n		}\r\n	}\r\n	p = p->father;\r\n	p->child[*(--sep.end())]->type = 0;\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief See now work directory\r\n * @example pwd()\r\n */\r\nvoid pwd() {\r\n	cout << now->full << endl;\r\n}\r\n\r\nint main() {\r\n	int n;\r\n	cin >> n;\r\n	initFS();\r\n	while (n--) {\r\n		string op;\r\n		cin >> op;\r\n		if (op == \"mkdir\") {\r\n			string x;\r\n			cin >> x;\r\n			mkdir(x);\r\n		} else if (op == \"ls\") {\r\n			ls();\r\n		} else if (op == \"cd\") {\r\n			string x;\r\n			cin >> x;\r\n			cd(x);\r\n		} else if (op == \"rm\") {\r\n			string x;\r\n			cin >> x;\r\n			rm(x);\r\n		} else if (op == \"touch\") {\r\n			string x;\r\n			cin >> x;\r\n			touch(x);\r\n		} else if (op == \"pwd\") {\r\n			pwd();\r\n		}\r\n	}\r\n	return 0;\r\n}'),(1083,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct folder {\r\n	bool type; // 1: folder, 0: file\r\n	string name, full;\r\n	map<string, bool> has;\r\n	map<string, folder*> child;\r\n	folder* father;\r\n} *root, *now, *p;\r\n\r\n/*\r\n * @brief Init File System\r\n * @example initFS()\r\n */\r\nvoid initFS() {\r\n	root = new folder;\r\n	root->name = \"\";\r\n	root->full = \"/\";\r\n	root->father = NULL;\r\n	now = root;\r\n	p = NULL;\r\n}\r\n\r\n/*\r\n * @brief Cut a string with \"/\"\r\n * @example cut(\"/root/c++\") -> [\"root\", \"c++\"]\r\n */\r\nvector<string> cut(string s) {\r\n	unsigned last = -1U;\r\n	vector<string> ret;\r\n	for (unsigned i = 0; i < s.size(); i++)\r\n		if (s[i] == \'/\') {\r\n//			cerr << \"Found s[\" << i << \"] is \'/\'\" << endl;\r\n			if (last == -1U) goto setLast;\r\n			ret.push_back(s.substr(last, i - last));\r\n			setLast: last = i + 1;\r\n		}\r\n	// avoid string like \"/root/c++/\"\r\n	if (last < s.size())\r\n		ret.push_back(s.substr(last));\r\n	return ret;\r\n}\r\n\r\n/*\r\n * @brief MaKe DIRectory\r\n * @example mkdir(\"/home/c++\") or mkdir(\"c++\")\r\n */\r\nvoid mkdir(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	for (string x: sep) {\r\n		if (p->has[x]) { \r\n			if (p->child[x]->type) p = p->child[x];\r\n			else {\r\n				cout << \"err\" << endl;\r\n				return;\r\n			}\r\n		} else {\r\n			p->has[x] = 1;\r\n			p->child[x] = new folder;\r\n			p->child[x]->type = 1;\r\n			p->child[x]->name = x;\r\n			p->child[x]->full = p->full + x + \"/\";\r\n			p->child[x]->father = p;\r\n			p = p->child[x];\r\n		}\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief See all the file and directory below now folder\r\n * @example ls()\r\n */\r\nvoid ls() {\r\n	bool flag = 0;\r\n	for (auto x: now->child) {\r\n		flag = 1;\r\n		if (x.second->type == 0) cout << \"*\";\r\n		cout << x.first << \" \";\r\n	}\r\n	if (!flag) cout << \"EMPTY\";\r\n	cout << endl;\r\n}\r\n\r\n/*\r\n * @brief Choose Directory\r\n * @example cd(\"c++\") or cd(\"../..\") etc\r\n */\r\nvoid cd(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	try { \r\n		for (string x: sep) {\r\n			if (x == \".\") continue;\r\n			else if (x == \"..\") p = p->father;\r\n			else if (!p->has[x]) throw \"err\";\r\n			else p = p->child[x];\r\n			if (p == NULL) throw \"err\";\r\n			if (p->type == 0) throw \"err\"; \r\n		}\r\n		now = p;\r\n	} catch (...) {\r\n		cout << \"err\" << endl;\r\n		return;\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief ReMove directory or file\r\n * @exapmle rm(\"c++\") or rm(\"/home\")\r\n */\r\nvoid rm(string s) {\r\n	string ori = (s[0] == \'/\'? \"\" : \"/\") + s;\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	try {\r\n		vector<string> tmp = cut(ori);\r\n		while (tmp.size() && *(--tmp.end()) == \".\")\r\n			tmp.pop_back();\r\n		if (tmp.empty()) throw \"err\";\r\n		for (string x: sep) {\r\n			if (x == \".\") continue;\r\n			else if (x == \"..\") p = p->father;\r\n			else if (!p->has[x]) throw \"err\";\r\n			else p = p->child[x];\r\n			if (p == NULL) throw \"err\"; \r\n		}\r\n		folder *temp = p;\r\n		p = p->father;\r\n		p->has.erase(*(--sep.end()));\r\n		p->child.erase(*(--sep.end()));\r\n		delete temp;\r\n	} catch (...) {\r\n		cout << \"err\" << endl;\r\n		return;\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief Create a file\r\n * @example touch(\"/etc/passwd\")\r\n */\r\nvoid touch(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	for (string x: sep) {\r\n		if (p->has[x]) { \r\n			if (p->child[x]->type) p = p->child[x];\r\n			else {\r\n				cout << \"err\" << endl;\r\n				return;\r\n			}\r\n		} else {\r\n			p->has[x] = 1;\r\n			p->child[x] = new folder;\r\n			p->child[x]->type = 1;\r\n			p->child[x]->name = x;\r\n			p->child[x]->full = p->full + x + \"/\";\r\n			p->child[x]->father = p;\r\n			p = p->child[x];\r\n		}\r\n	}\r\n	p = p->father;\r\n	p->child[*(--sep.end())]->type = 0;\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief See now work directory\r\n * @example pwd()\r\n */\r\nvoid pwd() {\r\n	cout << now->full << endl;\r\n}\r\n\r\nint main() {\r\n	int n;\r\n	cin >> n;\r\n	initFS();\r\n	while (n--) {\r\n		string op;\r\n		cin >> op;\r\n		if (op == \"mkdir\") {\r\n			string x;\r\n			cin >> x;\r\n			mkdir(x);\r\n		} else if (op == \"ls\") {\r\n			ls();\r\n		} else if (op == \"cd\") {\r\n			string x;\r\n			cin >> x;\r\n			cd(x);\r\n		} else if (op == \"rm\") {\r\n			string x;\r\n			cin >> x;\r\n			rm(x);\r\n		} else if (op == \"touch\") {\r\n			string x;\r\n			cin >> x;\r\n			touch(x);\r\n		} else if (op == \"pwd\") {\r\n			pwd();\r\n		}\r\n	}\r\n	return 0;\r\n}'),(1084,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct folder {\r\n	bool type; // 1: folder, 0: file\r\n	string name, full;\r\n	map<string, bool> has;\r\n	map<string, folder*> child;\r\n	folder* father;\r\n} *root, *now, *p;\r\n\r\n/*\r\n * @brief Init File System\r\n * @example initFS()\r\n */\r\nvoid initFS() {\r\n	root = new folder;\r\n	root->type = 1;\r\n	root->name = \"\";\r\n	root->full = \"/\";\r\n	root->father = NULL;\r\n	now = root;\r\n	p = NULL;\r\n}\r\n\r\n/*\r\n * @brief Cut a string with \"/\"\r\n * @example cut(\"/root/c++\") -> [\"root\", \"c++\"]\r\n */\r\nvector<string> cut(string s) {\r\n	unsigned last = -1U;\r\n	vector<string> ret;\r\n	for (unsigned i = 0; i < s.size(); i++)\r\n		if (s[i] == \'/\') {\r\n//			cerr << \"Found s[\" << i << \"] is \'/\'\" << endl;\r\n			if (last == -1U) goto setLast;\r\n			ret.push_back(s.substr(last, i - last));\r\n			setLast: last = i + 1;\r\n		}\r\n	// avoid string like \"/root/c++/\"\r\n	if (last < s.size())\r\n		ret.push_back(s.substr(last));\r\n	return ret;\r\n}\r\n\r\n/*\r\n * @brief MaKe DIRectory\r\n * @example mkdir(\"/home/c++\") or mkdir(\"c++\")\r\n */\r\nvoid mkdir(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	bool flag = 0;\r\n	for (string x: sep) {\r\n		if (p->has[x]) { \r\n			if (p->child[x]->type) p = p->child[x];\r\n			else {\r\n				cout << \"err\" << endl;\r\n				return;\r\n			}\r\n		} else {\r\n			flag = 1;\r\n			p->has[x] = 1;\r\n			p->child[x] = new folder;\r\n			p->child[x]->type = 1;\r\n			p->child[x]->name = x;\r\n			p->child[x]->full = p->full + x + \"/\";\r\n			p->child[x]->father = p;\r\n			p = p->child[x];\r\n		}\r\n	}\r\n	if (flag == 0) cout << \"err\" << endl;\r\n	else cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief See all the file and directory below now folder\r\n * @example ls()\r\n */\r\nvoid ls() {\r\n	bool flag = 0;\r\n	for (auto x: now->child) {\r\n		flag = 1;\r\n		if (x.second->type == 0) cout << \"*\";\r\n		cout << x.first << \" \";\r\n	}\r\n	if (!flag) cout << \"EMPTY\";\r\n	cout << endl;\r\n}\r\n\r\n/*\r\n * @brief Choose Directory\r\n * @example cd(\"c++\") or cd(\"../..\") etc\r\n */\r\nvoid cd(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	try { \r\n		for (string x: sep) {\r\n			if (x == \".\") continue;\r\n			else if (x == \"..\") p = p->father;\r\n			else if (!p->has[x]) throw \"err\";\r\n			else p = p->child[x];\r\n			if (p == NULL) throw \"err\";\r\n			if (p->type == 0) throw \"err\"; \r\n		}\r\n		now = p;\r\n	} catch (...) {\r\n		cout << \"err\" << endl;\r\n		return;\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief ReMove directory or file\r\n * @exapmle rm(\"c++\") or rm(\"/home\")\r\n */\r\nvoid rm(string s) {\r\n	string ori = (s[0] == \'/\'? \"\" : \"/\") + s;\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	try {\r\n		vector<string> tmp = cut(ori);\r\n		while (tmp.size() && *(--tmp.end()) == \".\")\r\n			tmp.pop_back();\r\n		if (tmp.empty()) throw \"err\";\r\n		for (string x: sep) {\r\n			if (x == \".\") continue;\r\n			else if (x == \"..\") p = p->father;\r\n			else if (!p->has[x]) throw \"err\";\r\n			else p = p->child[x];\r\n			if (p == NULL) throw \"err\"; \r\n		}\r\n		folder *temp = p;\r\n		p = p->father;\r\n		p->has.erase(*(--sep.end()));\r\n		p->child.erase(*(--sep.end()));\r\n		delete temp;\r\n	} catch (...) {\r\n		cout << \"err\" << endl;\r\n		return;\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief Create a file\r\n * @example touch(\"/etc/passwd\")\r\n */\r\nvoid touch(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	for (string x: sep) {\r\n		if (p->has[x]) { \r\n			if (p->child[x]->type) p = p->child[x];\r\n			else {\r\n				cout << \"err\" << endl;\r\n				return;\r\n			}\r\n		} else {\r\n			p->has[x] = 1;\r\n			p->child[x] = new folder;\r\n			p->child[x]->type = 1;\r\n			p->child[x]->name = x;\r\n			p->child[x]->full = p->full + x + \"/\";\r\n			p->child[x]->father = p;\r\n			p = p->child[x];\r\n		}\r\n	}\r\n	p = p->father;\r\n	p->child[*(--sep.end())]->type = 0;\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief See now work directory\r\n * @example pwd()\r\n */\r\nvoid pwd() {\r\n	cout << now->full << endl;\r\n}\r\n\r\nint main() {\r\n	int n;\r\n	cin >> n;\r\n	initFS();\r\n	while (n--) {\r\n		string op;\r\n		cin >> op;\r\n		if (op == \"mkdir\") {\r\n			string x;\r\n			cin >> x;\r\n			mkdir(x);\r\n		} else if (op == \"ls\") {\r\n			ls();\r\n		} else if (op == \"cd\") {\r\n			string x;\r\n			cin >> x;\r\n			cd(x);\r\n		} else if (op == \"rm\") {\r\n			string x;\r\n			cin >> x;\r\n			rm(x);\r\n		} else if (op == \"touch\") {\r\n			string x;\r\n			cin >> x;\r\n			touch(x);\r\n		} else if (op == \"pwd\") {\r\n			pwd();\r\n		}\r\n	}\r\n	return 0;\r\n}'),(1085,'public class Main {\r\n	public static void main(String[] args) {\r\n		System.out.println(\"Hello World!\"); // 在这里插入 Hello World!\r\n	}\r\n}\r\n'),(1086,'<?php\r\necho \"\"; // 在这里插入 Hello World!\r\n'),(1087,'<?php\r\necho \"Hello World!\"; // 在这里插入 Hello World!\r\n'),(1088,'using System;\r\n\r\npublic class Main {\r\n	private static void Main(string[] args) {\r\n		Console.WriteLine(\"Hello World!\"); // 在这里插入 Hello World!\r\n	}\r\n}\r\n'),(1089,'using System;\r\n\r\npublic class HelloWorld {\r\n	private static void Main(string[] args) {\r\n		Console.WriteLine(\"Hello World!\"); // 在这里插入 Hello World!\r\n	}\r\n}\r\n'),(1090,'console.log(\"Hello World!\") // 在这里插入 Hello World!\r\nprocess.exit()\r\n'),(1091,'console.log(\"Hello World!\") // 在这里插入 Hello World!\r\nprocess.exit()\r\n'),(1092,'package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n	fmt.Println(\"Hello World\") // 在这里插入 Hello World!\r\n}\r\n'),(1093,'package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n	fmt.Println(\"Hello World\") // 在这里插入 Hello World!\r\n}\r\n'),(1094,'set serveroutput on;\r\n\r\nDECLARE\r\n	message	varchar2(20) := \'Hello World!\'; -- 在这里插入 Hello World!\r\nBEGIN\r\n	dbms_output.put_line(message);\r\nEND;\r\n\r\n/\r\n'),(1095,'console.log(\"Hello World!\") // 在这里插入 Hello World!\r\nprocess.exit()\r\n');
/*!40000 ALTER TABLE `source_code` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `source_code_user`
--

DROP TABLE IF EXISTS `source_code_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `source_code_user` (
  `solution_id` int(11) NOT NULL,
  `source` text NOT NULL,
  PRIMARY KEY (`solution_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `source_code_user`
--

LOCK TABLES `source_code_user` WRITE;
/*!40000 ALTER TABLE `source_code_user` DISABLE KEYS */;
INSERT INTO `source_code_user` VALUES (1001,'print(\"Hello World!\")'),(1002,'Hello World!'),(1003,'#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nsigned main()\r\n{\r\n    cout<<\"Hello World!\";\r\n    return 0;\r\n}'),(1004,'print(\"Hello World!\")'),(1005,'Hello World!'),(1006,'print(\"Hello World!\")'),(1007,'<?php\r\n    echo(\"Hello World!\")\r\n?>'),(1008,'<script languge=\"php\">\r\n    echo(\"Hello World!\");\r\n</script>'),(1009,'<?php\r\necho \"Hello World!\";\r\n?>'),(1010,'#include <cstdio>\nint main() {\n    int a, b;\n    return printf(\"%d\",(scanf(\"%d\",&a)&0|a)+(scanf(\"%d\",&b)&0|b))&0;\n}'),(1011,'# coding=utf-8\na, b = map(int, input().split())\nprint(a + b)'),(1012,'#include <bits/stdc++.h>\nusing namespace std;\nclass SegTree\n{\n	private:\n		struct Node\n		{\n			int Left,Right,Max,Delta;\n			Node *Lchild,*Rchild;\n		};\n	public:\n		Node *Tree=new Node;\n		void build(Node *cur,int L,int R)\n		{\n			cur->Left=L;\n			cur->Right=R;\n			if(L!=R)\n			{\n				cur->Lchild=new Node;\n				cur->Rchild=new Node;\n				cur->Max=cur->Delta=0;\n				build(cur->Lchild,L,L+R>>1);\n				build(cur->Rchild,(L+R>>1)+1,R);\n			}\n			else{cur->Lchild=cur->Rchild=NULL;cur->Max=cur->Delta=0;};\n		}\n		int query(Node *cur,int L,int R)\n		{\n			int ans=0;\n			if(L<=cur->Left&&cur->Right<=R)\n				ans=cur->Max+cur->Delta;\n			else\n			{\n				cur->Lchild->Delta+=cur->Delta;\n				cur->Rchild->Delta+=cur->Delta;\n				cur->Delta=0;\n				if(L<=cur->Left+cur->Right>>1)\n					ans=max(ans,query(cur->Lchild,L,R));\n				if(R> cur->Left+cur->Right>>1)\n					ans=max(ans,query(cur->Rchild,L,R));\n				cur->Max=max(cur->Lchild->Max+cur->Lchild->Delta,cur->Rchild->Max+cur->Rchild->Delta);\n			}\n			return ans;\n		}\n		void secupdate(Node *cur,int L,int R,int Change)\n		{\n			if(L<=cur->Left&&cur->Right<=R)\n				cur->Delta+=Change;\n			else\n			{\n				cur->Lchild->Delta+=cur->Delta;\n				cur->Rchild->Delta+=cur->Delta;\n				cur->Delta=0;\n				if(L<=cur->Left+cur->Right>>1)secupdate(cur->Lchild,L,R,Change);\n				if(R> cur->Left+cur->Right>>1)secupdate(cur->Rchild,L,R,Change);\n				cur->Max=max(cur->Lchild->Max+cur->Lchild->Delta,cur->Rchild->Max+cur->Rchild->Delta);\n			}\n		} \n};\nint c,s,r,o,d,n;\nSegTree S;\nint main()\n{\n	cin >> c >> s >> r;\n	S.build(S.Tree,1,c);\n	for(int i=1;i<=r;i++)\n	{\n		cin >> o >> d >> n;\n		if(S.query(S.Tree,o,d-1)+n<=s)\n		{\n			S.secupdate(S.Tree,o,d-1,n);\n			cout << \"YES\" << endl;\n		}\n		else cout << \"NO\" << endl;\n	}\n	return 0;\n}'),(1013,'print(\"Hello World!\")'),(1014,'a=int(input())\r\nb=int(input())\r\nsum=a+b\r\nprint(sum)'),(1015,'#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nsigned main()\r\n{\r\n	int a,b;\r\n	cin>>a>>b;\r\n	cout<<a+b;\r\n	return 0;\r\n}'),(1016,'#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ls (p*2)\r\n#define rs (p*2+1)\r\n#define mid (l+r>>1)\r\n#define lson ls,l,mid\r\n#define rson rs,mid+1,r\r\n#define maxn 60005\r\n#define int long long\r\n#define INF 0x3f3f3f3f\r\n\r\nint n,S,m;\r\nint sum[maxn<<2];\r\nint lazy_tag[maxn<<2];\r\n\r\nvoid Pushdown(int p,int l,int r)\r\n{\r\n    lazy_tag[ls]+=lazy_tag[p];\r\n    lazy_tag[rs]+=lazy_tag[p];\r\n    sum[ls]+=lazy_tag[p];\r\n    sum[rs]+=lazy_tag[p];\r\n    lazy_tag[p]=0;\r\n}\r\n\r\nvoid Add(int p,int l,int r,int s,int t,int z)\r\n{\r\n    if(s>r||t<l)\r\n        return ;\r\n    if(s<=l && r<=t)\r\n    {\r\n        sum[p]+=z;\r\n        lazy_tag[p]+=z; \r\n        return;\r\n    }\r\n    Pushdown(p,l,r);\r\n    Add(lson,s,t,z);\r\n    Add(rson,s,t,z);\r\n    sum[p]=max(sum[ls],sum[rs]);\r\n    return;\r\n}\r\n\r\nint Max(int p,int l,int r,int s,int t)\r\n{\r\n    if(s>r||t<l)\r\n        return -INF;\r\n    if(s<=l&&r<=t)\r\n        return sum[p];\r\n    Pushdown(p,l,r);\r\n    return max(Max(lson,s,t),Max(rson,s,t));\r\n}\r\n\r\nsigned main()\r\n{\r\n    cin>>n>>S>>m;\r\n    for(int i=1;i<=m;i++)\r\n    {\r\n        int x,y,z;\r\n        cin>>x>>y>>z;\r\n        y--;\r\n        if(x>y)\r\n            swap(x,y);\r\n        Add(1,1,n,x,y,z);\r\n        if(Max(1,1,n,x,y)>S)\r\n        {\r\n            cout<<\"NO\"<<endl;\r\n            Add(1,1,n,x,y,-z);\r\n        } \r\n        else\r\n            cout<<\"YES\"<<endl;\r\n    } \r\n    return 0;\r\n}'),(1017,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n    int a,b;\r\n    cin>>a>>b;\r\n    cout<<a+b;\r\n}'),(1018,'#include <bits/stdc++.h> \r\nusing namespace std;\r\n\r\nconst int N = 500001, INF = 0x3f3f3f3f;\r\n\r\nint n, m, a[N];\r\nstruct SegTree {\r\n	int l, r, s, lx, rx, ans;\r\n} t[N << 2];\r\n\r\nvoid build(int l, int r, int p = 1) {\r\n	t[p].l = l; t[p].r = r;\r\n	if (l == r) {\r\n		t[p].s = t[p].lx = t[p].rx = t[p].ans = a[l];\r\n		return;\r\n	}\r\n	int mid = (l + r) >> 1;\r\n	build(l      , mid, p << 1    );\r\n	build(mid + 1, r  , p << 1 | 1);\r\n	t[p].s   = t[p << 1].s + t[p << 1 | 1].s;\r\n	t[p].lx  = max(t[p << 1    ].lx, t[p << 1].s  + t[p << 1 | 1].lx);\r\n	t[p].rx  = max(t[p << 1 | 1].rx, t[p << 1].rx + t[p << 1 | 1].s );\r\n	t[p].ans = max(max(t[p << 1].ans, t[p << 1 | 1].ans), t[p << 1].rx + t[p << 1 | 1].lx);\r\n}\r\n\r\nvoid change(int x, int y, int p = 1) {\r\n	if (t[p].l == t[p].r) {\r\n		t[p].s = t[p].lx = t[p].rx = t[p].ans = y;\r\n		return;\r\n	}\r\n	int mid = (t[p].l + t[p].r) >> 1;\r\n	if (x <= mid) change(x, y, p << 1);\r\n	else          change(x, y, p << 1 | 1);\r\n	t[p].s   = t[p << 1].s + t[p << 1 | 1].s;\r\n	t[p].lx  = max(t[p << 1    ].lx, t[p << 1].s  + t[p << 1 | 1].lx);\r\n	t[p].rx  = max(t[p << 1 | 1].rx, t[p << 1].rx + t[p << 1 | 1].s );\r\n	t[p].ans = max(max(t[p << 1].ans, t[p << 1 | 1].ans), t[p << 1].rx + t[p << 1 | 1].lx);\r\n}\r\n\r\nSegTree ask(int l, int r, int p = 1) {\r\n	if (l <= t[p].l and r >= t[p].r) return t[p];\r\n	SegTree a, b, ans;\r\n	a.s = a.lx = a.rx = a.ans = -INF;\r\n	b.s = b.lx = b.rx = b.ans = -INF;\r\n	ans.s = 0;\r\n	int mid = (t[p].l + t[p].r) >> 1;\r\n	if (l <= mid) {\r\n		a = ask(l, r, p << 1);\r\n		ans.s += a.s;\r\n	}\r\n	if (r > mid) {\r\n		b = ask(l, r, p << 1 | 1);\r\n		ans.s += b.s;\r\n	}\r\n	ans.ans = max(max(a.ans, b.ans), a.rx + b.lx);\r\n	ans.lx  = max(a.lx, a.s + b.lx);\r\n	ans.rx  = max(b.rx, b.s + a.rx);\r\n	if (l > mid)  ans.lx = max(ans.lx, b.lx);\r\n	if (r <= mid) ans.rx = max(ans.rx, a.rx);\r\n	return ans;\r\n}\r\n\r\nint main() {\r\n	ios::sync_with_stdio(false);\r\n	cin.tie(nullptr); cout.tie(nullptr);\r\n	cin >> n >> m;\r\n	for (int i = 1; i <= n; i++)\r\n		cin >> a[i];\r\n	build(1, n);\r\n	while (m--) {\r\n		int t, x, y;\r\n		cin >> t >> x >> y;\r\n		if (t == 1) {\r\n			if (x > y) swap(x, y);\r\n			cout << ask(x, y).ans << endl;\r\n		}\r\n		else change(x, y);\r\n	}\r\n	return 0;\r\n}'),(1019,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ninline int read(){\r\n    int x=0,f=1;\r\n    char c=getchar();\r\n    while(c<\'0\'||c>\'9\'){\r\n        if(c==\'-\') f=-f;\r\n        c=getchar();\r\n    }\r\n    while(c>=\'0\'&&c<=\'9\'){\r\n        x=(x<<3)+(x<<1)+c-\'0\';\r\n        c=getchar();\r\n    }\r\n    return x*f;\r\n}\r\nconst int maxn=50010;\r\nint n,d[4*maxn],lmax[4*maxn],rmax[4*maxn],vmax[4*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build(n<<1|1,mid+1,r);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nint main(){\r\n    n=read();\r\n    for(int i=1;i<=n;i++) a[i]=read();\r\n	build(1,1,n);\r\n	q=read();\r\n    while(q--){\r\n        int op;\r\n        op=read();\r\n        if(op==0){\r\n            int id,x;\r\n            id=read();\r\n            x=read();\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n            ql=read();\r\n            qr=read();\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1020,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ninline int read(){\r\n    int x=0,f=1;\r\n    char c=getchar();\r\n    while(c<\'0\'||c>\'9\'){\r\n        if(c==\'-\') f=-f;\r\n        c=getchar();\r\n    }\r\n    while(c>=\'0\'&&c<=\'9\'){\r\n        x=(x<<3)+(x<<1)+c-\'0\';\r\n        c=getchar();\r\n    }\r\n    return x*f;\r\n}\r\nconst int maxn=50010;\r\nint n,d[4*maxn],lmax[4*maxn],rmax[4*maxn],vmax[4*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build(n<<1|1,mid+1,r);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nint main(){\r\n    n=read();\r\n    for(int i=1;i<=n;i++) a[i]=read();\r\n	build(1,1,n);\r\n	q=read();\r\n    while(q--){\r\n        int op;\r\n        op=read();\r\n        if(op==0){\r\n            int id,x;\r\n            id=read();\r\n            x=read();\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n            ql=read();\r\n            qr=read();\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1021,'#include<bits/stdc++.h> \r\nusing namespace std;\r\n\r\nint read()\r\n{\r\n    int f=1,x=0;\r\n    char ss=getchar();\r\n    while(ss<\'0\'||ss>\'9\'){if(ss==\'-\')f=-1;ss=getchar();}\r\n    while(ss>=\'0\'&&ss<=\'9\'){x=x*10+ss-\'0\';ss=getchar();}\r\n    return f*x;\r\n}\r\n\r\nconst int maxn=100010;\r\nint n,m;\r\nint rt;\r\nint val[maxn],sum[maxn];\r\nint ch[maxn][2],fa[maxn];\r\nint size[maxn];\r\nint lx[maxn],rx[maxn],mx[maxn];\r\n\r\nvoid update(int p)\r\n{\r\n    int lc=ch[p][0],rc=ch[p][1];\r\n    size[p]=size[lc]+size[rc]+1;\r\n    sum[p]=sum[lc]+sum[rc]+val[p];\r\n    lx[p]=max(lx[lc],sum[lc]+lx[rc]+val[p]);\r\n    rx[p]=max(rx[rc],sum[rc]+rx[lc]+val[p]);\r\n    mx[p]=max(max(mx[lc],mx[rc]),rx[lc]+lx[rc]+val[p]);\r\n}\r\n\r\nvoid build(int p,int ll,int rr)\r\n{\r\n    if(ll>rr) return;\r\n    int mid=ll+rr>>1;\r\n    fa[mid]=p; size[mid]=1;\r\n    ch[p][mid>p]=mid;\r\n    if(ll==rr) \r\n    { \r\n        lx[mid]=rx[mid]=max(val[mid],0);\r\n        sum[mid]=mx[mid]=val[mid];  return;\r\n    }\r\n    build(mid,ll,mid-1); build(mid,mid+1,rr);\r\n    update(mid);\r\n}\r\n\r\nvoid rotate(int &p,int x)\r\n{\r\n    int y=fa[x],z=fa[y];\r\n    int d=(ch[y][0]==x);\r\n    if(y==p) p=x;\r\n    else if(ch[z][0]==y) ch[z][0]=x;\r\n    else ch[z][1]=x;\r\n    fa[y]=x; fa[ch[x][d]]=y; fa[x]=z;\r\n    ch[y][d^1]=ch[x][d]; ch[x][d]=y;\r\n    update(y); update(x);\r\n}\r\n\r\n\r\nvoid splay(int &p,int x)\r\n{\r\n    while(x!=p)\r\n    {\r\n        int y=fa[x],z=fa[y];\r\n        if(y!=p)\r\n        {\r\n            if((ch[z][0]==y)^(ch[y][0]==x))rotate(p,x);\r\n            else rotate(p,y);\r\n        }\r\n        rotate(p,x);\r\n    }\r\n}\r\n\r\nint find(int p,int k) \r\n{ \r\n    int ss=size[ch[p][0]]; \r\n    if(k==ss+1) return p;    \r\n    else if(k<=ss) return find(ch[p][0],k);\r\n    else return find(ch[p][1],k-ss-1);  \r\n}\r\n\r\nvoid change(int k,int w)\r\n{\r\n    int x=find(rt,k); splay(rt,x);\r\n    int y=find(rt,k+2); splay(ch[rt][1],y);\r\n    int z=ch[y][0];\r\n    val[z]=mx[z]=sum[z]=w;\r\n    lx[z]=rx[z]=max(w,0);\r\n    update(y); update(x);\r\n}\r\n\r\nvoid query(int ll,int rr)\r\n{\r\n    int x=find(rt,ll); splay(rt,x);\r\n    int y=find(rt,rr+2); splay(ch[rt][1],y);\r\n    printf(\"%d\\n\",mx[ch[y][0]]);\r\n}\r\n\r\nint main()\r\n{\r\n    n=read();\r\n    mx[0]=val[1]=val[n+2]=-1e9;\r\n    for(int i=2;i<=n+1;++i)\r\n    val[i]=read();\r\n    rt=n+3>>1;\r\n    build(rt,1,n+2);\r\n    m=read();\r\n    while(m--)\r\n    {\r\n        int k=read(),x=read(),y=read();\r\n        if(k==0) change(x,y);\r\n        else if(k==1) query(x,y);\r\n    }\r\n    return 0;\r\n}'),(1022,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ninline int read(){\r\n    int x=0,f=1;\r\n    char c=getchar();\r\n    while(c<\'0\'||c>\'9\'){\r\n        if(c==\'-\') f=-f;\r\n        c=getchar();\r\n    }\r\n    while(c>=\'0\'&&c<=\'9\'){\r\n        x=(x<<3)+(x<<1)+c-\'0\';\r\n        c=getchar();\r\n    }\r\n    return x*f;\r\n}\r\nconst int maxn=50010;\r\nint n,d[4*maxn],lmax[4*maxn],rmax[4*maxn],vmax[4*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build(n<<1|1,mid+1,r);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nint main(){\r\n    n=read();\r\n    for(int i=1;i<=n;i++) a[i]=read();\r\n	build(1,1,n);\r\n	q=read();\r\n    while(q--){\r\n        int op;\r\n        op=read();\r\n        if(op==0){\r\n            int id,x;\r\n            id=read();\r\n            x=read();\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n            ql=read();\r\n            qr=read();\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1023,'#include<bits/stdc++.h> \r\nusing namespace std;\r\n\r\nint read()\r\n{\r\n    int f=1,x=0;\r\n    char ss=getchar();\r\n    while(ss<\'0\'||ss>\'9\'){if(ss==\'-\')f=-1;ss=getchar();}\r\n    while(ss>=\'0\'&&ss<=\'9\'){x=x*10+ss-\'0\';ss=getchar();}\r\n    return f*x;\r\n}\r\n\r\nconst int maxn=100010;\r\nint n,m;\r\nint rt;\r\nint val[maxn],sum[maxn];\r\nint ch[maxn][2],fa[maxn];\r\nint size[maxn];\r\nint lx[maxn],rx[maxn],mx[maxn];\r\n\r\nvoid update(int p)\r\n{\r\n    int lc=ch[p][0],rc=ch[p][1];\r\n    size[p]=size[lc]+size[rc]+1;\r\n    sum[p]=sum[lc]+sum[rc]+val[p];\r\n    lx[p]=max(lx[lc],sum[lc]+lx[rc]+val[p]);\r\n    rx[p]=max(rx[rc],sum[rc]+rx[lc]+val[p]);\r\n    mx[p]=max(max(mx[lc],mx[rc]),rx[lc]+lx[rc]+val[p]);\r\n}\r\n\r\nvoid build(int p,int ll,int rr)\r\n{\r\n    if(ll>rr) return;\r\n    int mid=ll+rr>>1;\r\n    fa[mid]=p; size[mid]=1;\r\n    ch[p][mid>p]=mid;\r\n    if(ll==rr) \r\n    { \r\n        lx[mid]=rx[mid]=max(val[mid],0);\r\n        sum[mid]=mx[mid]=val[mid];  return;\r\n    }\r\n    build(mid,ll,mid-1); build(mid,mid+1,rr);\r\n    update(mid);\r\n}\r\n\r\nvoid rotate(int &p,int x)\r\n{\r\n    int y=fa[x],z=fa[y];\r\n    int d=(ch[y][0]==x);\r\n    if(y==p) p=x;\r\n    else if(ch[z][0]==y) ch[z][0]=x;\r\n    else ch[z][1]=x;\r\n    fa[y]=x; fa[ch[x][d]]=y; fa[x]=z;\r\n    ch[y][d^1]=ch[x][d]; ch[x][d]=y;\r\n    update(y); update(x);\r\n}\r\n\r\nvoid splay(int &p,int x)\r\n{\r\n    while(x!=p)\r\n    {\r\n        int y=fa[x],z=fa[y];\r\n        if(y!=p)\r\n        {\r\n            if((ch[z][0]==y)^(ch[y][0]==x))rotate(p,x);\r\n            else rotate(p,y);\r\n        }\r\n        rotate(p,x);\r\n    }\r\n}\r\n\r\nint find(int p,int k) \r\n{ \r\n    int ss=size[ch[p][0]]; \r\n    if(k==ss+1) return p;    \r\n    else if(k<=ss) return find(ch[p][0],k);\r\n    else return find(ch[p][1],k-ss-1);  \r\n}\r\n\r\nvoid change(int k,int w)\r\n{\r\n    int x=find(rt,k); splay(rt,x);\r\n    int y=find(rt,k+2); splay(ch[rt][1],y);\r\n    int z=ch[y][0];\r\n    val[z]=mx[z]=sum[z]=w;\r\n    lx[z]=rx[z]=max(w,0);\r\n    update(y); update(x);\r\n}\r\n\r\nvoid query(int ll,int rr)\r\n{\r\n    int x=find(rt,ll); splay(rt,x);\r\n    int y=find(rt,rr+2); splay(ch[rt][1],y);\r\n    printf(\"%d\\n\",mx[ch[y][0]]);\r\n}\r\n\r\nint main()\r\n{\r\n    n=read();\r\n    mx[0]=val[1]=val[n+2]=-1e9;\r\n    for(int i=2;i<=n+1;i++)\r\n    	val[i]=read();\r\n    rt=n+3>>1;\r\n    build(rt,1,n+2);\r\n    m=read();\r\n    while(m--)\r\n    {\r\n        int k=read(),x=read(),y=read();\r\n        if(k==1) change(x,y);\r\n        else if(k==2) query(x,y);\r\n    }\r\n    return 0;\r\n}'),(1024,'#include<bits/stdc++.h> \r\n#define int long long\r\nusing namespace std;\r\n \r\nint read()\r\n{\r\n    int f=1,x=0;\r\n    char ss=getchar();\r\n    while(ss<\'0\'||ss>\'9\'){if(ss==\'-\')f=-1;ss=getchar();}\r\n    while(ss>=\'0\'&&ss<=\'9\'){x=x*10+ss-\'0\';ss=getchar();}\r\n    return f*x;\r\n}\r\n \r\nconst int maxn=100010;\r\nint n,m;\r\nint rt;\r\nint val[maxn],sum[maxn];\r\nint ch[maxn][2],fa[maxn];\r\nint size[maxn];\r\nint lx[maxn],rx[maxn],mx[maxn];\r\n \r\nvoid update(int p)\r\n{\r\n    int lc=ch[p][0],rc=ch[p][1];\r\n    size[p]=size[lc]+size[rc]+1;\r\n    sum[p]=sum[lc]+sum[rc]+val[p];\r\n    lx[p]=max(lx[lc],sum[lc]+lx[rc]+val[p]);\r\n    rx[p]=max(rx[rc],sum[rc]+rx[lc]+val[p]);\r\n    mx[p]=max(max(mx[lc],mx[rc]),rx[lc]+lx[rc]+val[p]);\r\n}\r\n \r\nvoid build(int p,int ll,int rr)\r\n{\r\n    if(ll>rr) return;\r\n    int mid=ll+rr>>1;\r\n    fa[mid]=p; size[mid]=1;\r\n    ch[p][mid>p]=mid;\r\n    if(ll==rr) \r\n    { \r\n        lx[mid]=rx[mid]=max(val[mid],0);\r\n        sum[mid]=mx[mid]=val[mid];  return;\r\n    }\r\n    build(mid,ll,mid-1); build(mid,mid+1,rr);\r\n    update(mid);\r\n}\r\n \r\nvoid rotate(int &p,int x)\r\n{\r\n    int y=fa[x],z=fa[y];\r\n    int d=(ch[y][0]==x);\r\n    if(y==p) p=x;\r\n    else if(ch[z][0]==y) ch[z][0]=x;\r\n    else ch[z][1]=x;\r\n    fa[y]=x; fa[ch[x][d]]=y; fa[x]=z;\r\n    ch[y][d^1]=ch[x][d]; ch[x][d]=y;\r\n    update(y); update(x);\r\n}\r\n \r\nvoid splay(int &p,int x)\r\n{\r\n    while(x!=p)\r\n    {\r\n        int y=fa[x],z=fa[y];\r\n        if(y!=p)\r\n        {\r\n            if((ch[z][0]==y)^(ch[y][0]==x))rotate(p,x);\r\n            else rotate(p,y);\r\n        }\r\n        rotate(p,x);\r\n    }\r\n}\r\n \r\nint find(int p,int k) \r\n{ \r\n    int ss=size[ch[p][0]]; \r\n    if(k==ss+1) return p;    \r\n    else if(k<=ss) return find(ch[p][0],k);\r\n    else return find(ch[p][1],k-ss-1);  \r\n}\r\n \r\nvoid change(int k,int w)\r\n{\r\n    int x=find(rt,k); splay(rt,x);\r\n    int y=find(rt,k+2); splay(ch[rt][1],y);\r\n    int z=ch[y][0];\r\n    val[z]=mx[z]=sum[z]=w;\r\n    lx[z]=rx[z]=max(w,0);\r\n    update(y); update(x);\r\n}\r\n \r\nvoid query(int ll,int rr)\r\n{\r\n    int x=find(rt,ll); splay(rt,x);\r\n    int y=find(rt,rr+2); splay(ch[rt][1],y);\r\n    printf(\"%d\\n\",mx[ch[y][0]]);\r\n}\r\n \r\nsigned main()\r\n{\r\n    n=read();\r\n    mx[0]=val[1]=val[n+2]=-1e9;\r\n    for(int i=2;i<=n+1;i++)\r\n        val[i]=read();\r\n    rt=n+3>>1;\r\n    build(rt,1,n+2);\r\n    m=read();\r\n    while(m--)\r\n    {\r\n        int k=read(),x=read(),y=read();\r\n        if(k==1) change(x,y);\r\n        else if(k==2) query(x,y);\r\n    }\r\n    return 0;\r\n}'),(1025,'#include<bits/stdc++.h> \r\n#define int long long\r\nusing namespace std;\r\n \r\nint read()\r\n{\r\n    int f=1,x=0;\r\n    char ss=getchar();\r\n    while(ss<\'0\'||ss>\'9\'){if(ss==\'-\')f=-1;ss=getchar();}\r\n    while(ss>=\'0\'&&ss<=\'9\'){x=x*10+ss-\'0\';ss=getchar();}\r\n    return f*x;\r\n}\r\n \r\nconst int maxn=100010;\r\nint n,m;\r\nint rt;\r\nint val[maxn],sum[maxn];\r\nint ch[maxn][2],fa[maxn];\r\nint size[maxn];\r\nint lx[maxn],rx[maxn],mx[maxn];\r\n \r\nvoid update(int p)\r\n{\r\n    int lc=ch[p][0],rc=ch[p][1];\r\n    size[p]=size[lc]+size[rc]+1;\r\n    sum[p]=sum[lc]+sum[rc]+val[p];\r\n    lx[p]=max(lx[lc],sum[lc]+lx[rc]+val[p]);\r\n    rx[p]=max(rx[rc],sum[rc]+rx[lc]+val[p]);\r\n    mx[p]=max(max(mx[lc],mx[rc]),rx[lc]+lx[rc]+val[p]);\r\n}\r\n \r\nvoid build(int p,int ll,int rr)\r\n{\r\n    if(ll>rr) return;\r\n    int mid=ll+rr>>1;\r\n    fa[mid]=p; size[mid]=1;\r\n    ch[p][mid>p]=mid;\r\n    if(ll==rr) \r\n    { \r\n        lx[mid]=rx[mid]=max(val[mid],0);\r\n        sum[mid]=mx[mid]=val[mid];  return;\r\n    }\r\n    build(mid,ll,mid-1); build(mid,mid+1,rr);\r\n    update(mid);\r\n}\r\n \r\nvoid rotate(int &p,int x)\r\n{\r\n    int y=fa[x],z=fa[y];\r\n    int d=(ch[y][0]==x);\r\n    if(y==p) p=x;\r\n    else if(ch[z][0]==y) ch[z][0]=x;\r\n    else ch[z][1]=x;\r\n    fa[y]=x; fa[ch[x][d]]=y; fa[x]=z;\r\n    ch[y][d^1]=ch[x][d]; ch[x][d]=y;\r\n    update(y); update(x);\r\n}\r\n \r\nvoid splay(int &p,int x)\r\n{\r\n    while(x!=p)\r\n    {\r\n        int y=fa[x],z=fa[y];\r\n        if(y!=p)\r\n        {\r\n            if((ch[z][0]==y)^(ch[y][0]==x))rotate(p,x);\r\n            else rotate(p,y);\r\n        }\r\n        rotate(p,x);\r\n    }\r\n}\r\n \r\nint find(int p,int k) \r\n{ \r\n    int ss=size[ch[p][0]]; \r\n    if(k==ss+1) return p;    \r\n    else if(k<=ss) return find(ch[p][0],k);\r\n    else return find(ch[p][1],k-ss-1);  \r\n}\r\n \r\nvoid change(int k,int w)\r\n{\r\n    int x=find(rt,k); splay(rt,x);\r\n    int y=find(rt,k+2); splay(ch[rt][1],y);\r\n    int z=ch[y][0];\r\n    val[z]=mx[z]=sum[z]=w;\r\n    lx[z]=rx[z]=max(w,0LL);\r\n    update(y); update(x);\r\n}\r\n \r\nvoid query(int ll,int rr)\r\n{\r\n    int x=find(rt,ll); splay(rt,x);\r\n    int y=find(rt,rr+2); splay(ch[rt][1],y);\r\n    printf(\"%d\\n\",mx[ch[y][0]]);\r\n}\r\n \r\nsigned main()\r\n{\r\n    n=read();\r\n    mx[0]=val[1]=val[n+2]=-1e9;\r\n    for(int i=2;i<=n+1;i++)\r\n        val[i]=read();\r\n    rt=n+3>>1;\r\n    build(rt,1,n+2);\r\n    m=read();\r\n    while(m--)\r\n    {\r\n        int k=read(),x=read(),y=read();\r\n        if(k==1) change(x,y);\r\n        else if(k==2) query(x,y);\r\n    }\r\n    return 0;\r\n}'),(1026,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\ninline int read(){\r\n    int x=0,f=1;\r\n    char c=getchar();\r\n    while(c<\'0\'||c>\'9\'){\r\n        if(c==\'-\') f=-f;\r\n        c=getchar();\r\n    }\r\n    while(c>=\'0\'&&c<=\'9\'){\r\n        x=(x<<3)+(x<<1)+c-\'0\';\r\n        c=getchar();\r\n    }\r\n    return x*f;\r\n}\r\nconst int maxn=50010;\r\nint n,d[4*maxn],lmax[4*maxn],rmax[4*maxn],vmax[4*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build(n<<1|1,mid+1,r);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nsigned main(){\r\n    cin>>n>>q;\r\n    for(int i=1;i<=n;i++) cin>>a[i];\r\n	build(1,1,n);\r\n    while(q--){\r\n        int op;\r\n        cin>>op;\r\n        if(op==2){\r\n            int id,x;\r\n            cin>>id>>x;\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n        	cin>>ql>>qr;\r\n        	if(ql>qr) swap(ql,qr);\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1027,'#include<bits/stdc++.h> \r\n#define int long long\r\nusing namespace std;\r\n \r\nint read()\r\n{\r\n    int f=1,x=0;\r\n    char ss=getchar();\r\n    while(ss<\'0\'||ss>\'9\'){if(ss==\'-\')f=-1;ss=getchar();}\r\n    while(ss>=\'0\'&&ss<=\'9\'){x=x*10+ss-\'0\';ss=getchar();}\r\n    return f*x;\r\n}\r\n \r\nconst int maxn=100010;\r\nint n,m;\r\nint rt;\r\nint val[maxn],sum[maxn];\r\nint ch[maxn][2],fa[maxn];\r\nint size[maxn];\r\nint lx[maxn],rx[maxn],mx[maxn];\r\n \r\nvoid update(int p)\r\n{\r\n    int lc=ch[p][0],rc=ch[p][1];\r\n    size[p]=size[lc]+size[rc]+1;\r\n    sum[p]=sum[lc]+sum[rc]+val[p];\r\n    lx[p]=max(lx[lc],sum[lc]+lx[rc]+val[p]);\r\n    rx[p]=max(rx[rc],sum[rc]+rx[lc]+val[p]);\r\n    mx[p]=max(max(mx[lc],mx[rc]),rx[lc]+lx[rc]+val[p]);\r\n}\r\n \r\nvoid build(int p,int ll,int rr)\r\n{\r\n    if(ll>rr) return;\r\n    int mid=ll+rr>>1;\r\n    fa[mid]=p; size[mid]=1;\r\n    ch[p][mid>p]=mid;\r\n    if(ll==rr) \r\n    { \r\n        lx[mid]=rx[mid]=max(val[mid],0LL);\r\n        sum[mid]=mx[mid]=val[mid];  return;\r\n    }\r\n    build(mid,ll,mid-1); build(mid,mid+1,rr);\r\n    update(mid);\r\n}\r\n \r\nvoid rotate(int &p,int x)\r\n{\r\n    int y=fa[x],z=fa[y];\r\n    int d=(ch[y][0]==x);\r\n    if(y==p) p=x;\r\n    else if(ch[z][0]==y) ch[z][0]=x;\r\n    else ch[z][1]=x;\r\n    fa[y]=x; fa[ch[x][d]]=y; fa[x]=z;\r\n    ch[y][d^1]=ch[x][d]; ch[x][d]=y;\r\n    update(y); update(x);\r\n}\r\n \r\nvoid splay(int &p,int x)\r\n{\r\n    while(x!=p)\r\n    {\r\n        int y=fa[x],z=fa[y];\r\n        if(y!=p)\r\n        {\r\n            if((ch[z][0]==y)^(ch[y][0]==x))rotate(p,x);\r\n            else rotate(p,y);\r\n        }\r\n        rotate(p,x);\r\n    }\r\n}\r\n \r\nint find(int p,int k) \r\n{ \r\n    int ss=size[ch[p][0]]; \r\n    if(k==ss+1) return p;    \r\n    else if(k<=ss) return find(ch[p][0],k);\r\n    else return find(ch[p][1],k-ss-1);  \r\n}\r\n \r\nvoid change(int k,int w)\r\n{\r\n    int x=find(rt,k); splay(rt,x);\r\n    int y=find(rt,k+2); splay(ch[rt][1],y);\r\n    int z=ch[y][0];\r\n    val[z]=mx[z]=sum[z]=w;\r\n    lx[z]=rx[z]=max(w,0LL);\r\n    update(y); update(x);\r\n}\r\n \r\nvoid query(int ll,int rr)\r\n{\r\n    int x=find(rt,ll); splay(rt,x);\r\n    int y=find(rt,rr+2); splay(ch[rt][1],y);\r\n    printf(\"%d\\n\",mx[ch[y][0]]);\r\n}\r\n \r\nsigned main()\r\n{\r\n    n=read();\r\n    mx[0]=val[1]=val[n+2]=-1e9;\r\n    for(int i=2;i<=n+1;i++)\r\n        val[i]=read();\r\n    rt=n+3>>1;\r\n    build(rt,1,n+2);\r\n    m=read();\r\n    while(m--)\r\n    {\r\n        int k=read(),x=read(),y=read();\r\n        if(k==1) change(x,y);\r\n        else if(k==2) query(x,y);\r\n    }\r\n    return 0;\r\n}'),(1028,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\ninline int read(){\r\n    int x=0,f=1;\r\n    char c=getchar();\r\n    while(c<\'0\'||c>\'9\'){\r\n        if(c==\'-\') f=-f;\r\n        c=getchar();\r\n    }\r\n    while(c>=\'0\'&&c<=\'9\'){\r\n        x=(x<<3)+(x<<1)+c-\'0\';\r\n        c=getchar();\r\n    }\r\n    return x*f;\r\n}\r\nconst int maxn=50010;\r\nint n,d[8*maxn],lmax[8*maxn],rmax[8*maxn],vmax[8*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build(n<<1|1,mid+1,r);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nsigned main(){\r\n    cin>>n>>q;\r\n    for(int i=1;i<=n;i++) cin>>a[i];\r\n	build(1,1,n);\r\n    while(q--){\r\n        int op;\r\n        cin>>op;\r\n        if(op==2){\r\n            int id,x;\r\n            cin>>id>>x;\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n        	cin>>ql>>qr;\r\n        	if(ql>qr) swap(ql,qr);\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1029,'#include<bits/stdc++.h> \r\n#define int long long\r\nusing namespace std;\r\n \r\nint read()\r\n{\r\n    int f=1,x=0;\r\n    char ss=getchar();\r\n    while(ss<\'0\'||ss>\'9\'){if(ss==\'-\')f=-1;ss=getchar();}\r\n    while(ss>=\'0\'&&ss<=\'9\'){x=x*10+ss-\'0\';ss=getchar();}\r\n    return f*x;\r\n}\r\n \r\nconst int maxn=100010;\r\nint n,m;\r\nint rt;\r\nint val[maxn],sum[maxn];\r\nint ch[maxn][2],fa[maxn];\r\nint size[maxn];\r\nint lx[maxn],rx[maxn],mx[maxn];\r\n \r\nvoid update(int p)\r\n{\r\n    int lc=ch[p][0],rc=ch[p][1];\r\n    size[p]=size[lc]+size[rc]+1;\r\n    sum[p]=sum[lc]+sum[rc]+val[p];\r\n    lx[p]=max(lx[lc],sum[lc]+lx[rc]+val[p]);\r\n    rx[p]=max(rx[rc],sum[rc]+rx[lc]+val[p]);\r\n    mx[p]=max(max(mx[lc],mx[rc]),rx[lc]+lx[rc]+val[p]);\r\n}\r\n \r\nvoid build(int p,int ll,int rr)\r\n{\r\n    if(ll>rr) return;\r\n    int mid=ll+rr>>1;\r\n    fa[mid]=p; size[mid]=1;\r\n    ch[p][mid>p]=mid;\r\n    if(ll==rr) \r\n    { \r\n        lx[mid]=rx[mid]=max(val[mid],0LL);\r\n        sum[mid]=mx[mid]=val[mid];  return;\r\n    }\r\n    build(mid,ll,mid-1); build(mid,mid+1,rr);\r\n    update(mid);\r\n}\r\n \r\nvoid rotate(int &p,int x)\r\n{\r\n    int y=fa[x],z=fa[y];\r\n    int d=(ch[y][0]==x);\r\n    if(y==p) p=x;\r\n    else if(ch[z][0]==y) ch[z][0]=x;\r\n    else ch[z][1]=x;\r\n    fa[y]=x; fa[ch[x][d]]=y; fa[x]=z;\r\n    ch[y][d^1]=ch[x][d]; ch[x][d]=y;\r\n    update(y); update(x);\r\n}\r\n \r\nvoid splay(int &p,int x)\r\n{\r\n    while(x!=p)\r\n    {\r\n        int y=fa[x],z=fa[y];\r\n        if(y!=p)\r\n        {\r\n            if((ch[z][0]==y)^(ch[y][0]==x))rotate(p,x);\r\n            else rotate(p,y);\r\n        }\r\n        rotate(p,x);\r\n    }\r\n}\r\n \r\nint find(int p,int k) \r\n{ \r\n    int ss=size[ch[p][0]]; \r\n    if(k==ss+1) return p;    \r\n    else if(k<=ss) return find(ch[p][0],k);\r\n    else return find(ch[p][1],k-ss-1);  \r\n}\r\n \r\nvoid change(int k,int w)\r\n{\r\n    int x=find(rt,k); splay(rt,x);\r\n    int y=find(rt,k+2); splay(ch[rt][1],y);\r\n    int z=ch[y][0];\r\n    val[z]=mx[z]=sum[z]=w;\r\n    lx[z]=rx[z]=max(w,0LL);\r\n    update(y); update(x);\r\n}\r\n \r\nvoid query(int ll,int rr)\r\n{\r\n    int x=find(rt,ll); splay(rt,x);\r\n    int y=find(rt,rr+2); splay(ch[rt][1],y);\r\n    printf(\"%d\\n\",mx[ch[y][0]]);\r\n}\r\n \r\nsigned main()\r\n{\r\n    n=read();\r\n    mx[0]=val[1]=val[n+2]=-1e9;\r\n    for(int i=2;i<=n+1;i++)\r\n        val[i]=read();\r\n    rt=n+3>>1;\r\n    build(rt,1,n+2);\r\n    m=read();\r\n    while(m--)\r\n    {\r\n        int k=read(),x=read(),y=read();\r\n        if(k==2) change(x,y);\r\n        else if(k==1) query(x,y);\r\n    }\r\n    return 0;\r\n}'),(1030,'while True:\r\n    print(\"Fuck GXOJ\")'),(1031,'//Author:XuHt\r\n#include <cstdio>\r\n#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst int N = 500006, INF = 0x3f3f3f3f;\r\nint n, m, a[N];\r\nstruct T {\r\n	int l, r, s, lx, rx, ans;\r\n} t[N*4];\r\n\r\nvoid build(int p, int l, int r) {\r\n	t[p].l = l;\r\n	t[p].r = r;\r\n	if (l == r) {\r\n		t[p].s = t[p].lx = t[p].rx = t[p].ans = a[l];\r\n		return;\r\n	}\r\n	int mid = (l + r) >> 1;\r\n	build(p << 1, l, mid);\r\n	build(p << 1 | 1, mid + 1, r);\r\n	t[p].s = t[p<<1].s + t[p<<1|1].s;\r\n	t[p].lx = max(t[p<<1].lx, t[p<<1].s + t[p<<1|1].lx);\r\n	t[p].rx = max(t[p<<1|1].rx, t[p<<1].rx + t[p<<1|1].s);\r\n	t[p].ans = max(max(t[p<<1].ans, t[p<<1|1].ans), t[p<<1].rx + t[p<<1|1].lx);\r\n}\r\n\r\nvoid change(int p, int x, int y) {\r\n	if (t[p].l == t[p].r) {\r\n		t[p].s = t[p].lx = t[p].rx = t[p].ans = y;\r\n		return;\r\n	}\r\n	int mid = (t[p].l + t[p].r) >> 1;\r\n	if (x <= mid) change(p << 1, x, y);\r\n	else change(p << 1 | 1, x, y);\r\n	t[p].s = t[p<<1].s + t[p<<1|1].s;\r\n	t[p].lx = max(t[p<<1].lx, t[p<<1].s + t[p<<1|1].lx);\r\n	t[p].rx = max(t[p<<1|1].rx, t[p<<1].rx + t[p<<1|1].s);\r\n	t[p].ans = max(max(t[p<<1].ans, t[p<<1|1].ans), t[p<<1].rx + t[p<<1|1].lx);\r\n}\r\n\r\nT ask(int p, int l, int r) {\r\n	if (l <= t[p].l && r >= t[p].r) return t[p];\r\n	T a, b, ans;\r\n	a.s = a.lx = a.rx = a.ans = b.s = b.lx = b.rx = b.ans = -INF;\r\n	ans.s = 0;\r\n	int mid = (t[p].l + t[p].r) >> 1;\r\n	if (l <= mid) {\r\n		a = ask(p << 1, l, r);\r\n		ans.s += a.s;\r\n	}\r\n	if (r > mid) {\r\n		b = ask(p << 1 | 1, l, r);\r\n		ans.s += b.s;\r\n	}\r\n	ans.ans = max(max(a.ans, b.ans), a.rx + b.lx);\r\n	ans.lx = max(a.lx, a.s + b.lx);\r\n	ans.rx = max(b.rx, b.s + a.rx);\r\n	if (l > mid) ans.lx = max(ans.lx, b.lx);\r\n	if (r <= mid) ans.rx = max(ans.rx, a.rx);\r\n	return ans;\r\n}\r\n\r\nint main() {\r\n	cin >> n >> m;\r\n	for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\r\n	build(1, 1, n);\r\n	while (m--) {\r\n		int t, x, y;\r\n		scanf(\"%d %d %d\", &t, &x, &y);\r\n		if (t == 1) {\r\n			if (x > y) swap(x, y);\r\n			cout << ask(1, x, y).ans << endl;\r\n		}\r\n		else change(1, x, y);\r\n	}\r\n	return 0;\r\n}'),(1032,'#include<bits/stdc++.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n    cout<<\"Hello World!\";\r\n    return 0;\r\n}'),(1033,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nconst int maxn=50010;\r\nint n,d[16*maxn],lmax[16*maxn],rmax[16*maxn],vmax[16*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build(n<<1|1,mid+1,r);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[n<<1]+d[n<<1|1];\r\n    lmax[n]=max(lmax[n<<1],d[n<<1]+lmax[n<<1|1]);\r\n    rmax[n]=max(rmax[n<<1|1],d[n<<1|1]+rmax[n<<1]);\r\n    vmax[n]=max(vmax[n<<1],max(vmax[n<<1|1],rmax[n<<1]+lmax[n<<1|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nsigned main(){\r\n    cin>>n>>q;\r\n    for(int i=1;i<=n;i++) cin>>a[i];\r\n	build(1,1,n);\r\n    while(q--){\r\n        int op;\r\n        cin>>op;\r\n        if(op==2){\r\n            int id,x;\r\n            cin>>id>>x;\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n        	cin>>ql>>qr;\r\n        	if(ql>qr) swap(ql,qr);\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1034,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nconst int maxn=50010;\r\nint n,d[16*maxn],lmax[16*maxn],rmax[16*maxn],vmax[16*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build((n<<1)|1,mid+1,r);\r\n    d[n]=d[(n<<1)]+d[(n<<1)|1];\r\n    lmax[n]=max(lmax[(n<<1)],d[(n<<1)]+lmax[(n<<1)|1]);\r\n    rmax[n]=max(rmax[(n<<1)|1],d[(n<<1)|1]+rmax[(n<<1)]);\r\n    vmax[n]=max(vmax[(n<<1)],max(vmax[(n<<1)|1],rmax[(n<<1)]+lmax[(n<<1)|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[(n<<1)]+d[(n<<1)|1];\r\n    lmax[n]=max(lmax[(n<<1)],d[(n<<1)]+lmax[(n<<1)|1]);\r\n    rmax[n]=max(rmax[(n<<1)|1],d[(n<<1)|1]+rmax[(n<<1)]);\r\n    vmax[n]=max(vmax[(n<<1)],max(vmax[(n<<1)|1],rmax[(n<<1)]+lmax[(n<<1)|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nsigned main(){\r\n    cin>>n>>q;\r\n    for(int i=1;i<=n;i++) cin>>a[i];\r\n	build(1,1,n);\r\n    while(q--){\r\n        int op;\r\n        cin>>op;\r\n        if(op==2){\r\n            int id,x;\r\n            cin>>id>>x;\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n        	cin>>ql>>qr;\r\n        	if(ql>qr) swap(ql,qr);\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1035,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nconst int maxn=500010;\r\nint n,d[4*maxn],lmax[4*maxn],rmax[4*maxn],vmax[4*maxn],a[maxn],q;\r\nvoid build(int n,int l,int r){\r\n    if(l==r){\r\n        d[n]=a[l];\r\n        lmax[n]=a[l];\r\n        rmax[n]=a[l];\r\n        vmax[n]=a[l];\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    build(n<<1,l,mid);\r\n    build((n<<1)|1,mid+1,r);\r\n    d[n]=d[(n<<1)]+d[(n<<1)|1];\r\n    lmax[n]=max(lmax[(n<<1)],d[(n<<1)]+lmax[(n<<1)|1]);\r\n    rmax[n]=max(rmax[(n<<1)|1],d[(n<<1)|1]+rmax[(n<<1)]);\r\n    vmax[n]=max(vmax[(n<<1)],max(vmax[(n<<1)|1],rmax[(n<<1)]+lmax[(n<<1)|1]));\r\n}\r\nvoid update(int n,int l,int r,int id,int x){\r\n    if(l==r){\r\n        d[n]=x;\r\n        lmax[n]=x;\r\n        rmax[n]=x;\r\n        vmax[n]=x;\r\n        return;\r\n	}\r\n    int mid=(l+r)>>1;\r\n    if(id<=mid) update(n<<1,l,mid,id,x);\r\n    else update(n<<1|1,mid+1,r,id,x);\r\n    d[n]=d[(n<<1)]+d[(n<<1)|1];\r\n    lmax[n]=max(lmax[(n<<1)],d[(n<<1)]+lmax[(n<<1)|1]);\r\n    rmax[n]=max(rmax[(n<<1)|1],d[(n<<1)|1]+rmax[(n<<1)]);\r\n    vmax[n]=max(vmax[(n<<1)],max(vmax[(n<<1)|1],rmax[(n<<1)]+lmax[(n<<1)|1]));\r\n}\r\nstruct answer{\r\n    int d,lmax,rmax,vmax;\r\n};\r\nanswer query(int n,int l,int r,int ql,int qr){\r\n    if(l==ql&&r==qr){\r\n        answer ans;\r\n        ans.d=d[n];\r\n        ans.lmax=lmax[n];\r\n        ans.rmax=rmax[n];\r\n        ans.vmax=vmax[n];\r\n        return ans;\r\n    }\r\n    int mid=(l+r)>>1;\r\n	if(qr<=mid) return query(n<<1,l,mid,ql,qr);\r\n    if(ql>mid) return query(n<<1|1,mid+1,r,ql,qr);\r\n	answer left,right,ans;\r\n    left=query(n<<1,l,mid,ql,mid);\r\n    right=query(n<<1|1,mid+1,r,mid+1,qr);\r\n    ans.d=left.d+right.d;\r\n    ans.lmax=max(left.lmax,left.d+right.lmax);\r\n    ans.rmax=max(right.rmax,right.d+left.rmax);\r\n    ans.vmax=max(left.vmax,max(right.vmax,right.lmax+left.rmax));\r\n	return ans;\r\n}\r\nsigned main(){\r\n    cin>>n>>q;\r\n    for(int i=1;i<=n;i++) cin>>a[i];\r\n	build(1,1,n);\r\n    while(q--){\r\n        int op;\r\n        cin>>op;\r\n        if(op==2){\r\n            int id,x;\r\n            cin>>id>>x;\r\n            update(1,1,n,id,x);\r\n        }\r\n		else{\r\n            int ql,qr;\r\n        	cin>>ql>>qr;\r\n        	if(ql>qr) swap(ql,qr);\r\n            answer ans=query(1,1,n,ql,qr);\r\n            cout<<ans.vmax<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}'),(1036,'#include<bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nint n, m, aa[50005];\r\nstruct segtree{\r\n	int l, r, lsum, rsum, sum, asum;\r\n}a[200005];\r\nvoid build(int i, int l, int r){\r\n	a[i].l=l, a[i].r=r;\r\n	if(l==r){\r\n		a[i].lsum=a[i].rsum=a[i].sum=a[i].asum=aa[l];\r\n		return;\r\n	}\r\n	int mid=(l+r)>>1;\r\n	build(i*2, l, mid);\r\n	build(i*2+1, mid+1, r);\r\n	a[i].asum=a[i*2].asum+a[i*2+1].asum;\r\n	a[i].lsum=max(a[i*2].lsum,a[i*2].asum+a[i*2+1].lsum);\r\n	a[i].rsum=max(a[i*2+1].rsum,a[i*2+1].asum+a[i*2].rsum);\r\n	a[i].sum=max(a[i*2].sum,max(a[i*2+1].sum,a[i*2].rsum+a[i*2+1].lsum));\r\n} \r\nsegtree ask(int i,int l, int r){\r\n	if(l<=a[i].l&&r>=a[i].r)return a[i];\r\n	segtree aa, b, ans;\r\n	aa.asum=aa.lsum=aa.rsum=aa.sum=-1e18;\r\n	b.asum=b.lsum=b.rsum=b.sum=-1e18;\r\n	ans.sum=0;\r\n	int x=a[i].l+a[i].r;\r\n	int mid=x>>1;\r\n	if(l<=mid){aa=ask(i*2, l, r);ans.sum+=aa.sum;}\r\n	if(r>mid){b=ask(i*2+1, l, r);ans.sum+=b.sum;}\r\n    ans.sum=max(max(aa.sum, b.sum), aa.rsum+b.lsum);\r\n    ans.lsum=max(aa.lsum,aa.sum+b.lsum);\r\n    ans.rsum=max(b.rsum,b.sum+aa.rsum);\r\n    if(l>mid)ans.lsum=max(ans.lsum, b.lsum);\r\n    if(r<=mid)ans.rsum=max(ans.rsum, aa.rsum);\r\n    return ans;\r\n}\r\nvoid update(int i, int x, int y){\r\n	if(a[i].l==a[i].r&&a[i].r==x){\r\n		a[i].asum=a[i].lsum=a[i].rsum=a[i].sum=y;\r\n		return;\r\n	}\r\n	if(a[i].l>x||a[i].r<x)return;\r\n	update(i*2, x, y);\r\n	update(i*2+1, x, y);\r\n	a[i].asum=a[i*2].asum+a[i*2+1].asum;\r\n	a[i].lsum=max(a[i*2].lsum, a[i*2].asum+a[i*2+1].lsum);\r\n	a[i].rsum=max(a[i*2+1].rsum, a[i*2+1].asum+a[i*2].rsum);\r\n	a[i].sum=max(a[i*2].sum,max(a[i*2+1].sum,a[i*2].rsum+a[i*2+1].lsum));\r\n}\r\nsigned main()\r\n{\r\n	ios::sync_with_stdio(0);\r\n	cin.tie(0);\r\n	cout.tie(0);\r\n	cin>>n;\r\n	for(int i=1; i<=n; i++)cin>>aa[i];\r\n	cin>>m;\r\n	build(1, 1, n);\r\n	while(m--){\r\n		int op, x, y;\r\n		cin>>op>>x>>y;\r\n		if(op)cout<<ask(1, x, y).sum<<endl;\r\n		else{\r\n			aa[x]=y;\r\n			update(1, x, y);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\n'),(1037,'#include<bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nint n, m, aa[50005];\r\nstruct segtree{\r\n	int l, r, lsum, rsum, sum, asum;\r\n}a[200005];\r\nvoid build(int i, int l, int r){\r\n	a[i].l=l, a[i].r=r;\r\n	if(l==r){\r\n		a[i].lsum=a[i].rsum=a[i].sum=a[i].asum=aa[l];\r\n		return;\r\n	}\r\n	int mid=(l+r)>>1;\r\n	build(i*2, l, mid);\r\n	build(i*2+1, mid+1, r);\r\n	a[i].asum=a[i*2].asum+a[i*2+1].asum;\r\n	a[i].lsum=max(a[i*2].lsum,a[i*2].asum+a[i*2+1].lsum);\r\n	a[i].rsum=max(a[i*2+1].rsum,a[i*2+1].asum+a[i*2].rsum);\r\n	a[i].sum=max(a[i*2].sum,max(a[i*2+1].sum,a[i*2].rsum+a[i*2+1].lsum));\r\n} \r\nsegtree ask(int i,int l, int r){\r\n	if(l<=a[i].l&&r>=a[i].r)return a[i];\r\n	segtree aa, b, ans;\r\n	aa.asum=aa.lsum=aa.rsum=aa.sum=-1e18;\r\n	b.asum=b.lsum=b.rsum=b.sum=-1e18;\r\n	ans.asum=0;\r\n	int mid=(a[i].l+a[i].r)>>1;\r\n	if(l<=mid){aa=ask(i*2, l, r);ans.asum+=aa.asum;}\r\n	if(r>mid){b=ask(i*2+1, l, r);ans.asum+=b.asum;}\r\n    ans.sum=max(max(aa.sum, b.sum), aa.rsum+b.lsum);\r\n    ans.lsum=max(aa.lsum,aa.asum+b.lsum);\r\n    ans.rsum=max(b.rsum,b.asum+aa.rsum);\r\n    if(l>mid)ans.lsum=max(ans.lsum, b.lsum);\r\n    if(r<=mid)ans.rsum=max(ans.rsum, aa.rsum);\r\n    return ans;\r\n}\r\nvoid update(int i, int x, int y){\r\n	if(a[i].l==a[i].r&&a[i].r==x){\r\n		a[i].asum=a[i].lsum=a[i].rsum=a[i].sum=y;\r\n		return;\r\n	}\r\n	if(a[i].l>x||a[i].r<x)return;\r\n	update(i*2, x, y);\r\n	update(i*2+1, x, y);\r\n	a[i].asum=a[i*2].asum+a[i*2+1].asum;\r\n	a[i].lsum=max(a[i*2].lsum, a[i*2].asum+a[i*2+1].lsum);\r\n	a[i].rsum=max(a[i*2+1].rsum, a[i*2+1].asum+a[i*2].rsum);\r\n	a[i].sum=max(a[i*2].sum,max(a[i*2+1].sum,a[i*2].rsum+a[i*2+1].lsum));\r\n}\r\nsigned main()\r\n{\r\n	ios::sync_with_stdio(0);\r\n	cin.tie(0);\r\n	cout.tie(0);\r\n	cin>>n;\r\n	for(int i=1; i<=n; i++)cin>>aa[i];\r\n	cin>>m;\r\n	build(1, 1, n);\r\n	while(m--){\r\n		int op, x, y;\r\n		cin>>op>>x>>y;\r\n		if(op)cout<<ask(1, x, y).sum<<endl;\r\n		else{\r\n			aa[x]=y;\r\n			update(1, x, y);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\n'),(1038,'#include<bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nint n, m, aa[500005];\r\nstruct segtree{\r\n	int l, r, lsum, rsum, sum, asum;\r\n}a[2000005];\r\nvoid build(int i, int l, int r){\r\n	a[i].l=l, a[i].r=r;\r\n	if(l==r){\r\n		a[i].lsum=a[i].rsum=a[i].sum=a[i].asum=aa[l];\r\n		return;\r\n	}\r\n	int mid=(l+r)>>1;\r\n	build(i*2, l, mid);\r\n	build(i*2+1, mid+1, r);\r\n	a[i].asum=a[i*2].asum+a[i*2+1].asum;\r\n	a[i].lsum=max(a[i*2].lsum,a[i*2].asum+a[i*2+1].lsum);\r\n	a[i].rsum=max(a[i*2+1].rsum,a[i*2+1].asum+a[i*2].rsum);\r\n	a[i].sum=max(a[i*2].sum,max(a[i*2+1].sum,a[i*2].rsum+a[i*2+1].lsum));\r\n} \r\nsegtree ask(int i,int l, int r){\r\n	if(l<=a[i].l&&r>=a[i].r)return a[i];\r\n	segtree aa, b, ans;\r\n	aa.asum=aa.lsum=aa.rsum=aa.sum=-1e18;\r\n	b.asum=b.lsum=b.rsum=b.sum=-1e18;\r\n	ans.asum=0;\r\n	int mid=(a[i].l+a[i].r)>>1;\r\n	if(l<=mid){aa=ask(i*2, l, r);ans.asum+=aa.asum;}\r\n	if(r>mid){b=ask(i*2+1, l, r);ans.asum+=b.asum;}\r\n    ans.sum=max(max(aa.sum, b.sum), aa.rsum+b.lsum);\r\n    ans.lsum=max(aa.lsum,aa.asum+b.lsum);\r\n    ans.rsum=max(b.rsum,b.asum+aa.rsum);\r\n    if(l>mid)ans.lsum=max(ans.lsum, b.lsum);\r\n    if(r<=mid)ans.rsum=max(ans.rsum, aa.rsum);\r\n    return ans;\r\n}\r\nvoid update(int i, int x, int y){\r\n	if(a[i].l==a[i].r&&a[i].r==x){\r\n		a[i].asum=a[i].lsum=a[i].rsum=a[i].sum=y;\r\n		return;\r\n	}\r\n	if(a[i].l>x||a[i].r<x)return;\r\n	update(i*2, x, y);\r\n	update(i*2+1, x, y);\r\n	a[i].asum=a[i*2].asum+a[i*2+1].asum;\r\n	a[i].lsum=max(a[i*2].lsum, a[i*2].asum+a[i*2+1].lsum);\r\n	a[i].rsum=max(a[i*2+1].rsum, a[i*2+1].asum+a[i*2].rsum);\r\n	a[i].sum=max(a[i*2].sum,max(a[i*2+1].sum,a[i*2].rsum+a[i*2+1].lsum));\r\n}\r\nsigned main()\r\n{\r\n	ios::sync_with_stdio(0);\r\n	cin.tie(0);\r\n	cout.tie(0);\r\n	cin>>n;\r\n	for(int i=1; i<=n; i++)cin>>aa[i];\r\n	cin>>m;\r\n	build(1, 1, n);\r\n	while(m--){\r\n		int op, x, y;\r\n		cin>>op>>x>>y;\r\n		if(op)cout<<ask(1, x, y).sum<<endl;\r\n		else{\r\n			aa[x]=y;\r\n			update(1, x, y);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\n'),(1039,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nconst int N=15004,M=40004;\r\nint m,n,book[N],x[M],A[N],B[N],C[N],D[N];\r\nint main()\r\n{\r\n	cin >> m >> n;\r\n	for(int i=1;i<=n;i++)\r\n		cin >> x[i],book[x[i]]++;\r\n	for(int t=1;t*9<m;t++)\r\n	{\r\n		int sum=0;\r\n		for(int d=9*t+2;d<=m;d++)\r\n		{\r\n			int c=d-t,b=d-7*t-1,a=b-2*t;\r\n			sum+=book[a]*book[b];\r\n			D[d]+=book[c]*sum;\r\n			C[c]+=book[d]*sum;\r\n		}\r\n		sum=0;\r\n		for(int a=m-9*t-1;a;a--)\r\n		{\r\n			int b=a+2*t,c=b+6*t+1,d=c+t;\r\n			sum+=book[c]*book[d];\r\n			A[a]+=book[b]*sum;\r\n			B[b]+=book[a]*sum;\r\n		}\r\n	}\r\n	for(int i=1;i<=n;i++)\r\n		cout << A[x[i]] << \' \' << B[x[i]] << \' \' << C[x[i]] << \' \' << D[x[i]] << endl;\r\n	return 0;\r\n}'),(1040,'#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint a[15005],b[15005],c[15005],d[15005],w[15005],h[40005],n,m,x,y;\r\n\r\nint main()\r\n{\r\n	cin>>n>>m;\r\n	if(n<11)\r\n	{\r\n		for(int i=1;i<=m;i++)\r\n		    printf(\"0 0 0 0\\n\");\r\n		return 0;\r\n	}\r\n	for(int i=1;i<=m;i++)\r\n	{\r\n	    cin>>h[i];\r\n		w[h[i]]++;\r\n	}\r\n	for(int i=1;i<=n/9;i++)\r\n	{\r\n		x=1+9*i,y=0;\r\n		for(int j=2+9*i;j<=n;j++)\r\n		{\r\n		\r\n			y+=w[j-x]*w[j-x+i+i];\r\n			d[j]+=y*w[j-i];\r\n			c[j-i]+=y*w[j];\r\n		}\r\n		x=8*i+1,y=0;\r\n		for(int j=n-9*i-1;j>=1;j--)\r\n		{\r\n			y+=w[j+x]*w[j+x+i];\r\n			a[j]+=y*w[j+i+i];\r\n			b[j+i+i]+=y*w[j];\r\n		}\r\n	}\r\n	for(int i=1;i<=m;i++)\r\n		cout<<a[h[i]]<<\' \'<<b[h[i]]<<\' \'<<c[h[i]]<<\' \'<<d[h[i]]<<endl;\r\n}'),(1041,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// Template by xcx0902\r\n// Copyright 2022\r\n\r\n#define int long long\r\n\r\nbool ismulti = false;\r\n\r\n// Pair cin & cout\r\n\r\ntemplate <typename tp1, typename tp2>\r\nistream& operator >> (istream &in, pair<tp1, tp2> &p) {\r\n	in >> p.first >> p.second;\r\n	return in;\r\n}\r\n\r\ntemplate <typename tp1, typename tp2>\r\nostream& operator << (ostream &out, const pair<tp1, tp2> &p) {\r\n	out << p.first << \" \" << p.second;\r\n	out.flush();\r\n	return out;\r\n}\r\n\r\n// Read & Write\r\n\r\ntemplate <typename type>\r\nvoid read(type a[], int ed, int st = 1) {\r\n	for (int i = st; i <= ed; i++)\r\n		cin >> a[i];\r\n}\r\n\r\ntemplate <typename type>\r\nvoid read(vector<type> &v, int sz = 0) {\r\n	if(sz) v.resize(sz);\r\n	for (auto &p: v)\r\n		cin >> p;\r\n}\r\n\r\ntemplate <typename type>\r\nistream& operator >> (istream &in, vector<type> &v) {\r\n	for (auto &p: v)\r\n		in >> p;\r\n	return in;\r\n}\r\n\r\ntemplate <typename type>\r\nvoid write(type a[], int ed, int st = 1, string sep = \" \", string last = \"\\n\") {\r\n	for (int i = st; i <= ed; i++)\r\n		cout << a[i] << (i != ed? sep: last);\r\n	cout.flush();\r\n}\r\n\r\ntemplate <typename type>\r\nvoid write(vector<type> v, string sep = \" \", string last = \"\\n\") {\r\n	for (int i = 0; i < v.size(); i++)\r\n		cout << v[i] << (i != v.size() - 1? sep: last);\r\n	cout.flush();\r\n}\r\n\r\ntemplate <typename type>\r\nostream& operator << (ostream &out, const vector<type> &v) {\r\n	for (auto p: v)\r\n		out << p << \" \";\r\n	out.flush();\r\n	return out;\r\n}\r\n\r\n// Some Functions\r\n\r\nint gcd(int a, int b) {\r\n	return !b? a: gcd(b, a % b);\r\n}\r\n\r\nint lcm(int a, int b) {\r\n	return a * b / gcd(a, b);\r\n}\r\n\r\nint popcount(int x, int p = 2) {\r\n	int count = 0;\r\n	while(x) {\r\n		count++;\r\n		x /= p;\r\n	}\r\n	return count;\r\n}\r\n\r\nint lowbit(int x) {\r\n	return x & (-x);\r\n}\r\n\r\nint isqrt(int x) {\r\n	int l = 0, r = 3e9, ans = 0, mid;\r\n	while (l <= r) {\r\n		mid = (l + r) >> 1;\r\n		if (mid * mid <= x) l = mid + 1, ans = mid;\r\n		else r = mid - 1;\r\n	}\r\n	return ans;\r\n}\r\n\r\nint ilog2(int x) {\r\n	return popcount(x) - 1;\r\n}\r\n\r\nint ilog10(int x) {\r\n	return popcount(x, 10) - 1;\r\n}\r\n\r\nint ilogk(int x, int k) {\r\n	return popcount(x, k) - 1;\r\n}\r\n\r\nint qpow(int a, int b, int p) {\r\n	if (b == 0) return 1 % p;\r\n	if (b == 1) return a % p;\r\n	int tmp = qpow(a, b / 2, p) % p;\r\n	if (b % 2) return tmp * tmp % p * a % p;\r\n	else       return tmp * tmp % p;\r\n}\r\n\r\nint binarySearch(int l, int r, bool (*check)(int), int ans = 0) {\r\n	int mid = 0;\r\n	while (l <= r) {\r\n		mid = (l + r) >> 1;\r\n		if (check(mid)) l = mid + 1, ans = mid;\r\n		else r = mid - 1;\r\n	}\r\n	return ans;\r\n}\r\n\r\ndouble binarySearch(double l, double r, bool (*check)(double), double eps = 1e-6, double ans = 0) {\r\n	double mid = 0;\r\n	while(abs(l - r) > eps) {\r\n		mid = (l + r) / 2;\r\n		if (check(mid)) l = mid, ans = mid;\r\n		else r = mid;\r\n	}\r\n	return ans;\r\n}\r\n\r\nint getDivisor(int a[], int n, int cnt = 1) {\r\n	int tmp = cnt;\r\n	for (int i = 1; i * i <= n; i++)\r\n		if (n % i == 0) {\r\n			a[cnt++] = i;\r\n			if (i * i != n)\r\n				a[cnt++] = n / i;\r\n		}\r\n	cnt--;\r\n	sort(a + tmp, a + cnt + 1);\r\n	return cnt;\r\n}\r\n\r\nint getDivisor(vector<int> &v, int n) {\r\n	for (int i = 1; i * i <= n; i++)\r\n		if (n % i == 0) {\r\n			v.push_back(i);\r\n			if (i * i != n)\r\n				v.push_back(n / i);\r\n		}\r\n	sort(v.begin(), v.end());\r\n	return v.size();\r\n}\r\n\r\n// Yes & No, Possible & Impossible, ...\r\n\r\nvoid yes(bool ex = (!ismulti)) {\r\n	cout << \"yes\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid Yes(bool ex = (!ismulti)) {\r\n	cout << \"Yes\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid YES(bool ex = (!ismulti)) {\r\n	cout << \"YES\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid no(bool ex = (!ismulti)) {\r\n	cout << \"no\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid No(bool ex = (!ismulti)) {\r\n	cout << \"No\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid NO(bool ex = (!ismulti)) {\r\n	cout << \"NO\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid yesno(bool flag, bool ex = (!ismulti)) {\r\n	if (flag) cout << \"yes\" << endl;\r\n	else cout << \"no\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid YesNo(bool flag, bool ex = (!ismulti)) {\r\n	if (flag) cout << \"Yes\" << endl;\r\n	else cout << \"No\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid YESNO(bool flag, bool ex = (!ismulti)) {\r\n	if (flag) cout << \"YES\" << endl;\r\n	else cout << \"NO\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\n// Some data structures\r\n\r\nclass DJU {\r\n	private :\r\n		std::vector<unsigned> f, sz;\r\n	public :\r\n		DJU() {\r\n		}\r\n		DJU(unsigned _sz) {\r\n			f = sz = std::vector<unsigned> (_sz + 1);\r\n			for (unsigned i = 1; i <= _sz; i++)\r\n				f[i] = i, sz[i] = 1;\r\n		}\r\n		unsigned find(unsigned x) {\r\n			if (f[x] == x) return x;\r\n			return f[x] = find(f[x]);\r\n		}\r\n		bool same(unsigned x, unsigned y) {\r\n			if (find(x) == find(y)) return true;\r\n			else return false;\r\n		}\r\n		void merge(unsigned x, unsigned y) {\r\n			unsigned fx = find(x);\r\n			unsigned fy = find(y);\r\n			f[fx] = fy;\r\n			sz[fy] += sz[fx];\r\n		}\r\n		unsigned size(unsigned x) {\r\n			return sz[find(x)];\r\n		}\r\n};\r\n\r\ntemplate <typename tp>\r\nclass BIT {\r\n	private :\r\n		vector<tp> c; // from 1 to N\r\n		unsigned sz;\r\n		unsigned lowbit(unsigned x) {\r\n			return x & (-x);\r\n		}\r\n\r\n	public :\r\n		BIT() {\r\n		}\r\n		BIT(unsigned _sz) {\r\n			c = vector<tp> (_sz + 1);\r\n			sz= _sz;\r\n		}\r\n		tp getsum(unsigned dx) { // return sum of [1..dx]\r\n			tp ret = 0;\r\n			while(dx) {\r\n				ret += c[dx];\r\n				dx -= lowbit(dx);\r\n			}\r\n			return ret;\r\n		}\r\n		tp sum(unsigned l,unsigned r) { // return sum of [l..r]\r\n			return getsum(r) - getsum(l - 1);\r\n		}\r\n		tp get(unsigned dx) { // return value[dx]\r\n			return sum(dx,dx);\r\n		}\r\n		tp add(unsigned dx,tp val) { // return after add\r\n			unsigned tmp = dx;\r\n			while(dx <= sz) {\r\n				c[dx] += val;\r\n				dx += lowbit(dx);\r\n			}\r\n			return c[tmp];\r\n		}\r\n		tp change(unsigned dx,tp val) { // return after change\r\n			return add(dx,val - get(dx));\r\n		}\r\n};\r\n\r\ntemplate <typename tp>\r\nclass unauthorizedGraph {\r\n	private :\r\n		unsigned sz;\r\n	public :\r\n		vector<vector<tp> > gv;\r\n		vector<tp>& operator [] (unsigned x) {\r\n			return gv[x];\r\n		}\r\n		unauthorizedGraph() {\r\n		}\r\n		~unauthorizedGraph() {\r\n			sz = 0;\r\n			gv.resize(0);\r\n		}\r\n		unauthorizedGraph(unsigned _sz) {\r\n			sz = _sz;\r\n			gv.resize(_sz + 1);\r\n		}\r\n		void readGraph(unsigned n, unsigned m, bool directed = false) {\r\n			sz = n;\r\n			gv.resize(n + 1);\r\n			for (int i = 1; i <= m; i++) {\r\n				tp u, v;\r\n				cin >> u >> v;\r\n				gv[u].push_back(v);\r\n				if (directed == false)\r\n					gv[v].push_back(u);\r\n			}\r\n		}\r\n};\r\n\r\ntemplate <typename tp, typename tpw>\r\nclass authorizedGraph {\r\n	private :\r\n		unsigned sz;\r\n	public :\r\n		vector<vector<pair<tp, tpw> > > gv;\r\n		vector<pair<tp, tpw> >& operator [] (unsigned x) {\r\n			return gv[x];\r\n		}\r\n		authorizedGraph() {\r\n		}\r\n		~authorizedGraph() {\r\n			sz = 0;\r\n			gv.resize(0);\r\n		}\r\n		authorizedGraph(unsigned _sz) {\r\n			sz = _sz;\r\n			gv.resize(_sz + 1);\r\n		}\r\n		void readGraph(unsigned n, unsigned m, bool directed = false) {\r\n			sz = n;\r\n			gv.resize(n + 1);\r\n			for (int i = 1; i <= m; i++) {\r\n				tp u, v; tpw w;\r\n				cin >> u >> v >> w;\r\n				gv[u].push_back(make_pair(v, w));\r\n				if (directed == false)\r\n					gv[v].push_back(make_pair(u, w));\r\n			}\r\n		}\r\n};\r\n\r\nclass inverseElement {\r\n	private :\r\n		unsigned n;\r\n		int p;\r\n		vector<int> fac;\r\n		void getFactorial(unsigned L, unsigned R, int P) {\r\n			if (n >= R) return;\r\n			n = R;\r\n			fac.resize(n + 1);\r\n			fac[0] = 1;\r\n			for (unsigned i = L; i <= R; i++)\r\n				fac[i] = fac[i - 1] * i % P;\r\n		}\r\n	public :\r\n		inverseElement() {\r\n		}\r\n		inverseElement(int P) {\r\n			p = P;\r\n		}\r\n		int C(unsigned N, unsigned M, int P = 0) {\r\n			if (P == 0) P = p;\r\n			if (M > N) throw \"M cannot be greater than N!\";\r\n			if (n < N) getFactorial(n + 1, N, P);\r\n			return fac[N] * qpow(fac[M], P - 2 , P) % P * qpow(fac[N - M], P - 2, P) % P;\r\n		}\r\n		int A(unsigned N, unsigned M, int P = 0) {\r\n			if (P == 0) P = p;\r\n			if (M > N) throw \"M cannot be greater than N!\";\r\n			if (n < N) getFactorial(n + 1, N, P);\r\n			return C(N, M, P) * fac[M] % P;\r\n		}\r\n};\r\n\r\n// Some Consts\r\n\r\nconst int INF = 0x3f3f3f3f;\r\nconst int LONGINF = 0x3f3f3f3f3f3f3f3f;\r\nconst int MOD1 = 1e9 + 7;\r\nconst int MOD2 = 998244353;\r\nconst double PI = acos(-1.0);\r\nconst double E = 2.718281828;\r\nconst double PHI = (sqrt(5.0) - 1) / 2.0;\r\n\r\n// Some defines\r\n\r\ntypedef unsigned uint;\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef pair<int, int> pii;\r\ntypedef pair<pii, int> ppiii;\r\ntypedef pair<int, pii> pipii;\r\ntypedef vector<int> vi;\r\ntypedef vector<pii> vpii;\r\ntypedef vector<ppiii> vppiii;\r\ntypedef vector<pipii> vpipii;\r\ntypedef map<int, int> mii;\r\ntypedef map<int, vi> mivi;\r\ntypedef map<int, pii> mipii;\r\ntypedef map<pii, int> mpiii;\r\ntypedef map<char, int> mci;\r\ntypedef set<int> si;\r\ntypedef set<string> ss;\r\ntypedef set<pii> spii;\r\ntypedef set<ppiii> sppiii;\r\ntypedef set<pipii> spipii;\r\n\r\n#define forn(_i_, _a_, _b_) for (int _i_ = _a_; _i_ <= _b_; _i_++)\r\n#define nrof(_i_, _a_, _b_) for (int _i_ = _a_; _i_ >= _b_; _i_--)\r\n#define ncinn int n; cin >> n\r\n#define intcin(_name_) int _name_; cin >> _name_\r\n#define nmcin int n, m; cin >> n >> m\r\n#define acina int a[n+5]; read(a, n, 1)\r\n#define bcinb int b[n+5]; read(b, n, 1)\r\n#define intarrcin(_name_, _size_) int _name_[_size_+5]; read(_name_, _size_, 1)\r\n#define vcinv vector<int> v; read(v, n)\r\n#define vicin(_name_, _size_) vector<int> _name_; read(_name_, _size_)\r\n#define lrcin int l, r; cin >> l >> r\r\n#define xycin int x, y; cin >> x >> y\r\n#define int2cin(_name1_, _name2_) int _name1_, _name2_; cin >> _name1_ >> _name2_\r\n#define couta write(a, n, 1)\r\n#define coutarr(_name_, _size_) write(_name_, _size_, 1)\r\n#define coutv write(v)\r\n#define coutvec(_name_) write(_name_)\r\n#define setmulti ismulti = true\r\n#define multi setmulti; int _; cin >> _; while(_--)\r\n/*\r\nUse multi as:\r\nmulti {\r\n	// ...\r\n}\r\n*/\r\n\r\n// End of Template\r\n\r\n#define a(__x__) arr[__x__].a\r\n#define s(__x__) arr[__x__].s\r\nconst int N = 100001;\r\nint n, sum[N], premax[N], sufmax[N]; \r\nstruct node {\r\n	int a, s;\r\n	bool operator < (node b) const {\r\n		return a > b.a;\r\n	}\r\n};\r\nnode arr[N]; \r\nsigned main() {\r\n	ios::sync_with_stdio(false);\r\n	cin.tie(nullptr); cout.tie(nullptr);\r\n	cin >> n;\r\n	forn (i, 1, n) cin >> s(i);\r\n	forn (i, 1, n) cin >> a(i);\r\n	sort(arr + 1, arr + n + 1);\r\n	forn (i, 1, n) sum[i] = sum[i - 1] + a(i);\r\n	forn (i, 1, n) premax[i] = max(premax[i - 1], s(i) * 2);\r\n	nrof (i, n, 1) sufmax[i] = max(sufmax[i + 1], 2 * s(i) + a(i));\r\n	forn (i, 1, n) cout << max(sum[i] + premax[i], sum[i - 1] + sufmax[i]) << endl;\r\n	return 0;\r\n}\r\n'),(1042,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// Template by xcx0902\r\n// Copyright 2022\r\n\r\n#define int long long\r\n\r\nbool ismulti = false;\r\n\r\n// Pair cin & cout\r\n\r\ntemplate <typename tp1, typename tp2>\r\nistream& operator >> (istream &in, pair<tp1, tp2> &p) {\r\n	in >> p.first >> p.second;\r\n	return in;\r\n}\r\n\r\ntemplate <typename tp1, typename tp2>\r\nostream& operator << (ostream &out, const pair<tp1, tp2> &p) {\r\n	out << p.first << \" \" << p.second;\r\n	out.flush();\r\n	return out;\r\n}\r\n\r\n// Read & Write\r\n\r\ntemplate <typename type>\r\nvoid read(type a[], int ed, int st = 1) {\r\n	for (int i = st; i <= ed; i++)\r\n		cin >> a[i];\r\n}\r\n\r\ntemplate <typename type>\r\nvoid read(vector<type> &v, int sz = 0) {\r\n	if(sz) v.resize(sz);\r\n	for (auto &p: v)\r\n		cin >> p;\r\n}\r\n\r\ntemplate <typename type>\r\nistream& operator >> (istream &in, vector<type> &v) {\r\n	for (auto &p: v)\r\n		in >> p;\r\n	return in;\r\n}\r\n\r\ntemplate <typename type>\r\nvoid write(type a[], int ed, int st = 1, string sep = \" \", string last = \"\\n\") {\r\n	for (int i = st; i <= ed; i++)\r\n		cout << a[i] << (i != ed? sep: last);\r\n	cout.flush();\r\n}\r\n\r\ntemplate <typename type>\r\nvoid write(vector<type> v, string sep = \" \", string last = \"\\n\") {\r\n	for (int i = 0; i < v.size(); i++)\r\n		cout << v[i] << (i != v.size() - 1? sep: last);\r\n	cout.flush();\r\n}\r\n\r\ntemplate <typename type>\r\nostream& operator << (ostream &out, const vector<type> &v) {\r\n	for (auto p: v)\r\n		out << p << \" \";\r\n	out.flush();\r\n	return out;\r\n}\r\n\r\n// Some Functions\r\n\r\nint gcd(int a, int b) {\r\n	return !b? a: gcd(b, a % b);\r\n}\r\n\r\nint lcm(int a, int b) {\r\n	return a * b / gcd(a, b);\r\n}\r\n\r\nint popcount(int x, int p = 2) {\r\n	int count = 0;\r\n	while(x) {\r\n		count++;\r\n		x /= p;\r\n	}\r\n	return count;\r\n}\r\n\r\nint lowbit(int x) {\r\n	return x & (-x);\r\n}\r\n\r\nint isqrt(int x) {\r\n	int l = 0, r = 3e9, ans = 0, mid;\r\n	while (l <= r) {\r\n		mid = (l + r) >> 1;\r\n		if (mid * mid <= x) l = mid + 1, ans = mid;\r\n		else r = mid - 1;\r\n	}\r\n	return ans;\r\n}\r\n\r\nint ilog2(int x) {\r\n	return popcount(x) - 1;\r\n}\r\n\r\nint ilog10(int x) {\r\n	return popcount(x, 10) - 1;\r\n}\r\n\r\nint ilogk(int x, int k) {\r\n	return popcount(x, k) - 1;\r\n}\r\n\r\nint qpow(int a, int b, int p) {\r\n	if (b == 0) return 1 % p;\r\n	if (b == 1) return a % p;\r\n	int tmp = qpow(a, b / 2, p) % p;\r\n	if (b % 2) return tmp * tmp % p * a % p;\r\n	else       return tmp * tmp % p;\r\n}\r\n\r\nint binarySearch(int l, int r, bool (*check)(int), int ans = 0) {\r\n	int mid = 0;\r\n	while (l <= r) {\r\n		mid = (l + r) >> 1;\r\n		if (check(mid)) l = mid + 1, ans = mid;\r\n		else r = mid - 1;\r\n	}\r\n	return ans;\r\n}\r\n\r\ndouble binarySearch(double l, double r, bool (*check)(double), double eps = 1e-6, double ans = 0) {\r\n	double mid = 0;\r\n	while(abs(l - r) > eps) {\r\n		mid = (l + r) / 2;\r\n		if (check(mid)) l = mid, ans = mid;\r\n		else r = mid;\r\n	}\r\n	return ans;\r\n}\r\n\r\nint getDivisor(int a[], int n, int cnt = 1) {\r\n	int tmp = cnt;\r\n	for (int i = 1; i * i <= n; i++)\r\n		if (n % i == 0) {\r\n			a[cnt++] = i;\r\n			if (i * i != n)\r\n				a[cnt++] = n / i;\r\n		}\r\n	cnt--;\r\n	sort(a + tmp, a + cnt + 1);\r\n	return cnt;\r\n}\r\n\r\nint getDivisor(vector<int> &v, int n) {\r\n	for (int i = 1; i * i <= n; i++)\r\n		if (n % i == 0) {\r\n			v.push_back(i);\r\n			if (i * i != n)\r\n				v.push_back(n / i);\r\n		}\r\n	sort(v.begin(), v.end());\r\n	return v.size();\r\n}\r\n\r\n// Yes & No, Possible & Impossible, ...\r\n\r\nvoid yes(bool ex = (!ismulti)) {\r\n	cout << \"yes\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid Yes(bool ex = (!ismulti)) {\r\n	cout << \"Yes\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid YES(bool ex = (!ismulti)) {\r\n	cout << \"YES\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid no(bool ex = (!ismulti)) {\r\n	cout << \"no\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid No(bool ex = (!ismulti)) {\r\n	cout << \"No\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid NO(bool ex = (!ismulti)) {\r\n	cout << \"NO\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid yesno(bool flag, bool ex = (!ismulti)) {\r\n	if (flag) cout << \"yes\" << endl;\r\n	else cout << \"no\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid YesNo(bool flag, bool ex = (!ismulti)) {\r\n	if (flag) cout << \"Yes\" << endl;\r\n	else cout << \"No\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\nvoid YESNO(bool flag, bool ex = (!ismulti)) {\r\n	if (flag) cout << \"YES\" << endl;\r\n	else cout << \"NO\" << endl;\r\n	if (ex) exit(0);\r\n}\r\n\r\n// Some data structures\r\n\r\nclass DJU {\r\n	private :\r\n		std::vector<unsigned> f, sz;\r\n	public :\r\n		DJU() {\r\n		}\r\n		DJU(unsigned _sz) {\r\n			f = sz = std::vector<unsigned> (_sz + 1);\r\n			for (unsigned i = 1; i <= _sz; i++)\r\n				f[i] = i, sz[i] = 1;\r\n		}\r\n		unsigned find(unsigned x) {\r\n			if (f[x] == x) return x;\r\n			return f[x] = find(f[x]);\r\n		}\r\n		bool same(unsigned x, unsigned y) {\r\n			if (find(x) == find(y)) return true;\r\n			else return false;\r\n		}\r\n		void merge(unsigned x, unsigned y) {\r\n			unsigned fx = find(x);\r\n			unsigned fy = find(y);\r\n			f[fx] = fy;\r\n			sz[fy] += sz[fx];\r\n		}\r\n		unsigned size(unsigned x) {\r\n			return sz[find(x)];\r\n		}\r\n};\r\n\r\ntemplate <typename tp>\r\nclass BIT {\r\n	private :\r\n		vector<tp> c; // from 1 to N\r\n		unsigned sz;\r\n		unsigned lowbit(unsigned x) {\r\n			return x & (-x);\r\n		}\r\n\r\n	public :\r\n		BIT() {\r\n		}\r\n		BIT(unsigned _sz) {\r\n			c = vector<tp> (_sz + 1);\r\n			sz= _sz;\r\n		}\r\n		tp getsum(unsigned dx) { // return sum of [1..dx]\r\n			tp ret = 0;\r\n			while(dx) {\r\n				ret += c[dx];\r\n				dx -= lowbit(dx);\r\n			}\r\n			return ret;\r\n		}\r\n		tp sum(unsigned l,unsigned r) { // return sum of [l..r]\r\n			return getsum(r) - getsum(l - 1);\r\n		}\r\n		tp get(unsigned dx) { // return value[dx]\r\n			return sum(dx,dx);\r\n		}\r\n		tp add(unsigned dx,tp val) { // return after add\r\n			unsigned tmp = dx;\r\n			while(dx <= sz) {\r\n				c[dx] += val;\r\n				dx += lowbit(dx);\r\n			}\r\n			return c[tmp];\r\n		}\r\n		tp change(unsigned dx,tp val) { // return after change\r\n			return add(dx,val - get(dx));\r\n		}\r\n};\r\n\r\ntemplate <typename tp>\r\nclass unauthorizedGraph {\r\n	private :\r\n		unsigned sz;\r\n	public :\r\n		vector<vector<tp> > gv;\r\n		vector<tp>& operator [] (unsigned x) {\r\n			return gv[x];\r\n		}\r\n		unauthorizedGraph() {\r\n		}\r\n		~unauthorizedGraph() {\r\n			sz = 0;\r\n			gv.resize(0);\r\n		}\r\n		unauthorizedGraph(unsigned _sz) {\r\n			sz = _sz;\r\n			gv.resize(_sz + 1);\r\n		}\r\n		void readGraph(unsigned n, unsigned m, bool directed = false) {\r\n			sz = n;\r\n			gv.resize(n + 1);\r\n			for (int i = 1; i <= m; i++) {\r\n				tp u, v;\r\n				cin >> u >> v;\r\n				gv[u].push_back(v);\r\n				if (directed == false)\r\n					gv[v].push_back(u);\r\n			}\r\n		}\r\n};\r\n\r\ntemplate <typename tp, typename tpw>\r\nclass authorizedGraph {\r\n	private :\r\n		unsigned sz;\r\n	public :\r\n		vector<vector<pair<tp, tpw> > > gv;\r\n		vector<pair<tp, tpw> >& operator [] (unsigned x) {\r\n			return gv[x];\r\n		}\r\n		authorizedGraph() {\r\n		}\r\n		~authorizedGraph() {\r\n			sz = 0;\r\n			gv.resize(0);\r\n		}\r\n		authorizedGraph(unsigned _sz) {\r\n			sz = _sz;\r\n			gv.resize(_sz + 1);\r\n		}\r\n		void readGraph(unsigned n, unsigned m, bool directed = false) {\r\n			sz = n;\r\n			gv.resize(n + 1);\r\n			for (int i = 1; i <= m; i++) {\r\n				tp u, v; tpw w;\r\n				cin >> u >> v >> w;\r\n				gv[u].push_back(make_pair(v, w));\r\n				if (directed == false)\r\n					gv[v].push_back(make_pair(u, w));\r\n			}\r\n		}\r\n};\r\n\r\nclass inverseElement {\r\n	private :\r\n		unsigned n;\r\n		int p;\r\n		vector<int> fac;\r\n		void getFactorial(unsigned L, unsigned R, int P) {\r\n			if (n >= R) return;\r\n			n = R;\r\n			fac.resize(n + 1);\r\n			fac[0] = 1;\r\n			for (unsigned i = L; i <= R; i++)\r\n				fac[i] = fac[i - 1] * i % P;\r\n		}\r\n	public :\r\n		inverseElement() {\r\n		}\r\n		inverseElement(int P) {\r\n			p = P;\r\n		}\r\n		int C(unsigned N, unsigned M, int P = 0) {\r\n			if (P == 0) P = p;\r\n			if (M > N) throw \"M cannot be greater than N!\";\r\n			if (n < N) getFactorial(n + 1, N, P);\r\n			return fac[N] * qpow(fac[M], P - 2 , P) % P * qpow(fac[N - M], P - 2, P) % P;\r\n		}\r\n		int A(unsigned N, unsigned M, int P = 0) {\r\n			if (P == 0) P = p;\r\n			if (M > N) throw \"M cannot be greater than N!\";\r\n			if (n < N) getFactorial(n + 1, N, P);\r\n			return C(N, M, P) * fac[M] % P;\r\n		}\r\n};\r\n\r\n// Some Consts\r\n\r\nconst int INF = 0x3f3f3f3f;\r\nconst int LONGINF = 0x3f3f3f3f3f3f3f3f;\r\nconst int MOD1 = 1e9 + 7;\r\nconst int MOD2 = 998244353;\r\nconst double PI = acos(-1.0);\r\nconst double E = 2.718281828;\r\nconst double PHI = (sqrt(5.0) - 1) / 2.0;\r\n\r\n// Some defines\r\n\r\ntypedef unsigned uint;\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef pair<int, int> pii;\r\ntypedef pair<pii, int> ppiii;\r\ntypedef pair<int, pii> pipii;\r\ntypedef vector<int> vi;\r\ntypedef vector<pii> vpii;\r\ntypedef vector<ppiii> vppiii;\r\ntypedef vector<pipii> vpipii;\r\ntypedef map<int, int> mii;\r\ntypedef map<int, vi> mivi;\r\ntypedef map<int, pii> mipii;\r\ntypedef map<pii, int> mpiii;\r\ntypedef map<char, int> mci;\r\ntypedef set<int> si;\r\ntypedef set<string> ss;\r\ntypedef set<pii> spii;\r\ntypedef set<ppiii> sppiii;\r\ntypedef set<pipii> spipii;\r\n\r\n#define forn(_i_, _a_, _b_) for (int _i_ = _a_; _i_ <= _b_; _i_++)\r\n#define nrof(_i_, _a_, _b_) for (int _i_ = _a_; _i_ >= _b_; _i_--)\r\n#define ncinn int n; cin >> n\r\n#define intcin(_name_) int _name_; cin >> _name_\r\n#define nmcin int n, m; cin >> n >> m\r\n#define acina int a[n+5]; read(a, n, 1)\r\n#define bcinb int b[n+5]; read(b, n, 1)\r\n#define intarrcin(_name_, _size_) int _name_[_size_+5]; read(_name_, _size_, 1)\r\n#define vcinv vector<int> v; read(v, n)\r\n#define vicin(_name_, _size_) vector<int> _name_; read(_name_, _size_)\r\n#define lrcin int l, r; cin >> l >> r\r\n#define xycin int x, y; cin >> x >> y\r\n#define int2cin(_name1_, _name2_) int _name1_, _name2_; cin >> _name1_ >> _name2_\r\n#define couta write(a, n, 1)\r\n#define coutarr(_name_, _size_) write(_name_, _size_, 1)\r\n#define coutv write(v)\r\n#define coutvec(_name_) write(_name_)\r\n#define setmulti ismulti = true\r\n#define multi setmulti; int _; cin >> _; while(_--)\r\n/*\r\nUse multi as:\r\nmulti {\r\n	// ...\r\n}\r\n*/\r\n\r\n// End of Template\r\n\r\n#define a(__x__) arr[__x__].a\r\n#define s(__x__) arr[__x__].s\r\nconst int N = 100001;\r\nint n, sum[N], premax[N], sufmax[N]; \r\nstruct node {\r\n	int a, s;\r\n	bool operator < (node b) const {\r\n		return a > b.a;\r\n	}\r\n};\r\nnode arr[N]; \r\nsigned main() {\r\n	ios::sync_with_stdio(false);\r\n	cin.tie(nullptr); cout.tie(nullptr);\r\n	cin >> n;\r\n	forn (i, 1, n) cin >> s(i);\r\n	forn (i, 1, n) cin >> a(i);\r\n	sort(arr + 1, arr + n + 1);\r\n	forn (i, 1, n) sum[i] = sum[i - 1] + a(i);\r\n	forn (i, 1, n) premax[i] = max(premax[i - 1], s(i) * 2);\r\n	nrof (i, n, 1) sufmax[i] = max(sufmax[i + 1], 2 * s(i) + a(i));\r\n	forn (i, 1, n) cout << max(sum[i] + premax[i], sum[i - 1] + sufmax[i]) << endl;\r\n	return 0;\r\n}\r\n'),(1043,'#include <stdio.h>\r\n#include <string.h>\r\n#define max(a,b) ((a)>(b)?(a):(b))\r\nconst int N = 1e4 + 10; //qwq\r\nconst int M = 1e3 + 10;\r\nint /*w[N],v[N],*/f[N];\r\nint p[N][N];\r\nint t, n, m;\r\nint main() {\r\n	scanf(\"%d%d%d\", &t, &n, &m);\r\n	for (int i = 1; i <= t; i++)\r\n		for (int j = 1; j <= n; j++)\r\n			scanf(\"%d\", &p[i][j]);\r\n	for (int k = 1; k < t; k++) {\r\n		memset(f, 0, sizeof f);\r\n		for (int i = 1; i <= n; i++)\r\n			for (int j = p[k][i]; j <= m; j++)\r\n				f[j] = max(f[j], f[j - p[k][i]] + p[k + 1][i] - p[k][i]);\r\n		m += f[m];\r\n		// p[2][i] - p[1][i] + p[3][i] - p[2][i] = p[3][i] - p[1][i]\r\n	}\r\n	printf(\"%d\", m);\r\n	return 0;\r\n}'),(1044,'#include <stdio.h>\r\n#include <string.h>\r\n#define max(a,b) ((a)>(b)?(a):(b))\r\nconst int N=1e4+10;//qwq\r\nconst int M=1e3+10;\r\nint /*w[N],v[N],*/f[N];\r\nint p[N][N];\r\nint t,n,m;\r\nint main()\r\n{\r\n	scanf(\"%d%d%d\",&t,&n,&m);\r\n	for(int i=1;i<=t;i++)\r\n		for(int j=1;j<=n;j++)\r\n			scanf(\"%d\",&p[i][j]);\r\n	for(int k=1;k<t;k++)\r\n	{\r\n		memset(f,0,sizeof f); \r\n		for(int i=1;i<=n;i++)\r\n			for(int j=p[k][i];j<=m;j++)\r\n				f[j]=max(f[j],f[j-p[k][i]]+p[k+1][i]-p[k][i]);\r\n		m+=f[m];\r\n	}\r\n	printf(\"%d\",m);\r\n	return 0;\r\n}'),(1045,'#include <stdio.h>\r\n#include <string.h>\r\n#define max(a,b) ((a)>(b)?(a):(b))\r\nconst int N=1e4+10;//qwq\r\nconst int M=1e3+10;\r\nint /*w[N],v[N],*/f[N];\r\nint p[N][N];\r\nint t,n,m;\r\nint main()\r\n{\r\n	scanf(\"%d%d%d\",&t,&n,&m);\r\n	for(int i=1;i<=t;i++)\r\n		for(int j=1;j<=n;j++)\r\n			scanf(\"%d\",&p[i][j]);\r\n	for(int k=1;k<t;k++)\r\n	{\r\n		memset(f,0,sizeof f); \r\n		for(int i=1;i<=n;i++)\r\n			for(int j=p[k][i];j<=m;j++)\r\n				f[j]=max(f[j],f[j-p[k][i]]+p[k+1][i]-p[k][i]);\r\n		m+=f[m];\r\n	}\r\n	printf(\"%d\",m);\r\n	return 0;\r\n}'),(1046,'#include <stdio.h>\r\n#include <string.h>\r\n#define max(a,b) ((a)>(b)?(a):(b))\r\nconst int N=1e4+10;//qwq\r\nconst int M=1e3+10;\r\nint /*w[N],v[N],*/f[N];\r\nint p[N][N];\r\nint t,n,m;\r\nint main()\r\n{\r\n	scanf(\"%d%d%d\",&t,&n,&m);\r\n	for(int i=1;i<=t;i++)\r\n		for(int j=1;j<=n;j++)\r\n			scanf(\"%d\",&p[i][j]);\r\n	for(int k=1;k<t;k++)\r\n	{\r\n		memset(f,0,sizeof f); \r\n		for(int i=1;i<=n;i++)\r\n			for(int j=p[k][i];j<=m;j++)\r\n				f[j]=max(f[j],f[j-p[k][i]]+p[k+1][i]-p[k][i]);\r\n		m+=f[m];\r\n	}\r\n	printf(\"%d\",m);\r\n	return 0;\r\n}'),(1047,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n	int t;\r\n	cin >> t;\r\n	while (t--) {\r\n		string op; int n;\r\n		cin >> op >> n;\r\n		if (op == \"diff\") {\r\n			if (n & 1) cout << -1 << endl;\r\n			else cout << 0 << \" \" << 0 << \" \" << n / 2 << endl;\r\n		}\r\n		else if (op == \"gcd\") {\r\n			cout << 1 << \" \" << n - 2 << \" \" << n - 2 << endl;\r\n		}\r\n		else if (op == \"xor\") {\r\n			if (n & 1) cout << -1 << endl;\r\n			else cout << 0 << \" \" << 0 << \" \" << n / 2 << endl;\r\n		}\r\n	} \r\n	return 0;\r\n}\r\n'),(1048,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n \r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        string op; int n;\r\n        cin >> op >> n;\r\n        if (op == \"diff\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << 0 << \" \" << n / 2 << \" \" << 0 << endl;\r\n        }\r\n        else if (op == \"gcd\") {\r\n            cout << n - 2 << \" \" << 1 << \" \" << n - 2 << endl;\r\n        }\r\n        else if (op == \"xor\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << n / 2 << \" \" << 0 << \" \" << 0 << endl;\r\n        }\r\n    } \r\n    return 0;\r\n}'),(1049,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n \r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        string op; int n;\r\n        cin >> op >> n;\r\n        if (op == \"diff\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << 1 << \" \" << n / 2 << \" \" << 0 << endl;\r\n        }\r\n        else if (op == \"gcd\") {\r\n            cout << n - 2 << \" \" << 1 << \" \" << n - 2 << endl;\r\n        }\r\n        else if (op == \"xor\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << n / 2 << \" \" << 0 << \" \" << 0 << endl;\r\n        }\r\n    } \r\n    return 0;\r\n}'),(1050,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n \r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        string op; int n;\r\n        cin >> op >> n;\r\n        if (op == \"diff\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << 114514 << \" \" << n / 2 << \" \" << 0 << endl;\r\n        }\r\n        else if (op == \"gcd\") {\r\n            cout << n - 2 << \" \" << 1 << \" \" << n - 2 << endl;\r\n        }\r\n        else if (op == \"xor\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << n / 2 << \" \" << 0 << \" \" << 0 << endl;\r\n        }\r\n    } \r\n    return 0;\r\n}'),(1051,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n\r\nconst int mod = 988244533;\r\n\r\nint qpow(int a, int b) {\r\n	if (b == 0) return 1;\r\n	if (b == 1) return a % mod;\r\n	int tmp = qpow(a, b / 2);\r\n	if (b & 1) return tmp * tmp % mod * a % mod;\r\n	else return tmp * tmp % mod; \r\n}\r\n\r\nsigned main() {\r\n	int n;\r\n	cin >> n;\r\n	cout << qpow(3, n) << endl;\r\n	return 0;\r\n}\r\n'),(1052,'#include <bits/stdc++.h>\r\n#define l(_x) (((_x) + 5) % 6)\r\n#define r(_x) (((_x) + 1) % 6)\r\nusing namespace std;\r\n\r\nconst int mod = 988244533;\r\nchar pos1, pos2; \r\nint a, b, n, ans, f[2][6][6];\r\n\r\nvoid testlr() {\r\n	cout << \"l(0): \" << l(0) << endl;\r\n	cout << \"l(1): \" << l(1) << endl;\r\n	cout << \"r(5): \" << r(5) << endl;\r\n	cout << \"r(4): \" << r(4) << endl;	\r\n}\r\n\r\nvoid debugf(int x) {\r\n	for (int i = 0; i < 6; i++)\r\n		for (int j = 0; j < 6; j++)\r\n			cout << f[x & 1][i][j] << endl;\r\n}\r\n\r\nint main() {\r\n//	testlr();\r\n	cin >> pos1 >> pos2 >> n;\r\n	a = pos1 - \'A\', b = pos2 - \'A\';\r\n	f[0][a][b] = 1;\r\n//	debugf(0);\r\n	for (int i = 1; i <= n; i++) {\r\n		memset(f[i & 1], 0, sizeof f[i & 1]);\r\n		for (int j = 0; j < 6; j++)\r\n			for (int k = 0; k < 6; k++)\r\n				if (j != k) {\r\n					if (l(j) != l(k)) (f[i & 1][j][k] += f[(i - 1) & 1][l(j)][l(k)]) %= mod;\r\n					if (l(j) != r(k)) (f[i & 1][j][k] += f[(i - 1) & 1][l(j)][r(k)]) %= mod;\r\n					if (r(j) != l(k)) (f[i & 1][j][k] += f[(i - 1) & 1][r(j)][l(k)]) %= mod;\r\n					if (r(j) != r(k)) (f[i & 1][j][k] += f[(i - 1) & 1][r(j)][r(k)]) %= mod; \r\n				}\r\n//		debugf(i);\r\n	}\r\n	for (int i = 0; i < 6; i++)\r\n		for (int j = 0; j < 6; j++)\r\n			(ans += f[n & 1][i][j]) %= mod;\r\n	cout << ans << endl;\r\n	return 0;\r\n}\r\n'),(1053,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct node {\r\n	bool deleted = 0;\r\n	int coefficient;\r\n	map<char, int> mp;\r\n} a[10001];\r\nmap<char, int> tmp;\r\nmap<map<char, int>, int> vis;\r\nnode commonFactor;\r\n\r\nvoid print(node x) {\r\n	if (x.coefficient != 1) cout << x.coefficient;\r\n	int cnt = 0;\r\n	for (char c = \'a\'; c <= \'z\'; c++)\r\n		if (x.mp[c] != 0)\r\n			cnt++;\r\n	for (char c = \'a\'; c <= \'z\'; c++)\r\n		if (x.mp[c] != 0)\r\n			cout << (cnt == 1 && x.coefficient == 1? \"\" : \"*\") << c << (x.mp[c] == 1? \"\" : \"^\" + to_string(x.mp[c]));\r\n}\r\n\r\nint main() {\r\n	int n;\r\n	cin >> n;\r\n	for (int i = 1; i <= n; i++) {\r\n		int m, t;\r\n		cin >> m >> t;\r\n		a[i].coefficient = t;\r\n		tmp.clear();\r\n		for (int j = 1; j <= m; j++) {\r\n			char c; int num;\r\n			cin >> c >> num;\r\n			tmp[c] = num;\r\n		}\r\n		a[i].mp = tmp;\r\n	}\r\n	for (int i = 1; i <= n; i++) {\r\n		if (vis[a[i].mp]) {\r\n			a[i].deleted = 1;\r\n			a[vis[a[i].mp]].coefficient += a[i].coefficient;\r\n		}\r\n		else vis[a[i].mp] = i;\r\n	}\r\n	int g = a[1].coefficient;\r\n	for (int i = 2; i <= n; i++)\r\n		if (!a[i].deleted)\r\n			g = __gcd(g, a[i].coefficient);\r\n	commonFactor.coefficient = g;\r\n	for (char c = \'a\'; c <= \'z\'; c++) {\r\n		int mn = 0x3f3f3f3f;\r\n		for (int i = 1; i <= n; i++)\r\n			if (!a[i].deleted)\r\n				mn = min(mn, a[i].mp[c]);\r\n		commonFactor.mp[c] = mn;\r\n	}\r\n	print(commonFactor);\r\n	cout << endl;\r\n	return 0;\r\n}\r\n'),(1054,'// factorization.cpp\r\n// author: xcx\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint a, b, c, d, e, f, g;\r\nvector<int> da, dc, df;\r\n\r\nint gcd(int x, int y) {\r\n	x = abs(x); y = abs(y);\r\n	return !y? x : gcd(y, x % y);\r\n}\r\n\r\nvector<int> div(int x) {\r\n	vector<int> tmp, ret;\r\n	int up = sqrt(abs(x));\r\n	for (int i = 1; i <= up; i++)\r\n		if (x % i == 0) {\r\n			tmp.push_back(i);\r\n			if (i * i != x) tmp.push_back(x / i);\r\n		}\r\n	sort(tmp.begin(), tmp.end());\r\n	ret = tmp;\r\n	for (int num: tmp)\r\n		ret.push_back(-num);\r\n	return ret;\r\n}\r\n\r\nstring pr(int num) {\r\n	if (num == 1) return \"\";\r\n	else if (num == -1) return \"-\";\r\n	else return to_string(num);\r\n}\r\n\r\nvoid print(int a, int b, int c) { // ax + by + c\r\n	if (a == 0) cout << pr(b) << \"y\" << (c >= 0 ? \"+\" : \"\") << c;\r\n	else if (b == 0) cout << pr(a) << \"x\" << (c >= 0 ? \"+\" : \"\") << c;\r\n	else if (c == 0) cout << pr(a) << \"x\" << (b >= 0 ? \"+\" : \"\") << pr(b) << \"y\";\r\n	else cout << pr(a) << \"x\" << (b >= 0 ? \"+\" : \"\") << pr(b) << \"y\" << (c >= 0 ? \"+\" : \"\") << c; \r\n}\r\n\r\nvoid printAns(int k, int l, int m, int n, int p, int q) {\r\n	if (g != 1) cout << g;\r\n	cout << \"(\";\r\n	print(k, l, m);\r\n	cout << \")(\";\r\n	print(n, p, q);\r\n	cout << \")\" << endl; \r\n}\r\n\r\nint main() {\r\n	cin >> a >> b >> c >> d >> e >> f;\r\n	g = gcd(a, gcd(b, gcd(c, gcd(d, gcd(e, f)))));\r\n	a /= g, b /= g, c /= g, d /= g, e /= g, f /= g;\r\n//	cout << \"#\" << g << endl;\r\n	da = div(a); dc = div(c); df = div(f);\r\n//	cout << \'#\' << endl;\r\n//	cerr << da.size() << \" \" << dc.size() << \" \" << df.size() << endl;\r\n	// ax^2 + bxy + cy^2 + dx + ey + f\r\n	// (kx + ly + m)(nx + py + q)\r\n	for (int k: da)\r\n		for (int l: dc)\r\n			for (int m: df) {\r\n				int n = a / k, p = c / l, q = f / m;\r\n				if (k * p + l * n == b && l * q + m * p == e && k * q + n * m == d) {\r\n					printAns(k, l, m, n, p, q);\r\n					return 0;\r\n				}\r\n			}\r\n	return 0;\r\n}\r\n'),(1055,'// factorization.cpp\r\n// author: xcx\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint a, b, c, d, e, f, g;\r\nvector<int> da, dc, df;\r\n\r\nint gcd(int x, int y) {\r\n	x = abs(x); y = abs(y);\r\n	return !y? x : gcd(y, x % y);\r\n}\r\n\r\nvector<int> div(int x) {\r\n	vector<int> tmp, ret;\r\n	int up = sqrt(abs(x));\r\n	for (int i = 1; i <= up; i++)\r\n		if (x % i == 0) {\r\n			tmp.push_back(i);\r\n			if (i * i != x) tmp.push_back(x / i);\r\n		}\r\n	sort(tmp.begin(), tmp.end());\r\n	ret = tmp;\r\n	for (int num: tmp)\r\n		ret.push_back(-num);\r\n	return ret;\r\n}\r\n\r\nstring pr(int num) {\r\n	if (num == 1) return \"\";\r\n	else if (num == -1) return \"-\";\r\n	else return to_string(num);\r\n}\r\n\r\nvoid print(int a, int b, int c) { // ax + by + c\r\n	if (a == 0) cout << pr(b) << \"y\" << (c >= 0 ? \"+\" : \"\") << c;\r\n	else if (b == 0) cout << pr(a) << \"x\" << (c >= 0 ? \"+\" : \"\") << c;\r\n	else if (c == 0) cout << pr(a) << \"x\" << (b >= 0 ? \"+\" : \"\") << pr(b) << \"y\";\r\n	else cout << pr(a) << \"x\" << (b >= 0 ? \"+\" : \"\") << pr(b) << \"y\" << (c >= 0 ? \"+\" : \"\") << c; \r\n}\r\n\r\nvoid printAns(int k, int l, int m, int n, int p, int q) {\r\n	if (g != 1) cout << g;\r\n	cout << \"(\";\r\n	print(k, l, m);\r\n	cout << \")(\";\r\n	print(n, p, q);\r\n	cout << \")\" << endl; \r\n}\r\n\r\nint main() {\r\n	cin >> a >> b >> c >> d >> e >> f;\r\n	g = gcd(a, gcd(b, gcd(c, gcd(d, gcd(e, f)))));\r\n	a /= g, b /= g, c /= g, d /= g, e /= g, f /= g;\r\n//	cout << \"#\" << g << endl;\r\n	da = div(a); dc = div(c); df = div(f);\r\n//	cout << \'#\' << endl;\r\n//	cerr << da.size() << \" \" << dc.size() << \" \" << df.size() << endl;\r\n	// ax^2 + bxy + cy^2 + dx + ey + f\r\n	// (kx + ly + m)(nx + py + q)\r\n	for (int k: da)\r\n		for (int l: dc)\r\n			for (int m: df) {\r\n				int n = a / k, p = c / l, q = f / m;\r\n				if (k * p + l * n == b && l * q + m * p == e && k * q + n * m == d) {\r\n					printAns(-k, -l, -m, -n, -p, -q);\r\n					return 0;\r\n				}\r\n			}\r\n	return 0;\r\n}\r\n'),(1056,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n\r\nconst int mod = 988244533;\r\nint n, len, ans;\r\nstring s;\r\nvector<string> a;\r\nvector<int> c;\r\n\r\nint qpow(int a, int b) {\r\n	if (b == 0) return 1;\r\n	if (b == 1) return a % mod;\r\n	int tmp = qpow(a, b / 2) % mod;\r\n	if (b & 1) return tmp * tmp % mod * a % mod;\r\n	else return tmp * tmp % mod;\r\n}\r\n\r\nvoid init() {\r\n	cin >> s;\r\n	len = s.length();\r\n	s = \" \" + s;\r\n}\r\n\r\nbool checkStar() {\r\n	for (int i = 1; i <= len; i++)\r\n		if (s[i] == \'*\')\r\n			return true;\r\n	return false;\r\n}\r\n\r\nvoid division() {\r\n	int last = 1;\r\n	a.push_back(\"\");\r\n	for (int i = 1; i <= len; i++)\r\n		if (s[i] == \'|\') {\r\n			a.push_back(s.substr(last, i - last));\r\n			last = i + 1;\r\n		}\r\n	a.push_back(s.substr(last, len - last + 1));\r\n	n = a.size() - 1;\r\n}\r\n\r\npair<string, int> merge(string x, string y) {\r\n	if (x.size() != y.size()) return {\"\", 0};\r\n	int clen = x.size();\r\n	string ans;\r\n	for (int i = 0; i < clen; i++) {\r\n		if (x[i] != \'?\' && y[i] != \'?\' && x[i] != y[i]) return {\"\", 0};\r\n		if (x[i] != \'?\' && y[i] != \'?\' && x[i] == y[i]) ans += x[i];\r\n		if (x[i] == \'?\' && y[i] != \'?\') ans += y[i];\r\n		if (x[i] != \'?\' && y[i] == \'?\') ans += x[i];\r\n		if (x[i] == \'?\' && y[i] == \'?\') ans += \'?\';\r\n	}\r\n	return {ans, 1};\r\n}\r\n\r\nint calc() {\r\n	if (c.size() == 0) return -1;\r\n	for (auto i: c)\r\n		if (a[i].size() != a[c[0]].size())\r\n			return -1;\r\n	string t;\r\n	int clen = a[c[0]].size();\r\n	for (int i = 1; i <= clen; i++)\r\n		t += \'?\';\r\n//	cout << clen << \" \" << t << endl;\r\n	for (auto i: c) {\r\n		pair<string, int> tmp = merge(t, a[i]);\r\n		if (tmp.second == 0) return -1;\r\n		else t = tmp.first;\r\n	}\r\n	if (c.size() == 1) t = a[c[0]];\r\n	int ret = 0;\r\n	for (auto ch: t)\r\n		if (ch == \'?\')\r\n			ret++;\r\n//	cout << \"------------\" << endl;\r\n//	cout << \"chose: \";\r\n//	for (auto i: c) cout << a[i] << \" \";\r\n//	cout << endl;\r\n//	cout << \"t: \" << t << endl; \r\n//	cout << \"ret: \" << ret << endl;\r\n//	cout << \"------------\" << endl;\r\n	return ret;\r\n}\r\n\r\nvoid work() {\r\n//	cout << s << endl << \"*\" << s.substr(1) << \"*\" << endl;\r\n	if (checkStar()) {\r\n		cout << \"INF\" << endl;\r\n		return;\r\n	}\r\n//	cout << \"Before Divison\" << endl; \r\n	division();\r\n//	cout << \"After Divison\" << endl;\r\n//	for (auto x: a) cout << x << endl;\r\n//	cout << \"After Debug1\" << endl;\r\n//	cout << n << \" \" << (1 << n) << endl; \r\n	for (int i = 0; i < (1 << n); i++) {\r\n//		cout << \"for started\" << endl;\r\n		int tmp = i;\r\n//		cout << tmp << \":\";\r\n		c.clear();\r\n		for (int j = 1; j <= n; j++) {\r\n			if (tmp & 1) c.push_back(j);\r\n			tmp >>= 1;\r\n		}\r\n//		for (auto x: c) cout << x << \" \"; cout << endl;\r\n		int num = calc();\r\n		if (num != -1) num = qpow(26, num);\r\n		else num = 0;\r\n//		cout << num << endl;\r\n		if (c.size() & 1) ans = (ans + num) % mod;\r\n		else ans = (ans - num + mod) % mod;\r\n//		cout << \"for ended\" << endl;\r\n	}\r\n	cout << ans << endl;\r\n}\r\n\r\nsigned main() {\r\n//	for (int i = 1; i <= 100; i++)\r\n//		cout << qpow(26, i) << endl;\r\n	init();\r\n	work();\r\n	return 0;\r\n}'),(1057,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    cout << \"Hello World!\" << endl;\r\n	return 0;\r\n}\r\n'),(1058,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    int a, b;\r\n    cin >> a >> b;\r\n    cout << a + b << endl;\r\n	return 0;\r\n}\r\n'),(1059,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    int a, b;\r\n    cin >> a >> b;\r\n    cout << a + b << endl;\r\n	return 0;\r\n}\r\n'),(1060,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n  \r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        string op; int n;\r\n        cin >> op >> n;\r\n        if (op == \"diff\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << n / 2 << \" \" << 0 << \" \" << 0 << endl;\r\n        }\r\n        else if (op == \"gcd\") {\r\n            cout << n - 2 << \" \" << n - 2 << \" \" << 1 << endl;\r\n        }\r\n        else if (op == \"xor\") {\r\n            if (n & 1) cout << -1 << endl;\r\n            else cout << 0 << \" \" << 0 << \" \" << n / 2 << endl;\r\n        }\r\n    } \r\n    return 0;\r\n}'),(1061,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    cout << \"4294967295\" << endl;\r\n    return 0;\r\n}'),(1062,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n \r\nnamespace trie {\r\n	const int N = 100005 * 65;\r\n	int cnt = 0;\r\n	struct trieNode {\r\n		int num, lc, rc;\r\n		trieNode() {\r\n			num = lc = rc = -1;\r\n		}\r\n	} trie[N]; // root = 0\r\n	#define son(_x, _y) ((_y)? trie[_x].rc : trie[_x].lc)\r\n	#define num(_x) trie[_x].num\r\n	vector<int> div(int x) {\r\n		vector<int> ret;\r\n		for (int i = 1; i <= 60; i++) {\r\n			ret.push_back(x & 1);\r\n			x >>= 1;\r\n		}\r\n		reverse(ret.begin(), ret.end());\r\n		return ret;\r\n	}\r\n	void insert(int x) {\r\n		vector<int> bits = div(x);\r\n		int p = 0;\r\n		for (int i: bits) {\r\n			if (son(p, i) == -1)\r\n				son(p, i) = ++cnt;\r\n			num(son(p, i)) = i;\r\n			p = son(p, i);\r\n		}\r\n	}\r\n	int calc(int x) {\r\n		vector<int> bits = div(x);\r\n		int p = 0, ans = 0;\r\n		for (int i: bits) {\r\n			if (son(p, i ^ 1) != -1) {\r\n				ans = ans << 1 | 1;\r\n				p = son(p, i ^ 1);\r\n			} else {\r\n				ans <<= 1;\r\n				p = son(p, i);\r\n			}\r\n//			cout << ans << endl;\r\n		}\r\n		return ans;\r\n	}\r\n}\r\n\r\nconst int N = 100005;\r\nint n, ans, a[N], d[N];\r\nvector<int> g[N];\r\n\r\nvoid dfs(int u, int fa) {\r\n	d[u] ^= a[u];\r\n	for (int v: g[u])\r\n		if (v != fa)\r\n			d[v] ^= d[u], dfs(v, u);\r\n}\r\n\r\nsigned main() {\r\n	cin >> n;\r\n	for (int i = 1; i <= n; i++)\r\n		cin >> a[i];\r\n	for (int i = 1, u, v; i < n; i++) {\r\n		cin >> u >> v;\r\n		g[u].push_back(v);\r\n		g[v].push_back(u); \r\n	}\r\n	dfs(1, -1);\r\n//	for (int i = 1; i <= n; i++)\r\n//		cout << d[i] << \" \";\r\n//	cout << endl;\r\n	for (int i = 1; i <= n; i++)\r\n		trie::insert(d[i]);\r\n	for (int i = 1; i <= n; i++)\r\n		ans = max(ans, trie::calc(d[i]));\r\n	cout << ans << endl;\r\n	return 0;\r\n}'),(1063,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\nnamespace deQueue {\r\n	const int NUM = 100001;\r\n	typedef pii Elemtype; \r\n	typedef struct deQueue {\r\n		Elemtype base[NUM];\r\n		int front, back;\r\n	} myDeque;\r\n	void init(deQueue &Q) {\r\n		Q.back = Q.front = 1;\r\n	}\r\n	int push_front(deQueue &Q, Elemtype x) {\r\n		if (Q.front < Q.back) {\r\n			if (Q.front == 1)\r\n				if (Q.back == NUM - 1) return 1;\r\n				else Q.base[Q.front = NUM - 1] = x;\r\n		}\r\n		else if (Q.front == Q.back)\r\n			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n			else Q.base[--Q.front] = x;\r\n		else if (Q.front == Q.back + 1) return 1;\r\n		else Q.base[--Q.front] = x;\r\n		return 0;\r\n	}\r\n	int push_back(deQueue &Q, Elemtype x) {\r\n		if (Q.front == Q.back)\r\n			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n			else Q.base[Q.back++] = x;\r\n		else if (Q.front < Q.back)\r\n			if (Q.back == NUM - 1)\r\n				if (Q.front == 1) return 1;\r\n				else Q.base[Q.back = 1] = x;\r\n			else Q.base[Q.back++] = x;\r\n		else if (Q.back + 1 == Q.front) return 1;\r\n		else Q.base[Q.back++] = x;\r\n		return 0;\r\n	}\r\n	int pop_front(deQueue &Q) {\r\n		if (Q.front == Q.back) return 1;\r\n		else if (Q.front < Q.back) ++Q.front;\r\n		else if (Q.front == NUM - 1) Q.front = 1;\r\n		else ++Q.front;\r\n		return 0;\r\n	}\r\n	int pop_back(deQueue &Q) {\r\n		if (Q.back > Q.front) --Q.back;\r\n		else if (Q.back == Q.front) return 1;\r\n		else if (Q.back == 1) Q.back = NUM - 1;\r\n		else --Q.back;\r\n		return 0;\r\n	}\r\n	int size(deQueue &Q) {\r\n		if (Q.back >= Q.front) return Q.back - Q.front;\r\n		else return Q.back + NUM - Q.front; \r\n	}\r\n	Elemtype front(deQueue &Q) {\r\n		return Q.base[Q.front];\r\n	}\r\n	Elemtype back(deQueue &Q) {\r\n		return Q.base[Q.back];\r\n	}\r\n}\r\nusing namespace deQueue;\r\nmyDeque q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	init(q);\r\n	push_back(q, {x, 0});\r\n	while (size(q)) {\r\n		pii t = front(q); pop_front(q);\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) push_front(q, {e[i].to, dis});\r\n			else push_back(q, {e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1064,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\nnamespace deQueue {\r\n	const int NUM = 100001;\r\n	typedef pii Elemtype; \r\n	typedef struct deQueue {\r\n		Elemtype base[NUM];\r\n		int front, back;\r\n	} myDeque;\r\n	void init(deQueue &Q) {\r\n		Q.back = Q.front = 1;\r\n	}\r\n	int push_front(deQueue &Q, Elemtype x) {\r\n		if (Q.front < Q.back) {\r\n			if (Q.front == 1)\r\n				if (Q.back == NUM - 1) return 1;\r\n				else Q.base[Q.front = NUM - 1] = x;\r\n			else Q.base[--Q.front] = x;\r\n		}\r\n		else if (Q.front == Q.back)\r\n			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n			else Q.base[--Q.front] = x;\r\n		else if (Q.front == Q.back + 1) return 1;\r\n		else Q.base[--Q.front] = x;\r\n		return 0;\r\n	}\r\n	int push_back(deQueue &Q, Elemtype x) {\r\n		if (Q.front == Q.back)\r\n			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n			else Q.base[Q.back++] = x;\r\n		else if (Q.front < Q.back)\r\n			if (Q.back == NUM - 1)\r\n				if (Q.front == 1) return 1;\r\n				else Q.base[Q.back = 1] = x;\r\n			else Q.base[Q.back++] = x;\r\n		else if (Q.back + 1 == Q.front) return 1;\r\n		else Q.base[Q.back++] = x;\r\n		return 0;\r\n	}\r\n	int pop_front(deQueue &Q) {\r\n		if (Q.front == Q.back) return 1;\r\n		else if (Q.front < Q.back) ++Q.front;\r\n		else if (Q.front == NUM - 1) Q.front = 1;\r\n		else ++Q.front;\r\n		return 0;\r\n	}\r\n	int pop_back(deQueue &Q) {\r\n		if (Q.back > Q.front) --Q.back;\r\n		else if (Q.back == Q.front) return 1;\r\n		else if (Q.back == 1) Q.back = NUM - 1;\r\n		else --Q.back;\r\n		return 0;\r\n	}\r\n	int size(deQueue &Q) {\r\n		if (Q.back >= Q.front) return Q.back - Q.front;\r\n		else return Q.back + NUM - Q.front; \r\n	}\r\n	Elemtype front(deQueue &Q) {\r\n		return Q.base[Q.front];\r\n	}\r\n	Elemtype back(deQueue &Q) {\r\n		return Q.base[Q.back];\r\n	}\r\n}\r\nusing namespace deQueue;\r\nmyDeque q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	init(q);\r\n	push_back(q, {x, 0});\r\n	while (size(q)) {\r\n		pii t = front(q); pop_front(q);\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) push_front(q, {e[i].to, dis});\r\n			else push_back(q, {e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1065,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\nnamespace deQueue {\r\n	const int NUM = 100001;\r\n	typedef pii Elemtype; \r\n	typedef struct deQueue {\r\n		Elemtype base[NUM];\r\n		int front, back;\r\n	} myDeque;\r\n	void init(deQueue &Q) {\r\n		Q.back = Q.front = 1;\r\n	}\r\n	int push_front(deQueue &Q, Elemtype x) {\r\n		if (Q.front < Q.back) {\r\n			if (Q.front == 1)\r\n				if (Q.back == NUM - 1) return 1;\r\n				else Q.base[Q.front = NUM - 1] = x;\r\n			else Q.base[--Q.front] = x;\r\n		}\r\n		else if (Q.front == Q.back)\r\n			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n			else Q.base[--Q.front] = x;\r\n		else if (Q.front == Q.back + 1) return 1;\r\n		else Q.base[--Q.front] = x;\r\n		return 0;\r\n	}\r\n	int push_back(deQueue &Q, Elemtype x) {\r\n		if (Q.front == Q.back)\r\n			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n			else Q.base[Q.back++] = x;\r\n		else if (Q.front < Q.back)\r\n			if (Q.back == NUM - 1)\r\n				if (Q.front == 1) return 1;\r\n				else Q.base[Q.back = 1] = x;\r\n			else Q.base[Q.back++] = x;\r\n		else if (Q.back + 1 == Q.front) return 1;\r\n		else Q.base[Q.back++] = x;\r\n		return 0;\r\n	}\r\n	int pop_front(deQueue &Q) {\r\n		if (Q.front == Q.back) return 1;\r\n		else if (Q.front < Q.back) ++Q.front;\r\n		else if (Q.front == NUM - 1) Q.front = 1;\r\n		else ++Q.front;\r\n		return 0;\r\n	}\r\n	int pop_back(deQueue &Q) {\r\n		if (Q.back > Q.front) --Q.back;\r\n		else if (Q.back == Q.front) return 1;\r\n		else if (Q.back == 1) Q.back = NUM - 1;\r\n		else --Q.back;\r\n		return 0;\r\n	}\r\n	int size(deQueue &Q) {\r\n		if (Q.back >= Q.front) return Q.back - Q.front;\r\n		else return Q.back + NUM - Q.front; \r\n	}\r\n	Elemtype front(deQueue &Q) {\r\n		return Q.base[Q.front];\r\n	}\r\n	Elemtype back(deQueue &Q) {\r\n		return Q.base[Q.back];\r\n	}\r\n}\r\nusing namespace deQueue;\r\nmyDeque q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	init(q);\r\n	push_back(q, {x, 0});\r\n	while (size(q)) {\r\n		pii t = front(q); pop_front(q);\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) push_front(q, {e[i].to, dis});\r\n			else push_back(q, {e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1066,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\n// namespace deQueue {\r\n// 	const int NUM = 100001;\r\n// 	typedef pii Elemtype; \r\n// 	typedef struct deQueue {\r\n// 		Elemtype base[NUM];\r\n// 		int front, back;\r\n// 	} myDeque;\r\n// 	void init(deQueue &Q) {\r\n// 		Q.back = Q.front = 1;\r\n// 	}\r\n// 	int push_front(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front < Q.back) {\r\n// 			if (Q.front == 1)\r\n// 				if (Q.back == NUM - 1) return 1;\r\n// 				else Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		}\r\n// 		else if (Q.front == Q.back)\r\n// 			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		else if (Q.front == Q.back + 1) return 1;\r\n// 		else Q.base[--Q.front] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int push_back(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front == Q.back)\r\n// 			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.front < Q.back)\r\n// 			if (Q.back == NUM - 1)\r\n// 				if (Q.front == 1) return 1;\r\n// 				else Q.base[Q.back = 1] = x;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.back + 1 == Q.front) return 1;\r\n// 		else Q.base[Q.back++] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_front(deQueue &Q) {\r\n// 		if (Q.front == Q.back) return 1;\r\n// 		else if (Q.front < Q.back) ++Q.front;\r\n// 		else if (Q.front == NUM - 1) Q.front = 1;\r\n// 		else ++Q.front;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_back(deQueue &Q) {\r\n// 		if (Q.back > Q.front) --Q.back;\r\n// 		else if (Q.back == Q.front) return 1;\r\n// 		else if (Q.back == 1) Q.back = NUM - 1;\r\n// 		else --Q.back;\r\n// 		return 0;\r\n// 	}\r\n// 	int size(deQueue &Q) {\r\n// 		if (Q.back >= Q.front) return Q.back - Q.front;\r\n// 		else return Q.back + NUM - Q.front; \r\n// 	}\r\n// 	Elemtype front(deQueue &Q) {\r\n// 		return Q.base[Q.front];\r\n// 	}\r\n// 	Elemtype back(deQueue &Q) {\r\n// 		return Q.base[Q.back];\r\n// 	}\r\n// }\r\n// using namespace deQueue;\r\n// myDeque q;\r\n\r\ndeque<int> q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	q.clear();\r\n	q.push_back({x, 0});\r\n	while (size(q)) {\r\n		pii t = q.front(); q.pop_front();\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) q.push_front({e[i].to, dis});\r\n			else q.push_back({e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1067,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\n// namespace deQueue {\r\n// 	const int NUM = 100001;\r\n// 	typedef pii Elemtype; \r\n// 	typedef struct deQueue {\r\n// 		Elemtype base[NUM];\r\n// 		int front, back;\r\n// 	} myDeque;\r\n// 	void init(deQueue &Q) {\r\n// 		Q.back = Q.front = 1;\r\n// 	}\r\n// 	int push_front(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front < Q.back) {\r\n// 			if (Q.front == 1)\r\n// 				if (Q.back == NUM - 1) return 1;\r\n// 				else Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		}\r\n// 		else if (Q.front == Q.back)\r\n// 			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		else if (Q.front == Q.back + 1) return 1;\r\n// 		else Q.base[--Q.front] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int push_back(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front == Q.back)\r\n// 			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.front < Q.back)\r\n// 			if (Q.back == NUM - 1)\r\n// 				if (Q.front == 1) return 1;\r\n// 				else Q.base[Q.back = 1] = x;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.back + 1 == Q.front) return 1;\r\n// 		else Q.base[Q.back++] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_front(deQueue &Q) {\r\n// 		if (Q.front == Q.back) return 1;\r\n// 		else if (Q.front < Q.back) ++Q.front;\r\n// 		else if (Q.front == NUM - 1) Q.front = 1;\r\n// 		else ++Q.front;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_back(deQueue &Q) {\r\n// 		if (Q.back > Q.front) --Q.back;\r\n// 		else if (Q.back == Q.front) return 1;\r\n// 		else if (Q.back == 1) Q.back = NUM - 1;\r\n// 		else --Q.back;\r\n// 		return 0;\r\n// 	}\r\n// 	int size(deQueue &Q) {\r\n// 		if (Q.back >= Q.front) return Q.back - Q.front;\r\n// 		else return Q.back + NUM - Q.front; \r\n// 	}\r\n// 	Elemtype front(deQueue &Q) {\r\n// 		return Q.base[Q.front];\r\n// 	}\r\n// 	Elemtype back(deQueue &Q) {\r\n// 		return Q.base[Q.back];\r\n// 	}\r\n// }\r\n// using namespace deQueue;\r\n// myDeque q;\r\n\r\ndeque<pii> q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	q.clear();\r\n	q.push_back({x, 0});\r\n	while (size(q)) {\r\n		pii t = q.front(); q.pop_front();\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) q.push_front({e[i].to, dis});\r\n			else q.push_back({e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1068,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\n// namespace deQueue {\r\n// 	const int NUM = 100001;\r\n// 	typedef pii Elemtype; \r\n// 	typedef struct deQueue {\r\n// 		Elemtype base[NUM];\r\n// 		int front, back;\r\n// 	} myDeque;\r\n// 	void init(deQueue &Q) {\r\n// 		Q.back = Q.front = 1;\r\n// 	}\r\n// 	int push_front(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front < Q.back) {\r\n// 			if (Q.front == 1)\r\n// 				if (Q.back == NUM - 1) return 1;\r\n// 				else Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		}\r\n// 		else if (Q.front == Q.back)\r\n// 			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		else if (Q.front == Q.back + 1) return 1;\r\n// 		else Q.base[--Q.front] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int push_back(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front == Q.back)\r\n// 			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.front < Q.back)\r\n// 			if (Q.back == NUM - 1)\r\n// 				if (Q.front == 1) return 1;\r\n// 				else Q.base[Q.back = 1] = x;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.back + 1 == Q.front) return 1;\r\n// 		else Q.base[Q.back++] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_front(deQueue &Q) {\r\n// 		if (Q.front == Q.back) return 1;\r\n// 		else if (Q.front < Q.back) ++Q.front;\r\n// 		else if (Q.front == NUM - 1) Q.front = 1;\r\n// 		else ++Q.front;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_back(deQueue &Q) {\r\n// 		if (Q.back > Q.front) --Q.back;\r\n// 		else if (Q.back == Q.front) return 1;\r\n// 		else if (Q.back == 1) Q.back = NUM - 1;\r\n// 		else --Q.back;\r\n// 		return 0;\r\n// 	}\r\n// 	int size(deQueue &Q) {\r\n// 		if (Q.back >= Q.front) return Q.back - Q.front;\r\n// 		else return Q.back + NUM - Q.front; \r\n// 	}\r\n// 	Elemtype front(deQueue &Q) {\r\n// 		return Q.base[Q.front];\r\n// 	}\r\n// 	Elemtype back(deQueue &Q) {\r\n// 		return Q.base[Q.back];\r\n// 	}\r\n// }\r\n// using namespace deQueue;\r\n// myDeque q;\r\n\r\ndeque<pii> q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	q.clear();\r\n	q.push_back({x, 0});\r\n	while (!q.empty()) {\r\n		pii t = q.front(); q.pop_front();\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) q.push_front({e[i].to, dis});\r\n			else q.push_back({e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1069,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\n// namespace deQueue {\r\n// 	const int NUM = 100001;\r\n// 	typedef pii Elemtype; \r\n// 	typedef struct deQueue {\r\n// 		Elemtype base[NUM];\r\n// 		int front, back;\r\n// 	} myDeque;\r\n// 	void init(deQueue &Q) {\r\n// 		Q.back = Q.front = 1;\r\n// 	}\r\n// 	int push_front(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front < Q.back) {\r\n// 			if (Q.front == 1)\r\n// 				if (Q.back == NUM - 1) return 1;\r\n// 				else Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		}\r\n// 		else if (Q.front == Q.back)\r\n// 			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		else if (Q.front == Q.back + 1) return 1;\r\n// 		else Q.base[--Q.front] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int push_back(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front == Q.back)\r\n// 			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.front < Q.back)\r\n// 			if (Q.back == NUM - 1)\r\n// 				if (Q.front == 1) return 1;\r\n// 				else Q.base[Q.back = 1] = x;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.back + 1 == Q.front) return 1;\r\n// 		else Q.base[Q.back++] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_front(deQueue &Q) {\r\n// 		if (Q.front == Q.back) return 1;\r\n// 		else if (Q.front < Q.back) ++Q.front;\r\n// 		else if (Q.front == NUM - 1) Q.front = 1;\r\n// 		else ++Q.front;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_back(deQueue &Q) {\r\n// 		if (Q.back > Q.front) --Q.back;\r\n// 		else if (Q.back == Q.front) return 1;\r\n// 		else if (Q.back == 1) Q.back = NUM - 1;\r\n// 		else --Q.back;\r\n// 		return 0;\r\n// 	}\r\n// 	int size(deQueue &Q) {\r\n// 		if (Q.back >= Q.front) return Q.back - Q.front;\r\n// 		else return Q.back + NUM - Q.front; \r\n// 	}\r\n// 	Elemtype front(deQueue &Q) {\r\n// 		return Q.base[Q.front];\r\n// 	}\r\n// 	Elemtype back(deQueue &Q) {\r\n// 		return Q.base[Q.back];\r\n// 	}\r\n// }\r\n// using namespace deQueue;\r\n// myDeque q;\r\n\r\ndeque<pii> q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	q.clear();\r\n	q.push_back({x, 0});\r\n	while (size(q)) {\r\n		pii t = q.front(); q.pop_front();\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) q.push_front({e[i].to, dis});\r\n			else q.push_back({e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1070,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\n// namespace deQueue {\r\n// 	const int NUM = 100001;\r\n// 	typedef pii Elemtype; \r\n// 	typedef struct deQueue {\r\n// 		Elemtype base[NUM];\r\n// 		int front, back;\r\n// 	} myDeque;\r\n// 	void init(deQueue &Q) {\r\n// 		Q.back = Q.front = 1;\r\n// 	}\r\n// 	int push_front(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front < Q.back) {\r\n// 			if (Q.front == 1)\r\n// 				if (Q.back == NUM - 1) return 1;\r\n// 				else Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		}\r\n// 		else if (Q.front == Q.back)\r\n// 			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		else if (Q.front == Q.back + 1) return 1;\r\n// 		else Q.base[--Q.front] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int push_back(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front == Q.back)\r\n// 			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.front < Q.back)\r\n// 			if (Q.back == NUM - 1)\r\n// 				if (Q.front == 1) return 1;\r\n// 				else Q.base[Q.back = 1] = x;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.back + 1 == Q.front) return 1;\r\n// 		else Q.base[Q.back++] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_front(deQueue &Q) {\r\n// 		if (Q.front == Q.back) return 1;\r\n// 		else if (Q.front < Q.back) ++Q.front;\r\n// 		else if (Q.front == NUM - 1) Q.front = 1;\r\n// 		else ++Q.front;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_back(deQueue &Q) {\r\n// 		if (Q.back > Q.front) --Q.back;\r\n// 		else if (Q.back == Q.front) return 1;\r\n// 		else if (Q.back == 1) Q.back = NUM - 1;\r\n// 		else --Q.back;\r\n// 		return 0;\r\n// 	}\r\n// 	int size(deQueue &Q) {\r\n// 		if (Q.back >= Q.front) return Q.back - Q.front;\r\n// 		else return Q.back + NUM - Q.front; \r\n// 	}\r\n// 	Elemtype front(deQueue &Q) {\r\n// 		return Q.base[Q.front];\r\n// 	}\r\n// 	Elemtype back(deQueue &Q) {\r\n// 		return Q.base[Q.back];\r\n// 	}\r\n// }\r\n// using namespace deQueue;\r\n// myDeque q;\r\n\r\ndeque<pii> q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	q.clear();\r\n	q.push_back({x, 0});\r\n	while (!q.empty()) {\r\n		pii t = q.front(); q.pop_front();\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) q.push_front({e[i].to, dis});\r\n			else q.push_back({e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1071,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\n\r\nnamespace graph {\r\n	int cnt, head[N];\r\n	struct node {\r\n		int to, next, w;\r\n	} e[M << 1];\r\n	void addEdge(int u, int v, int w) {\r\n		cnt++;\r\n		e[cnt].to = v;\r\n		e[cnt].w = w;\r\n		e[cnt].next = head[u];\r\n		head[u] = cnt;\r\n	}\r\n}\r\nusing namespace graph;\r\n\r\n// namespace deQueue {\r\n// 	const int NUM = 100001;\r\n// 	typedef pii Elemtype; \r\n// 	typedef struct deQueue {\r\n// 		Elemtype base[NUM];\r\n// 		int front, back;\r\n// 	} myDeque;\r\n// 	void init(deQueue &Q) {\r\n// 		Q.back = Q.front = 1;\r\n// 	}\r\n// 	int push_front(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front < Q.back) {\r\n// 			if (Q.front == 1)\r\n// 				if (Q.back == NUM - 1) return 1;\r\n// 				else Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		}\r\n// 		else if (Q.front == Q.back)\r\n// 			if (Q.front == 1) Q.base[Q.front = NUM - 1] = x;\r\n// 			else Q.base[--Q.front] = x;\r\n// 		else if (Q.front == Q.back + 1) return 1;\r\n// 		else Q.base[--Q.front] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int push_back(deQueue &Q, Elemtype x) {\r\n// 		if (Q.front == Q.back)\r\n// 			if (Q.back == NUM - 1) Q.base[Q.back] = x, Q.back = 1;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.front < Q.back)\r\n// 			if (Q.back == NUM - 1)\r\n// 				if (Q.front == 1) return 1;\r\n// 				else Q.base[Q.back = 1] = x;\r\n// 			else Q.base[Q.back++] = x;\r\n// 		else if (Q.back + 1 == Q.front) return 1;\r\n// 		else Q.base[Q.back++] = x;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_front(deQueue &Q) {\r\n// 		if (Q.front == Q.back) return 1;\r\n// 		else if (Q.front < Q.back) ++Q.front;\r\n// 		else if (Q.front == NUM - 1) Q.front = 1;\r\n// 		else ++Q.front;\r\n// 		return 0;\r\n// 	}\r\n// 	int pop_back(deQueue &Q) {\r\n// 		if (Q.back > Q.front) --Q.back;\r\n// 		else if (Q.back == Q.front) return 1;\r\n// 		else if (Q.back == 1) Q.back = NUM - 1;\r\n// 		else --Q.back;\r\n// 		return 0;\r\n// 	}\r\n// 	int size(deQueue &Q) {\r\n// 		if (Q.back >= Q.front) return Q.back - Q.front;\r\n// 		else return Q.back + NUM - Q.front; \r\n// 	}\r\n// 	Elemtype front(deQueue &Q) {\r\n// 		return Q.base[Q.front];\r\n// 	}\r\n// 	Elemtype back(deQueue &Q) {\r\n// 		return Q.base[Q.back];\r\n// 	}\r\n// }\r\n// using namespace deQueue;\r\n// myDeque q;\r\n\r\ndeque<pii> q;\r\n\r\nvoid bfs(int x) {\r\n	memset(vis, 0, sizeof vis);\r\n	q.clear();\r\n	q.push_back({x, 0});\r\n	while (!q.empty()) {\r\n		pii t = q.front(); q.pop_front();\r\n		int u = t.first, dis = t.second;\r\n		if (vis[u]) continue;\r\n		d[x][u] = min(d[x][u], dis);\r\n		vis[u] = 1;\r\n		for (int i = head[u]; i; i = e[i].next)\r\n			if (e[i].w == 0) q.push_front({e[i].to, dis});\r\n			else q.push_back({e[i].to, dis + 1});\r\n	}\r\n}\r\n\r\nint main() {\r\n	memset(d, 0x3f, sizeof d);\r\n	scanf(\"%d%d\", &n, &m);\r\n	for (int i = 1, u, v, w; i <= m; i++) {\r\n		scanf(\"%d%d%d\", &u, &v, &w);\r\n		addEdge(u, v, w);\r\n		addEdge(v, u, w);\r\n	}\r\n	for (int i = 1; i <= n; i++)\r\n		bfs(i);\r\n	scanf(\"%d\", &qNum);\r\n	for (int u, v; qNum--;) {\r\n		cin >> u >> v;\r\n		if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n		else printf(\"%d\\n\", d[u][v]);\r\n	}\r\n	return 0;\r\n}'),(1072,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n \r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\nvector<pii> g[N];\r\ndeque<pii> q;\r\n \r\nvoid bfs(int x) {\r\n    memset(vis, 0, sizeof vis);\r\n    q.clear();\r\n    q.push_back({x, 0});\r\n    while (!q.empty()) {\r\n        pii t = q.front(); q.pop_front();\r\n        int u = t.first, dis = t.second;\r\n        if (vis[u]) continue;\r\n        d[x][u] = min(d[x][u], dis);\r\n        vis[u] = 1;\r\n        for (pii v: g[u])\r\n            if (v.second == 0) q.push_front({v.first, dis});\r\n            else q.push_back({v.first, dis + 1});\r\n    }\r\n}\r\n \r\nint main() {\r\n    memset(d, 0x3f, sizeof d);\r\n    scanf(\"%d%d\", &n, &m);\r\n    for (int i = 1, u, v, w; i <= m; i++) {\r\n        scanf(\"%d%d%d\", &u, &v, &w);\r\n        g[u].push_back({v, w});\r\n        g[v].push_back({u, w});\r\n    }\r\n    for (int i = 1; i <= n; i++)\r\n        bfs(i);\r\n    scanf(\"%d\", &qNum);\r\n    for (int u, v; qNum--;) {\r\n        cin >> u >> v;\r\n        if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n        else printf(\"%d\\n\", d[u][v]);\r\n    }\r\n    return 0;\r\n}'),(1073,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> pii;\r\n \r\nconst int N = 1001, M = 10001;\r\nint n, m, qNum, d[N][N], vis[N];\r\nvector<pii> g[N];\r\ndeque<pii> q;\r\n \r\nvoid bfs(int x) {\r\n    memset(vis, 0, sizeof vis);\r\n    q.clear();\r\n    q.push_back({x, 0});\r\n    while (!q.empty()) {\r\n        pii t = q.front(); q.pop_front();\r\n        int u = t.first, dis = t.second;\r\n        if (vis[u]) continue;\r\n        d[x][u] = min(d[x][u], dis);\r\n        vis[u] = 1;\r\n        for (pii v: g[u])\r\n            if (v.second == 0) q.push_front({v.first, dis});\r\n            else q.push_back({v.first, dis + 1});\r\n    }\r\n}\r\n \r\nint main() {\r\n    memset(d, 0x3f, sizeof d);\r\n    scanf(\"%d%d\", &n, &m);\r\n    for (int i = 1, u, v, w; i <= m; i++) {\r\n        scanf(\"%d%d%d\", &u, &v, &w);\r\n        g[u].push_back({v, w});\r\n        g[v].push_back({u, w});\r\n    }\r\n    for (int i = 1; i <= n; i++)\r\n        bfs(i);\r\n    scanf(\"%d\", &qNum);\r\n    for (int u, v; qNum--;) {\r\n        cin >> u >> v;\r\n        if (d[u][v] == 0x3f3f3f3f) puts(\"INF\");\r\n        else printf(\"%d\\n\", d[u][v]);\r\n    }\r\n    return 0;\r\n}'),(1074,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    cout << \"Hello World!\" << endl;\r\n    return 0;\r\n}'),(1075,'#include <stdio.h>\r\n#include <string.h>\r\n#define max(a,b) ((a)>(b)?(a):(b))\r\nconst int N=1e3+10;//qwq\r\nconst int M=1e3+10;\r\nint /*w[N],v[N],*/f[N];\r\nint p[N][N];\r\nint t,n,m;\r\nint main()\r\n{\r\n	scanf(\"%d%d%d\",&t,&n,&m);\r\n	for(int i=1;i<=t;i++)\r\n		for(int j=1;j<=n;j++)\r\n			scanf(\"%d\",&p[i][j]);\r\n	for(int k=1;k<t;k++)\r\n	{\r\n		memset(f,0,sizeof f); \r\n		for(int i=1;i<=n;i++)\r\n			for(int j=p[k][i];j<=m;j++)\r\n				f[j]=max(f[j],f[j-p[k][i]]+p[k+1][i]-p[k][i]);\r\n		m+=f[m];\r\n	}\r\n	printf(\"%d\\n\",m);\r\n	return 0;\r\n}'),(1076,'#include <iostream>\r\n#include <cstring>\r\n#include <cstdio>\r\n\r\nusing namespace std;\r\nconst int MAXN = 105;\r\n\r\n//dp[k]表示手里剩k元现金的时候，明天早上都卖了以后的钱数\r\n//price[i][j]表示第i天第j件物品的价格\r\nint dp[10005], price[MAXN][MAXN];\r\n\r\nint main() {\r\n    int t, n, m, ans;\r\n    scanf(\"%d%d%d\", &t, &n, &m);\r\n    //先输入\r\n    for (int i = 1; i <= t; ++i) {\r\n        for (int j = 1; j <= n; ++j) {\r\n            scanf(\"%d\", &price[i][j]);\r\n        }\r\n    }\r\n    //第一天早上手里有m元\r\n    ans = m;\r\n    for (int i = 1; i < t; ++i) {\r\n        //先把数组赋值为负无穷\r\n        memset(dp, ~0x3f, sizeof(dp));\r\n        //什么都不买，今天早上有ans元，明天早上也是ans元\r\n        dp[ans] = ans;\r\n        //枚举第j个物品\r\n        for (int j = 1; j <= n; ++j) {\r\n            //手里有k元的时候，去推明天早上的钱\r\n            for (int k = ans; k >= price[i][j]; --k) {\r\n                //买一件物品，现金减少，赚一份差价，完全背包倒着循环\r\n                dp[k - price[i][j]] = max(dp[k - price[i][j]], dp[k] + price[i + 1][j] - price[i][j]);\r\n            }\r\n        }\r\n        //找一下明天早上收益最大\r\n        int ma = 0;\r\n        for (int j = 0; j <= ans; ++j) {\r\n            ma = max(ma, dp[j]);\r\n        }\r\n        //明天早上就有这么多钱了，继续赚钱\r\n        ans = ma;\r\n    }\r\n    cout << ans << endl;\r\n    return 0;\r\n}\r\n'),(1077,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int N = 105, M = 10005;\r\nint t, n, m, ans, mx, f[M], p[N][N];\r\n\r\nint main() {\r\n	cin >> t >> n >> m;\r\n	for (int i = 1; i <= t; i++)\r\n		for (int j = 1; j <= n; j++) \r\n			cin >> p[i][j];\r\n	ans = m;\r\n	for (int i = 1; i < t; i++) {\r\n		memset(f, ~0x3f, sizeof f);\r\n		f[ans] = ans;\r\n		for (int j = 1; j <= n; j++)\r\n			for (int k = ans; k >= p[i][j]; k--)\r\n				f[k - p[i][j]] = max(f[k - p[i][j]], f[k] + p[i + 1][j] - p[i][j]);\r\n		mx = 0;\r\n		for (int j = 0; j <= ans; j++)\r\n			mx = max(ma, f[j]);\r\n		ans = mx;\r\n	}\r\n	cout << ans << endl;\r\n	return 0;\r\n}\r\n'),(1078,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int N = 105, M = 10005;\r\nint t, n, m, ans, mx, f[M], p[N][N];\r\n\r\nint main() {\r\n	cin >> t >> n >> m;\r\n	for (int i = 1; i <= t; i++)\r\n		for (int j = 1; j <= n; j++) \r\n			cin >> p[i][j];\r\n	ans = m;\r\n	for (int i = 1; i < t; i++) {\r\n		memset(f, ~0x3f, sizeof f);\r\n		f[ans] = ans;\r\n		for (int j = 1; j <= n; j++)\r\n			for (int k = ans; k >= p[i][j]; k--)\r\n				f[k - p[i][j]] = max(f[k - p[i][j]], f[k] + p[i + 1][j] - p[i][j]);\r\n		mx = 0;\r\n		for (int j = 0; j <= ans; j++)\r\n			mx = max(mx, f[j]);\r\n		ans = mx;\r\n	}\r\n	cout << ans << endl;\r\n	return 0;\r\n}\r\n'),(1079,'#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nsigned main()\r\n{\r\n	ios::sync_with_stdio(0);\r\n\r\n	cout << \"Hello World!\";\r\n}\r\n/*\r\n██╗   ██╗ █████╗ ███╗   ██╗ ██████╗ ███████╗██████╗\r\n╚██╗ ██╔╝██╔══██╗████╗  ██║██╔════╝ ╚══███╔╝██╔══██╗\r\n ╚████╔╝ ███████║██╔██╗ ██║██║  ███╗  ███╔╝ ██║  ██║\r\n  ╚██╔╝  ██╔══██║██║╚██╗██║██║   ██║ ███╔╝  ██║  ██║\r\n   ██║   ██║  ██║██║ ╚████║╚██████╔╝███████╗██████╔╝\r\n   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚══════╝╚═════╝\r\n*/\r\n\r\n'),(1080,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n\r\nconst int N = 1001;\r\nint l, r, ans, mid, tmp1, tmp2, flag;\r\nint t, n, nlen, a[N], b[N], c[N], d[N];\r\n\r\nint isok(int len) {\r\n	memset(a, 0, sizeof a);\r\n	memset(b, 0, sizeof b);\r\n	tmp2 = (len - 1) << 1;\r\n	for (int i = len - 1, j = 0; i >= 0; i--)\r\n		a[j++] = c[i];\r\n	for (int i = 0; i < len; i++)\r\n		for (int j = 0; j < len; j++)\r\n			b[i + j] += a[i] * a[j];\r\n	len = (len << 1) - 1;\r\n	for (int i = 0; i < len; i++)\r\n		b[i + 1] += b[i] / 10, b[i] %= 10;\r\n	while (b[len])\r\n		b[len + 1] += b[len] / 10, b[len++] %= 10;\r\n	if (len - tmp2 < nlen) return -1;\r\n	if (len - tmp2 > nlen) return 1;\r\n	tmp2 = len - 1;\r\n	for (int i = len - 1, j = nlen - 1; i >= 0 && j >= 0; i--, j--) {\r\n		if (d[j] > b[i]) return -1;\r\n		if (d[j] < b[i]) return 1;\r\n		tmp2 = i - 1;\r\n	}\r\n	while (tmp2 >= 0)\r\n		if (b[tmp2--])\r\n			return 1;\r\n	return 0;\r\n}\r\n\r\nsigned main() {\r\n	scanf(\"%lld\", &t);\r\n	while (t--) {\r\n		memset(c, 0, sizeof c);\r\n		flag = nlen = 0;\r\n		scanf(\"%lld\", &n);\r\n		tmp1 = n;\r\n		while (tmp1) {\r\n			d[nlen++] = tmp1 % 10;\r\n			tmp1 /= 10;\r\n		}\r\n//		cerr << \"inited\" << endl;\r\n		l = 1, r = n;\r\n		while (l <= r) {\r\n			mid = (l + r) >> 1;\r\n			c[0] = mid;\r\n			tmp1 = isok(1);\r\n			if (tmp1 > 0) r = mid - 1;\r\n			else if (tmp1 < 0) ans = mid, l = mid + 1;\r\n			else if (tmp1 == 0) {\r\n				ans = mid, flag = 1;\r\n				break;\r\n			}\r\n		}\r\n		c[0] = ans;\r\n//		cerr << \"calced c[0]\" << endl;\r\n		for (int i = 1; i <= 120; i++) {\r\n			if (flag) continue;\r\n			l = 0, r = 9;\r\n			while (l <= r) {\r\n				mid = (l + r) / 2;\r\n				c[i] = mid;\r\n				tmp1 = isok(i + 1);\r\n				if (tmp1 > 0) r = mid - 1;\r\n				else if (tmp1 < 0) ans = mid, l = mid + 1;\r\n				else if (tmp1 == 0) {\r\n					ans = mid, flag = 1;\r\n					break;\r\n				}\r\n			}\r\n			c[i] = ans;\r\n//			cerr << \"calced c[\" << i << \"]\" << endl;\r\n		}\r\n		tmp1 = -1;\r\n		for (int i = 120; i >= 1; i--)\r\n			if (c[i]) {\r\n				tmp1 = i;\r\n				break;\r\n			}\r\n		printf(\"%lld%s\", c[0], (tmp1 != -1? \".\" : \"\"));\r\n		for (int i = 1; i <= tmp1; i++)\r\n			printf(\"%lld\", c[i]);\r\n		printf(\"\\n\");\r\n	}\r\n	return 0;\r\n}'),(1081,'#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n\r\nconst int N = 1001;\r\nint l, r, ans, mid, tmp1, tmp2, flag;\r\nint t, n, nlen, a[N], b[N], c[N], d[N];\r\n\r\nint isok(int len) {\r\n	memset(a, 0, sizeof a);\r\n	memset(b, 0, sizeof b);\r\n	tmp2 = (len - 1) << 1;\r\n	for (int i = len - 1, j = 0; i >= 0; i--)\r\n		a[j++] = c[i];\r\n	for (int i = 0; i < len; i++)\r\n		for (int j = 0; j < len; j++)\r\n			b[i + j] += a[i] * a[j];\r\n	len = (len << 1) - 1;\r\n	for (int i = 0; i < len; i++)\r\n		b[i + 1] += b[i] / 10, b[i] %= 10;\r\n	while (b[len])\r\n		b[len + 1] += b[len] / 10, b[len++] %= 10;\r\n	if (len - tmp2 < nlen) return -1;\r\n	if (len - tmp2 > nlen) return 1;\r\n	tmp2 = len - 1;\r\n	for (int i = len - 1, j = nlen - 1; i >= 0 && j >= 0; i--, j--) {\r\n		if (d[j] > b[i]) return -1;\r\n		if (d[j] < b[i]) return 1;\r\n		tmp2 = i - 1;\r\n	}\r\n	while (tmp2 >= 0)\r\n		if (b[tmp2--])\r\n			return 1;\r\n	return 0;\r\n}\r\n\r\nsigned main() {\r\n	scanf(\"%lld\", &t);\r\n	while (t--) {\r\n		memset(c, 0, sizeof c);\r\n		flag = nlen = 0;\r\n		scanf(\"%lld\", &n);\r\n		tmp1 = n;\r\n		while (tmp1) {\r\n			d[nlen++] = tmp1 % 10;\r\n			tmp1 /= 10;\r\n		}\r\n//		cerr << \"inited\" << endl;\r\n		l = 1, r = n;\r\n		while (l <= r) {\r\n			mid = (l + r) >> 1;\r\n			c[0] = mid;\r\n			tmp1 = isok(1);\r\n			if (tmp1 > 0) r = mid - 1;\r\n			else if (tmp1 < 0) ans = mid, l = mid + 1;\r\n			else if (tmp1 == 0) {\r\n				ans = mid, flag = 1;\r\n				break;\r\n			}\r\n		}\r\n		c[0] = ans;\r\n//		cerr << \"calced c[0]\" << endl;\r\n		for (int i = 1; i <= 120; i++) {\r\n			if (flag) continue;\r\n			l = 0, r = 9;\r\n			while (l <= r) {\r\n				mid = (l + r) / 2;\r\n				c[i] = mid;\r\n				tmp1 = isok(i + 1);\r\n				if (tmp1 > 0) r = mid - 1;\r\n				else if (tmp1 < 0) ans = mid, l = mid + 1;\r\n				else if (tmp1 == 0) {\r\n					ans = mid, flag = 1;\r\n					break;\r\n				}\r\n			}\r\n			c[i] = ans;\r\n//			cerr << \"calced c[\" << i << \"]\" << endl;\r\n		}\r\n		tmp1 = -1;\r\n		for (int i = 120; i >= 1; i--)\r\n			if (c[i]) {\r\n				tmp1 = i;\r\n				break;\r\n			}\r\n		printf(\"%lld%s\", c[0], (tmp1 != -1? \".\" : \"\"));\r\n		for (int i = 1; i <= tmp1; i++)\r\n			printf(\"%lld\", c[i]);\r\n		printf(\"\\n\");\r\n	}\r\n	return 0;\r\n}'),(1082,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct folder {\r\n	bool type; // 1: folder, 0: file\r\n	string name, full;\r\n	map<string, bool> has;\r\n	map<string, folder*> child;\r\n	folder* father;\r\n} *root, *now, *p;\r\n\r\n/*\r\n * @brief Init File System\r\n * @example initFS()\r\n */\r\nvoid initFS() {\r\n	root = new folder;\r\n	root->name = \"\";\r\n	root->full = \"/\";\r\n	root->father = NULL;\r\n	now = root;\r\n	p = NULL;\r\n}\r\n\r\n/*\r\n * @brief Cut a string with \"/\"\r\n * @example cut(\"/root/c++\") -> [\"root\", \"c++\"]\r\n */\r\nvector<string> cut(string s) {\r\n	unsigned last = -1U;\r\n	vector<string> ret;\r\n	for (unsigned i = 0; i < s.size(); i++)\r\n		if (s[i] == \'/\') {\r\n//			cerr << \"Found s[\" << i << \"] is \'/\'\" << endl;\r\n			if (last == -1U) goto setLast;\r\n			ret.push_back(s.substr(last, i - last));\r\n			setLast: last = i + 1;\r\n		}\r\n	// avoid string like \"/root/c++/\"\r\n	if (last < s.size())\r\n		ret.push_back(s.substr(last));\r\n	return ret;\r\n}\r\n\r\n/*\r\n * @brief MaKe DIRectory\r\n * @example mkdir(\"/home/c++\") or mkdir(\"c++\")\r\n */\r\nvoid mkdir(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	for (string x: sep) {\r\n		if (p->has[x]) { \r\n			if (p->child[x]->type) p = p->child[x];\r\n			else {\r\n				cout << \"err\" << endl;\r\n				return;\r\n			}\r\n		} else {\r\n			p->has[x] = 1;\r\n			p->child[x] = new folder;\r\n			p->child[x]->type = 1;\r\n			p->child[x]->name = x;\r\n			p->child[x]->full = p->full + x + \"/\";\r\n			p->child[x]->father = p;\r\n			p = p->child[x];\r\n		}\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief See all the file and directory below now folder\r\n * @example ls()\r\n */\r\nvoid ls() {\r\n	bool flag = 0;\r\n	for (auto x: now->child) {\r\n		flag = 1;\r\n		if (x.second->type == 0) cout << \"*\";\r\n		cout << x.first << \" \";\r\n	}\r\n	if (!flag) cout << \"EMPTY\";\r\n	cout << endl;\r\n}\r\n\r\n/*\r\n * @brief Choose Directory\r\n * @example cd(\"c++\") or cd(\"../..\") etc\r\n */\r\nvoid cd(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	try { \r\n		for (string x: sep) {\r\n			if (x == \".\") continue;\r\n			else if (x == \"..\") p = p->father;\r\n			else if (!p->has[x]) throw \"err\";\r\n			else p = p->child[x];\r\n			if (p == NULL) throw \"err\";\r\n			if (p->type == 0) throw \"err\"; \r\n		}\r\n		now = p;\r\n	} catch (...) {\r\n		cout << \"err\" << endl;\r\n		return;\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief ReMove directory or file\r\n * @exapmle rm(\"c++\") or rm(\"/home\")\r\n */\r\nvoid rm(string s) {\r\n	string ori = (s[0] == \'/\'? \"\" : \"/\") + s;\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	try {\r\n		vector<string> tmp = cut(ori);\r\n		while (tmp.size() && *(--tmp.end()) == \".\")\r\n			tmp.pop_back();\r\n		if (tmp.empty()) throw \"err\";\r\n		for (string x: sep) {\r\n			if (x == \".\") continue;\r\n			else if (x == \"..\") p = p->father;\r\n			else if (!p->has[x]) throw \"err\";\r\n			else p = p->child[x];\r\n			if (p == NULL) throw \"err\"; \r\n		}\r\n		folder *temp = p;\r\n		p = p->father;\r\n		p->has.erase(*(--sep.end()));\r\n		p->child.erase(*(--sep.end()));\r\n		delete temp;\r\n	} catch (...) {\r\n		cout << \"err\" << endl;\r\n		return;\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief Create a file\r\n * @example touch(\"/etc/passwd\")\r\n */\r\nvoid touch(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	for (string x: sep) {\r\n		if (p->has[x]) { \r\n			if (p->child[x]->type) p = p->child[x];\r\n			else {\r\n				cout << \"err\" << endl;\r\n				return;\r\n			}\r\n		} else {\r\n			p->has[x] = 1;\r\n			p->child[x] = new folder;\r\n			p->child[x]->type = 1;\r\n			p->child[x]->name = x;\r\n			p->child[x]->full = p->full + x + \"/\";\r\n			p->child[x]->father = p;\r\n			p = p->child[x];\r\n		}\r\n	}\r\n	p = p->father;\r\n	p->child[*(--sep.end())]->type = 0;\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief See now work directory\r\n * @example pwd()\r\n */\r\nvoid pwd() {\r\n	cout << now->full << endl;\r\n}\r\n\r\nint main() {\r\n	int n;\r\n	cin >> n;\r\n	initFS();\r\n	while (n--) {\r\n		string op;\r\n		cin >> op;\r\n		if (op == \"mkdir\") {\r\n			string x;\r\n			cin >> x;\r\n			mkdir(x);\r\n		} else if (op == \"ls\") {\r\n			ls();\r\n		} else if (op == \"cd\") {\r\n			string x;\r\n			cin >> x;\r\n			cd(x);\r\n		} else if (op == \"rm\") {\r\n			string x;\r\n			cin >> x;\r\n			rm(x);\r\n		} else if (op == \"touch\") {\r\n			string x;\r\n			cin >> x;\r\n			touch(x);\r\n		} else if (op == \"pwd\") {\r\n			pwd();\r\n		}\r\n	}\r\n	return 0;\r\n}'),(1083,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct folder {\r\n	bool type; // 1: folder, 0: file\r\n	string name, full;\r\n	map<string, bool> has;\r\n	map<string, folder*> child;\r\n	folder* father;\r\n} *root, *now, *p;\r\n\r\n/*\r\n * @brief Init File System\r\n * @example initFS()\r\n */\r\nvoid initFS() {\r\n	root = new folder;\r\n	root->name = \"\";\r\n	root->full = \"/\";\r\n	root->father = NULL;\r\n	now = root;\r\n	p = NULL;\r\n}\r\n\r\n/*\r\n * @brief Cut a string with \"/\"\r\n * @example cut(\"/root/c++\") -> [\"root\", \"c++\"]\r\n */\r\nvector<string> cut(string s) {\r\n	unsigned last = -1U;\r\n	vector<string> ret;\r\n	for (unsigned i = 0; i < s.size(); i++)\r\n		if (s[i] == \'/\') {\r\n//			cerr << \"Found s[\" << i << \"] is \'/\'\" << endl;\r\n			if (last == -1U) goto setLast;\r\n			ret.push_back(s.substr(last, i - last));\r\n			setLast: last = i + 1;\r\n		}\r\n	// avoid string like \"/root/c++/\"\r\n	if (last < s.size())\r\n		ret.push_back(s.substr(last));\r\n	return ret;\r\n}\r\n\r\n/*\r\n * @brief MaKe DIRectory\r\n * @example mkdir(\"/home/c++\") or mkdir(\"c++\")\r\n */\r\nvoid mkdir(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	for (string x: sep) {\r\n		if (p->has[x]) { \r\n			if (p->child[x]->type) p = p->child[x];\r\n			else {\r\n				cout << \"err\" << endl;\r\n				return;\r\n			}\r\n		} else {\r\n			p->has[x] = 1;\r\n			p->child[x] = new folder;\r\n			p->child[x]->type = 1;\r\n			p->child[x]->name = x;\r\n			p->child[x]->full = p->full + x + \"/\";\r\n			p->child[x]->father = p;\r\n			p = p->child[x];\r\n		}\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief See all the file and directory below now folder\r\n * @example ls()\r\n */\r\nvoid ls() {\r\n	bool flag = 0;\r\n	for (auto x: now->child) {\r\n		flag = 1;\r\n		if (x.second->type == 0) cout << \"*\";\r\n		cout << x.first << \" \";\r\n	}\r\n	if (!flag) cout << \"EMPTY\";\r\n	cout << endl;\r\n}\r\n\r\n/*\r\n * @brief Choose Directory\r\n * @example cd(\"c++\") or cd(\"../..\") etc\r\n */\r\nvoid cd(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	try { \r\n		for (string x: sep) {\r\n			if (x == \".\") continue;\r\n			else if (x == \"..\") p = p->father;\r\n			else if (!p->has[x]) throw \"err\";\r\n			else p = p->child[x];\r\n			if (p == NULL) throw \"err\";\r\n			if (p->type == 0) throw \"err\"; \r\n		}\r\n		now = p;\r\n	} catch (...) {\r\n		cout << \"err\" << endl;\r\n		return;\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief ReMove directory or file\r\n * @exapmle rm(\"c++\") or rm(\"/home\")\r\n */\r\nvoid rm(string s) {\r\n	string ori = (s[0] == \'/\'? \"\" : \"/\") + s;\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	try {\r\n		vector<string> tmp = cut(ori);\r\n		while (tmp.size() && *(--tmp.end()) == \".\")\r\n			tmp.pop_back();\r\n		if (tmp.empty()) throw \"err\";\r\n		for (string x: sep) {\r\n			if (x == \".\") continue;\r\n			else if (x == \"..\") p = p->father;\r\n			else if (!p->has[x]) throw \"err\";\r\n			else p = p->child[x];\r\n			if (p == NULL) throw \"err\"; \r\n		}\r\n		folder *temp = p;\r\n		p = p->father;\r\n		p->has.erase(*(--sep.end()));\r\n		p->child.erase(*(--sep.end()));\r\n		delete temp;\r\n	} catch (...) {\r\n		cout << \"err\" << endl;\r\n		return;\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief Create a file\r\n * @example touch(\"/etc/passwd\")\r\n */\r\nvoid touch(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	for (string x: sep) {\r\n		if (p->has[x]) { \r\n			if (p->child[x]->type) p = p->child[x];\r\n			else {\r\n				cout << \"err\" << endl;\r\n				return;\r\n			}\r\n		} else {\r\n			p->has[x] = 1;\r\n			p->child[x] = new folder;\r\n			p->child[x]->type = 1;\r\n			p->child[x]->name = x;\r\n			p->child[x]->full = p->full + x + \"/\";\r\n			p->child[x]->father = p;\r\n			p = p->child[x];\r\n		}\r\n	}\r\n	p = p->father;\r\n	p->child[*(--sep.end())]->type = 0;\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief See now work directory\r\n * @example pwd()\r\n */\r\nvoid pwd() {\r\n	cout << now->full << endl;\r\n}\r\n\r\nint main() {\r\n	int n;\r\n	cin >> n;\r\n	initFS();\r\n	while (n--) {\r\n		string op;\r\n		cin >> op;\r\n		if (op == \"mkdir\") {\r\n			string x;\r\n			cin >> x;\r\n			mkdir(x);\r\n		} else if (op == \"ls\") {\r\n			ls();\r\n		} else if (op == \"cd\") {\r\n			string x;\r\n			cin >> x;\r\n			cd(x);\r\n		} else if (op == \"rm\") {\r\n			string x;\r\n			cin >> x;\r\n			rm(x);\r\n		} else if (op == \"touch\") {\r\n			string x;\r\n			cin >> x;\r\n			touch(x);\r\n		} else if (op == \"pwd\") {\r\n			pwd();\r\n		}\r\n	}\r\n	return 0;\r\n}'),(1084,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct folder {\r\n	bool type; // 1: folder, 0: file\r\n	string name, full;\r\n	map<string, bool> has;\r\n	map<string, folder*> child;\r\n	folder* father;\r\n} *root, *now, *p;\r\n\r\n/*\r\n * @brief Init File System\r\n * @example initFS()\r\n */\r\nvoid initFS() {\r\n	root = new folder;\r\n	root->type = 1;\r\n	root->name = \"\";\r\n	root->full = \"/\";\r\n	root->father = NULL;\r\n	now = root;\r\n	p = NULL;\r\n}\r\n\r\n/*\r\n * @brief Cut a string with \"/\"\r\n * @example cut(\"/root/c++\") -> [\"root\", \"c++\"]\r\n */\r\nvector<string> cut(string s) {\r\n	unsigned last = -1U;\r\n	vector<string> ret;\r\n	for (unsigned i = 0; i < s.size(); i++)\r\n		if (s[i] == \'/\') {\r\n//			cerr << \"Found s[\" << i << \"] is \'/\'\" << endl;\r\n			if (last == -1U) goto setLast;\r\n			ret.push_back(s.substr(last, i - last));\r\n			setLast: last = i + 1;\r\n		}\r\n	// avoid string like \"/root/c++/\"\r\n	if (last < s.size())\r\n		ret.push_back(s.substr(last));\r\n	return ret;\r\n}\r\n\r\n/*\r\n * @brief MaKe DIRectory\r\n * @example mkdir(\"/home/c++\") or mkdir(\"c++\")\r\n */\r\nvoid mkdir(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	bool flag = 0;\r\n	for (string x: sep) {\r\n		if (p->has[x]) { \r\n			if (p->child[x]->type) p = p->child[x];\r\n			else {\r\n				cout << \"err\" << endl;\r\n				return;\r\n			}\r\n		} else {\r\n			flag = 1;\r\n			p->has[x] = 1;\r\n			p->child[x] = new folder;\r\n			p->child[x]->type = 1;\r\n			p->child[x]->name = x;\r\n			p->child[x]->full = p->full + x + \"/\";\r\n			p->child[x]->father = p;\r\n			p = p->child[x];\r\n		}\r\n	}\r\n	if (flag == 0) cout << \"err\" << endl;\r\n	else cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief See all the file and directory below now folder\r\n * @example ls()\r\n */\r\nvoid ls() {\r\n	bool flag = 0;\r\n	for (auto x: now->child) {\r\n		flag = 1;\r\n		if (x.second->type == 0) cout << \"*\";\r\n		cout << x.first << \" \";\r\n	}\r\n	if (!flag) cout << \"EMPTY\";\r\n	cout << endl;\r\n}\r\n\r\n/*\r\n * @brief Choose Directory\r\n * @example cd(\"c++\") or cd(\"../..\") etc\r\n */\r\nvoid cd(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	try { \r\n		for (string x: sep) {\r\n			if (x == \".\") continue;\r\n			else if (x == \"..\") p = p->father;\r\n			else if (!p->has[x]) throw \"err\";\r\n			else p = p->child[x];\r\n			if (p == NULL) throw \"err\";\r\n			if (p->type == 0) throw \"err\"; \r\n		}\r\n		now = p;\r\n	} catch (...) {\r\n		cout << \"err\" << endl;\r\n		return;\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief ReMove directory or file\r\n * @exapmle rm(\"c++\") or rm(\"/home\")\r\n */\r\nvoid rm(string s) {\r\n	string ori = (s[0] == \'/\'? \"\" : \"/\") + s;\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	try {\r\n		vector<string> tmp = cut(ori);\r\n		while (tmp.size() && *(--tmp.end()) == \".\")\r\n			tmp.pop_back();\r\n		if (tmp.empty()) throw \"err\";\r\n		for (string x: sep) {\r\n			if (x == \".\") continue;\r\n			else if (x == \"..\") p = p->father;\r\n			else if (!p->has[x]) throw \"err\";\r\n			else p = p->child[x];\r\n			if (p == NULL) throw \"err\"; \r\n		}\r\n		folder *temp = p;\r\n		p = p->father;\r\n		p->has.erase(*(--sep.end()));\r\n		p->child.erase(*(--sep.end()));\r\n		delete temp;\r\n	} catch (...) {\r\n		cout << \"err\" << endl;\r\n		return;\r\n	}\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief Create a file\r\n * @example touch(\"/etc/passwd\")\r\n */\r\nvoid touch(string s) {\r\n	if (s[0] != \'/\') s = now->full + s;\r\n	vector<string> sep = cut(s);\r\n	p = root;\r\n	for (string x: sep) {\r\n		if (p->has[x]) { \r\n			if (p->child[x]->type) p = p->child[x];\r\n			else {\r\n				cout << \"err\" << endl;\r\n				return;\r\n			}\r\n		} else {\r\n			p->has[x] = 1;\r\n			p->child[x] = new folder;\r\n			p->child[x]->type = 1;\r\n			p->child[x]->name = x;\r\n			p->child[x]->full = p->full + x + \"/\";\r\n			p->child[x]->father = p;\r\n			p = p->child[x];\r\n		}\r\n	}\r\n	p = p->father;\r\n	p->child[*(--sep.end())]->type = 0;\r\n	cout << \"ok\" << endl;\r\n}\r\n\r\n/*\r\n * @brief See now work directory\r\n * @example pwd()\r\n */\r\nvoid pwd() {\r\n	cout << now->full << endl;\r\n}\r\n\r\nint main() {\r\n	int n;\r\n	cin >> n;\r\n	initFS();\r\n	while (n--) {\r\n		string op;\r\n		cin >> op;\r\n		if (op == \"mkdir\") {\r\n			string x;\r\n			cin >> x;\r\n			mkdir(x);\r\n		} else if (op == \"ls\") {\r\n			ls();\r\n		} else if (op == \"cd\") {\r\n			string x;\r\n			cin >> x;\r\n			cd(x);\r\n		} else if (op == \"rm\") {\r\n			string x;\r\n			cin >> x;\r\n			rm(x);\r\n		} else if (op == \"touch\") {\r\n			string x;\r\n			cin >> x;\r\n			touch(x);\r\n		} else if (op == \"pwd\") {\r\n			pwd();\r\n		}\r\n	}\r\n	return 0;\r\n}'),(1085,'public class Main {\r\n	public static void main(String[] args) {\r\n		System.out.println(\"Hello World!\"); // 在这里插入 Hello World!\r\n	}\r\n}\r\n'),(1086,'<?php\r\necho \"\"; // 在这里插入 Hello World!\r\n'),(1087,'<?php\r\necho \"Hello World!\"; // 在这里插入 Hello World!\r\n'),(1088,'using System;\r\n\r\npublic class Main {\r\n	private static void Main(string[] args) {\r\n		Console.WriteLine(\"Hello World!\"); // 在这里插入 Hello World!\r\n	}\r\n}\r\n'),(1089,'using System;\r\n\r\npublic class HelloWorld {\r\n	private static void Main(string[] args) {\r\n		Console.WriteLine(\"Hello World!\"); // 在这里插入 Hello World!\r\n	}\r\n}\r\n'),(1090,'console.log(\"Hello World!\") // 在这里插入 Hello World!\r\nprocess.exit()\r\n'),(1091,'console.log(\"Hello World!\") // 在这里插入 Hello World!\r\nprocess.exit()\r\n'),(1092,'package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n	fmt.Println(\"Hello World\") // 在这里插入 Hello World!\r\n}\r\n'),(1093,'package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n	fmt.Println(\"Hello World\") // 在这里插入 Hello World!\r\n}\r\n'),(1094,'set serveroutput on;\r\n\r\nDECLARE\r\n	message	varchar2(20) := \'Hello World!\'; -- 在这里插入 Hello World!\r\nBEGIN\r\n	dbms_output.put_line(message);\r\nEND;\r\n\r\n/\r\n'),(1095,'console.log(\"Hello World!\") // 在这里插入 Hello World!\r\nprocess.exit()\r\n');
/*!40000 ALTER TABLE `source_code_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `topic`
--

DROP TABLE IF EXISTS `topic`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `topic` (
  `tid` int(11) NOT NULL AUTO_INCREMENT,
  `title` varbinary(60) NOT NULL,
  `status` int(11) NOT NULL DEFAULT '0',
  `top_level` int(11) NOT NULL DEFAULT '0',
  `cid` int(11) DEFAULT NULL,
  `pid` int(11) NOT NULL,
  `author_id` varchar(48) NOT NULL,
  PRIMARY KEY (`tid`),
  KEY `cid` (`cid`,`pid`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `topic`
--

LOCK TABLES `topic` WRITE;
/*!40000 ALTER TABLE `topic` DISABLE KEYS */;
INSERT INTO `topic` VALUES (1,_binary 'Welcome to GXOJ',2,0,0,0,'admin');
/*!40000 ALTER TABLE `topic` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `users` (
  `user_id` varchar(48) NOT NULL DEFAULT '',
  `email` varchar(100) DEFAULT NULL,
  `submit` int(11) DEFAULT '0',
  `solved` int(11) DEFAULT '0',
  `defunct` char(1) NOT NULL DEFAULT 'N',
  `ip` varchar(46) NOT NULL DEFAULT '',
  `accesstime` datetime DEFAULT NULL,
  `volume` int(11) NOT NULL DEFAULT '1',
  `language` int(11) NOT NULL DEFAULT '1',
  `password` varchar(32) DEFAULT NULL,
  `reg_time` datetime DEFAULT NULL,
  `nick` varchar(20) NOT NULL DEFAULT '',
  `school` varchar(20) NOT NULL DEFAULT '',
  PRIMARY KEY (`user_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` VALUES ('admin','3562907147@qq.com',26,17,'N','49.77.72.76','2022-12-21 15:43:12',1,1,'1xeAw0o6CC5r9VqplDN7j0zs64gzMGI1','2022-05-05 08:46:42','xcx',''),('yangzhibo123','5241164@qq.com',14,3,'N','','2022-08-16 21:18:46',1,1,'BCbLgPwwMMKpxf/dkKAfQz/9dNcwYWMz','2022-05-06 08:25:17','yzb',''),('DerekXu','1613591793@qq.com',10,4,'N','180.111.51.240','2022-11-04 20:03:13',1,1,'djXY2ON8yHZ6p71Oj+/gZDvW5O01YThk','2022-05-06 08:33:21','xyy','南京外国语学校仙林分校小学部'),('qianruiyi','3051215984@qq.com',0,0,'N','183.209.50.194','2022-10-24 21:50:27',1,1,'KAsMQ4brGYKB8ca3k67yKnaAcJwzM2E5','2022-05-06 08:56:46','qry','南京玄武外国语学校附属小学'),('mhb2010','31957973@qq.com',3,0,'N','180.110.197.159','2022-05-20 17:54:55',1,1,'IR5BU3lfZPj0aNl4jyxBOti0fW84MTQ2','2022-05-11 07:27:25','mhb',''),('lihaoze','3585473072@qq.com',1,1,'N','112.20.78.176','2022-05-28 20:54:43',1,1,'NdHaLmU/3uv3KTKsWtOYZOZHWwwwM2Vm','2022-05-11 08:03:26','lhz',''),('adminxcx','3562907147@qq.com',9,3,'N','49.77.72.76','2022-10-16 17:42:21',1,1,'ePpmJvq4MvPNoncUfCNySExPAOZmOTM0','2022-05-11 08:14:23','xcx','XCX 的小号'),('wangzining','193086775@qq.com',0,0,'N','117.62.165.126','2022-05-22 09:19:30',1,1,'w2ugJKB8sDw9WoEiKknFOpGDhiY5MTAy','2022-05-22 09:19:30','wzn',''),('xcx0902','3562907147@qq.com',4,1,'N','180.109.29.36','2022-09-09 21:20:28',1,1,'mhY4lCLNu2fzoJiRav+367Pe0y0yMDdl','2022-08-17 21:02:10','xcx','XCX 用来测试的账号'),('test_smtp','xuchenxuan@uuf.me',0,0,'Y','180.109.29.36','2022-08-21 21:20:20',1,1,'rBCOx8uFjaxoc/Nrc2Vu00Iu02pmZDRk','2022-08-21 21:20:20','xcx',''),('FReQuenter','frequenter5156@126.com',0,0,'N','49.77.60.242','2022-08-26 11:02:25',1,1,'i/wJkVkMP/eD46Qb2Tnn3qbSBJI0NTYz','2022-08-26 11:02:25','frq','NFLS'),('tommychen','123123@123123.com',0,0,'N','112.23.190.51','2022-08-26 21:03:36',1,1,'dMcZWdAMmBcf4IGPDk0dzL2Wkg01ZTVi','2022-08-26 21:03:36','czq',''),('oimaster','oi_master@yeah.net',0,0,'N','121.237.136.18','2022-09-04 13:47:13',1,1,'L1pCtzp0hJRgcm2drziL04wnaekwYmUy','2022-08-27 08:54:47','zty','XWFLS'),('yangzd','1622269780@qq.com',1,1,'N','114.222.131.88','2022-10-02 00:43:19',1,1,'UzlAT263s4UhxvrVt6sL+0o8ostiOWE3','2022-08-28 00:16:01','yzd','南京秦淮外国语学校'),('LCN','2696571637@qq.com',0,0,'N','117.60.76.238','2022-09-04 14:15:59',1,1,'Qjdb7mv2BWdQG4JR5RKpg/Rh7npmZjdm','2022-09-04 14:15:59','lcn','明道'),('GX_halxf08','2396257240@qq.com',0,0,'N','114.106.123.142','2022-11-11 21:06:45',1,1,'pxVKPhTXMKZjIReGfU4YbHejvLlkZDk5','2022-09-04 18:21:36','xzh','芜湖市师范大学附属小学'),('yhq123','512655189@qq.com',1,1,'N','180.109.90.20','2022-11-26 09:02:07',1,1,'5XsFfSCKcq0+C6Q7SwGFRQq4hSU5OWZi','2022-09-10 09:38:46','yhq',''),('sszcdjr','2780034817@qq.com',0,0,'N','49.74.95.30','2022-09-13 21:27:48',1,1,'At2ngYu/3xnwlSnUoHwPbyH5W8A1ZTRk','2022-09-11 21:55:37','zxx','NFLS'),('test_reg_remind','3562907147@qq.com',0,0,'Y','49.77.9.214','2022-09-19 18:21:55',1,1,'2D+qsIOUeQLoxbFdGcjt25PiSU4wNjdj','2022-09-19 18:21:55','???',''),('JerryCKB','2392808489@qq.com',0,0,'N','101.224.100.228','2022-09-28 21:03:57',1,1,'wMoBtaCHhY7QrVenqs8hcToOpe84Yzc1','2022-09-28 21:03:57','ckb',''),('Derek0919','1613591793@qq.com',0,0,'N','180.111.27.242','2022-11-04 20:05:31',1,1,'hbfgiufIEdHL5Np8qft/IdB+stllYjkw','2022-11-04 19:59:31','xyy','NFLSXC');
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2022-12-21 21:30:02
